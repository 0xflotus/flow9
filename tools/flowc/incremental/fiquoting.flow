import tools/flowc/incremental/fiexp;
import tools/flowc/incremental/fi_helpers;
import runtime;

export {
    expandFiQuote(f : FiExp, start : int) -> FiExp;
}

expandFiQuote(f : FiExp, qstart : int) -> FiExp {
	mkstruct = \name : string, args : [FiExp] -> {
		FiCallPrim(FcStructPrim(name), args, FiTypeName(name, []), qstart);
	}
	todo = \ -> {
		println("TODO: Quote");
		println(f);
		f;
	}
	switch (f) {
		FiVoid(start): mkstruct("QVoid", []);
		FiBool(b, start): mkstruct("QBool", [f]);
		FiInt(i, start): mkstruct("QInt", [f]);
		FiString(s, start): mkstruct("QString", [f]);
		FiDouble(d, start): mkstruct("QDouble", [f]);
		FiCallPrim(op, args, t, start): {
			mkop = \name -> {
				mkstruct("QCallPrim", [
					mkstruct(name, []), 
					FiCallPrim(
						FcArrayPrim(),
						expandFiQuotes(args, start),
						FiTypeName("QExp", []),
						start
					)
				]);
			}
			switch (op) {
				FcUnquote(): unquote(args[0]);
				FcPlusPrim(): mkop("QPlusPrim");
				FcOrPrim(): mkop("QOrPrim");
				FcAndPrim(): mkop("QAndPrim");
				FcNotPrim(): mkop("QNotPrim");
				FcEqPrim(): mkop("QEqPrim");
				FcNePrim(): mkop("QNePrim");
				FcLePrim(): mkop("QLePrim");
				FcGePrim(): mkop("QGePrim");
				FcLtPrim(): mkop("QLtPrim");
				FcGtPrim(): mkop("QGtPrim");
				FcMinusPrim(): mkop("QMinusPrim");
				FcMulPrim(): mkop("QMulPrim");
				FcDivPrim(): mkop("QDivPrim");
				FcModPrim(): mkop("QModPrim");
				FcNegPrim(): mkop("QNegPrim");
				FcArrayPrim(): mkop("QArrayPrim");
				FcIndexPrim(): mkop("QIndexPrim");
				FcDerefPrim(): mkop("QDerefPrim");
				FcAssignPrim(): mkop("QAssignPrim");
				FcRefPrim(): mkop("QRefPrim");
				FcStructPrim(struct_name): mkop("QStructPrim");
				FcFieldPrim(name): mkop("QFieldPrim");
				FcSetMutablePrim(name): mkop("QSetMutablePrim");
				FcCreateClosurePrim(structName, functionName): todo();
				FcQuote(): todo();
			}
		}
		FiLambda(args, body, type, start): todo();
		FiCall(fn, args, type, start): todo();
		FiVar(name, type, start): todo();
		FiLet(name, type, e1, e2, type2, start): todo();
		FiIf(e1, e2, e3, type, start): todo();
		FiSwitch(x, switchType, cases, type, start): todo();
		FiCast(e, tFrom, tTo, type, start): todo();
		FiSeq(es, type, start): todo();
		FiRequire(flowfile, e, type, start): todo();
		FiUnsafe(name, fallback, type, start): todo();
	}
}


expandFiQuotes(f : [FiExp], start : int) -> [FiExp] {
	map(f, \a -> expandFiQuote(a, start))
}

unquote(f : FiExp) -> FiExp {
	mkstruct = \name : string, args : [FiExp] -> {
		FiCallPrim(FcStructPrim(name), args, FiTypeName(name, []), f.start);
	}

	type = fiExpType(f);
	todo = \ -> {
		println("TODO: Unquote");
		println(f);
		println(type);
		f;
	}
	switch (type) {
		FiTypeArray(t): todo();
		FiTypeFunction(args, returnType): todo();
		FiTypeRef(t): todo();
		FiTypeParameter(n): todo();
		FiTypeBool(): todo();
		FiTypeInt(): mkstruct("QInt", [f]);
		FiTypeDouble(): todo();
		FiTypeString(): todo();
		FiTypeFlow(): todo();
		FiTypeVoid(): todo();
		FiTypeNative(): todo();
		FiTypeName(name, typeparameters): todo();
	}
}