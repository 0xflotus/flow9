import tools/flowc/typechecker2/gtype;
import tools/flowc/prettyprint;

export {
	gtype2string(env : GEnv, type : GType) -> string;

	instantiateGTypePars(env : GEnv, typars : Tree<string, GType>, type : GType, onError : (string) -> void) -> GType;
}

gtype2string(env : GEnv, type : GType) -> string {
	doGtype2string(env, type, makeSet());
}

doGtype2string(env : GEnv, type : GType, seen : Set<int>) -> string {
	pt = \t -> prettyFcType(FcPretty(false, false, ^(env.env.local.tyvars), ^(env.env.local.typars)), t, makeSet());
	switch (type) {
		GFlow(): "flow";
		GTypeVar(id): {
			alpha = "Î±" + i2s(id);
			if (containsSet(seen, id)) alpha
			else {
				switch (lookupTree(env.tyvars, id)) {
					None(): alpha;
					Some(rt): if (env.verbose > 1) alpha + " (=" + doGtype2string(env, rt, insertSet(seen, id)) + ")" else doGtype2string(env, rt, insertSet(seen, id));
				}
			};
		}
		GTypePar(id): id;
		GFunction(args, rt): {
			"(" + superglue(args, \a -> doGtype2string(env, a, seen), ", ") + ") -> " + doGtype2string(env, rt, seen);
		}
		GArray(at): {
			 "[" + doGtype2string(env, at, seen) + "]";
		}
		GRef(read): {
			 "ref " + doGtype2string(env, read, seen);
		}
		GBasicType(tt): pt(tt);
		GSubType(e): gsubtypeexpr2string(env, e, seen);
	}
}

gsubtypeexpr2string(env : GEnv, expr : GSubTypeExpr, seen : Set<int>) -> string {
	switch (expr) {
		GBounded(lower, upper): {
			// [l..y]
			"{" 
			+ gsubtypeexpr2string(env, lower, seen)
			+ " .. " 
			+ gsubtypeexpr2string(env, upper, seen)
			+ "}"
		}
		GNamed(name, tps): {
			name + "<" + superglue(tps, \a -> doGtype2string(env, a, seen), ", ") + ">";
		}
		GTypeVar(id): doGtype2string(env, expr, seen);
		GField(name, type): "(." + name + ":" + doGtype2string(env, type, seen) + ")";
		GAnd(exprs): "(" + superglue(exprs, \a -> gsubtypeexpr2string(env, a, seen), " & ") + ")";
		GOr(exprs): "(" + superglue(exprs, \a -> gsubtypeexpr2string(env, a, seen), " | ") + ")";
		GTopBottom(): "*";
	}
}

instantiateGTypePars(env : GEnv, typars : Tree<string, GType>, type : GType, onError : (string) -> void) -> GType {
	switch (type) {
		GBasicType(t): type;
		GFlow(): type;
		GTypePar(id): lookupTreeDef(typars, id, type);
		GFunction(args, rt): {
			GFunction(instantiateGTypesPars(env, typars, args, onError), instantiateGTypePars(env, typars, rt, onError))
		}
		GArray(atype): GArray(instantiateGTypePars(env, typars, atype, onError));
		GRef(rtype): GArray(instantiateGTypePars(env, typars, rtype, onError));
		GTypeVar(id): type;
		GSubType(expr): GSubType(instantiateGSubTypePars(env, typars, expr, onError));
	}
}

instantiateGTypesPars(env : GEnv, typars : Tree<string, GType>, types : [GType], onError : (string) -> void) -> [GType] {
	map(types, \t -> {
		instantiateGTypePars(env, typars, t, onError)
	})
}

instantiateGSubTypePars(env : GEnv, typars : Tree<string, GType>, expr : GSubTypeExpr, onError : (string) -> void) -> GSubTypeExpr {
	todo = \ -> {
		println("TODO: Instantiate");
		expr;
	}
	switch (expr) {
		GTypeVar(id): expr;
		GNamed(name, ntypars): GNamed(name, instantiateGTypesPars(env, typars, ntypars, onError));
		GField(name, type): GField(name, instantiateGTypePars(env, typars, type, onError));
		GAnd(exprs): todo();
		GOr(exprs):  todo();
		GBounded(lower, upper):  todo();
		GTopBottom():  todo();
	}
}
