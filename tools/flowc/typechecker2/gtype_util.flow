import tools/flowc/typechecker2/gtype;
import tools/flowc/prettyprint;

export {
	gtype2string(env : GEnv, type : GType) -> string;

	instantiateGTypePars(env : GEnv, typars : Tree<string, GType>, type : GType, onError : (string) -> void) -> GType;

	extractGTypePars(env : GEnv, type : GType, acc : Set<string>) -> Set<string>;

	// Extract unbound typevars
	extractGTypeVars(env : GEnv, type : GType, acc : Set<int>) -> Set<int>;
}

gtype2string(env : GEnv, type : GType) -> string {
	doGtype2string(env, type, makeSet());
}

doGtype2string(env : GEnv, type : GType, seen : Set<int>) -> string {
	pt = \t -> prettyFcType(FcPretty(false, false, ^(env.env.local.tyvars), ^(env.env.local.typars)), t, makeSet());
	switch (type) {
		GFlow(): "flow";
		GTypeVar(id): {
			alpha = "Î±" + i2s(id);
			if (containsSet(seen, id)) alpha
			else {
				switch (lookupTree(env.tyvars, id)) {
					None(): alpha;
					Some(rt): if (env.verbose > 1) alpha + " (=" + doGtype2string(env, rt, insertSet(seen, id)) + ")" else doGtype2string(env, rt, insertSet(seen, id));
				}
			};
		}
		GTypePar(id): id;
		GFunction(args, rt): {
			"(" + superglue(args, \a -> doGtype2string(env, a, seen), ", ") + ") -> " + doGtype2string(env, rt, seen);
		}
		GArray(at): {
			 "[" + doGtype2string(env, at, seen) + "]";
		}
		GRef(read): {
			 "ref " + doGtype2string(env, read, seen);
		}
		GBasicType(tt): pt(tt);
		GSubType(e): gsubtypeexpr2string(env, e, seen);
	}
}

gsubtypeexpr2string(env : GEnv, expr : GSubTypeExpr, seen : Set<int>) -> string {
	switch (expr) {
		GNamed(name, tps): {
			name + "<" + superglue(tps, \a -> doGtype2string(env, a, seen), ", ") + ">";
		}
		GField(name, type): "(." + name + ":" + doGtype2string(env, type, seen) + ")";
		GAnd(exprs): "(" + superglue(exprs, \a -> gsubtypeexpr2string(env, a, seen), " & ") + ")";
		GOr(exprs): "(" + superglue(exprs, \a -> gsubtypeexpr2string(env, a, seen), " | ") + ")";
	}
}

instantiateGTypePars(env : GEnv, typars : Tree<string, GType>, type : GType, onError : (string) -> void) -> GType {
	switch (type) {
		GBasicType(t): type;
		GFlow(): type;
		GTypePar(id): lookupTreeDef(typars, id, type);
		GFunction(args, rt): {
			GFunction(instantiateGTypesPars(env, typars, args, onError), instantiateGTypePars(env, typars, rt, onError))
		}
		GArray(atype): GArray(instantiateGTypePars(env, typars, atype, onError));
		GRef(rtype): GRef(instantiateGTypePars(env, typars, rtype, onError));
		GTypeVar(id): type;
		GSubType(expr): GSubType(instantiateGSubTypePars(env, typars, expr, onError));
	}
}

instantiateGTypesPars(env : GEnv, typars : Tree<string, GType>, types : [GType], onError : (string) -> void) -> [GType] {
	map(types, \t -> {
		instantiateGTypePars(env, typars, t, onError)
	})
}

instantiateGSubTypePars(env : GEnv, typars : Tree<string, GType>, expr : GSubTypeExpr, onError : (string) -> void) -> GSubTypeExpr {
	todo = \ -> {
		println("TODO: Instantiate");
		expr;
	}
	switch (expr) {
		GNamed(name, ntypars): GNamed(name, instantiateGTypesPars(env, typars, ntypars, onError));
		GField(name, type): GField(name, instantiateGTypePars(env, typars, type, onError));
		GAnd(exprs): todo();
		GOr(exprs):  todo();
	}
}

extractGTypePars(env : GEnv, type : GType, acc : Set<string>) -> Set<string> {
	switch (type) {
		GBasicType(t): acc;
		GFlow(): acc;
		GTypePar(id): insertSet(acc, id);
		GFunction(args, rt): extractGTypePars2(env, args, extractGTypePars(env, rt, acc));
		GArray(atype): extractGTypePars(env, atype, acc);
		GRef(atype): extractGTypePars(env, atype, acc);
		GTypeVar(id): acc;
		GSubType(expr): {
			extractGSubTypePars(env, expr, acc);
		}
	}
}

extractGTypePars2(env : GEnv, types : [GType], acc : Set<string>) -> Set<string> {
	fold(types, acc, \acc2, t -> extractGTypePars(env, t, acc2))
}

extractGSubTypePars(env : GEnv, expr : GSubTypeExpr, acc : Set<string>) -> Set<string> {
	todo = \ -> {
		println("TODO: Extract typar");
		acc;
	}
	switch (expr) {
		GNamed(name, typars): extractGTypePars2(env, typars, acc);
		GField(name, type): extractGTypePars(env, type, acc);
		GAnd(exprs): todo();
		GOr(exprs): todo();
	}
}

extractGTypeVars(env : GEnv, type : GType, acc : Set<int>) -> Set<int> {
	switch (type) {
		GBasicType(t): acc;
		GFlow(): acc;
		GTypePar(id): acc;
		GFunction(args, rt): extractGTypeVars2(env, args, extractGTypeVars(env, rt, acc));
		GArray(atype): extractGTypeVars(env, atype, acc);
		GRef(atype): extractGTypeVars(env, atype, acc);
		GTypeVar(id): {
			if (!containsKeyTree(env.tyvars, id)) {
				insertSet(acc, id);
			} else acc;
		}
		GSubType(expr): {
			extractGSubTypeVars(env, expr, acc);
		}
	}
}

extractGTypeVars2(env : GEnv, types : [GType], acc : Set<int>) -> Set<int> {
	fold(types, acc, \acc2, t -> extractGTypeVars(env, t, acc2))
}

extractGSubTypeVars(env : GEnv, expr : GSubTypeExpr, acc : Set<int>) -> Set<int> {
	todo = \ -> {
		println("TODO: Extract tyvar");
		acc;
	}
	switch (expr) {
		GNamed(name, typars): extractGTypeVars2(env, typars, acc);
		GField(name, type): extractGTypeVars(env, type, acc);
		GAnd(exprs): todo();
		GOr(exprs): todo();
	}
}
