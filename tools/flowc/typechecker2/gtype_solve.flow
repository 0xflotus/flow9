import tools/flowc/typechecker2/gtype_util;
import tools/flowc/typechecker2/fctype2gtype;
import tools/flowc/fcexp_description;
import tools/flowc/debug;
import tools/flowc/type_helpers;
import tools/flowc/typechecker/type_expect_helpers;

export {
	// This resolves the constraints
	gtypeSolve(name : string, tyvarIdGroup : IdGroup, pos : FcPosition, env : FcTypeEnv) -> GEnv;
}

/*
This works using a few passes algorithm:
First, recursively deconstruct all relations based on the expectations and build a graph
of requirements for each tyvar.
Then, for each tyvar, figure out how to resolve it.


Run with something like

	flowcpp tools/flowc/flowc.flow -- test=1 incremental=0 gtype=1 >out.flow

and then

	mkdot

to produce the graphviz relations
*/

gtypeSolve(name : string, tyvarIdGroup : IdGroup, pos : FcPosition, env : FcTypeEnv) -> GEnv {
	expects = reverseList(^(env.local.expects));

	// Build a map from tyvar to typar
	typars : Tree<int, GType> = foldTree(^(env.local.typars), makeTree(), \typar, tyvar, acc : Tree<int, GType> -> {
		setTree(acc, tyvar.id, GTypePar(typar));
	});

	ge = GEnv(
		env, 
		tyvarIdGroup, 
		// While debugging, let us do this
		if (true) 3 else if (^(env.local.debugTyping) > 0 || getConfigParameter(env.program.acc.config.config, "verbose") == name) 3 else env.program.acc.config.verbose, 
		typars, 
		makeSet(), 
		makeSet(),
		makeSimpleGraph(),
		makeSimpleGraph(),
	);

	if (ge.verbose >= 2)  {
		fcPrintln("\nType " + name);
	}

	onError = \m, info, description -> {
		poss = FcPosition(pos.file, info.start, info.end);
		addFcTypeError(env.program, FcError(name + ": " + (if (description != "") description + ": " else "") + m, [poss]));
	};

	gunify = \genv : GEnv, output : FcType, input : FcType, info : FcInfo2, description : () -> string -> {
		ot = fctype2gtype(genv.env, tyvarIdGroup, output);
		it = fctype2gtype(genv.env, tyvarIdGroup, input);
		unifyGType(genv, ot, it, \m -> onError(m, info, description()));
	}

	ge2 = foldList(expects, ge, \acc, e -> {
		// If verbose is on, we keep track of what expects to debug
		solveDebug = (ge.verbose >= 1 && containsSet(^(env.local.debugExpects), e)) || ge.verbose >= 3;
		if (solveDebug) {
			env.local.debugTyping := 1;
		};
		if (solveDebug || ge.verbose >= 2) {
			fcPrintln("\n// " + strReplace(fcExpect2string(acc.env, e), "\n", " "));
		}

		re = switch (e : FcTypeExpect) {
			FcLessOrEqual(e1, e2, d, info, ex): {
				re1 = getResolvedFcType(env, e1);
				re2 = getResolvedFcType(env, e2);
				gunify(acc, re1, re2, info, \ -> d + ": " + fcexpDescription(ex));
			}
			FcVerifyType(e1, e2, info): {
				re1 = getResolvedFcType(env, e1);
				re2 = getResolvedFcType(env, e2);
				et1 = gunify(acc, re1, re2, info, \ -> "");
				gunify(et1, re2, re1, info, \ -> "");
			}
			FcExpectField(field, ftype, t, info, ex): {
				struct = getResolvedFcType(env, t);
				st = fctype2gtype(env, tyvarIdGroup, struct);
				gfield = GSubType(GField(field, fctype2gtype(env, tyvarIdGroup, ftype)));
				unifyGType(acc, gfield, st, \m -> onError(m, info, ""));
			}
			FcSetMutableField(stype, field, ftype, info): {
				st = fctype2gtype(acc.env, tyvarIdGroup, stype);
				ft = fctype2gtype(acc.env, tyvarIdGroup, ftype);
				gfield = GSubType(GField(field, ft));
				unifyGType(acc, st, gfield, \m -> onError(m, info, "set mutable"));
			}
		}
		if (solveDebug) {
			env.local.debugTyping := 0;
		}
		re;
	});

	if (ge2.verbose >= 2) {
/*		println("Result:");
		traverseInOrder(be2.tyvars, \tv, type -> {
			 println("Î±" + i2s(tv) + " = " + gtype2string(be2, type));
			 {}
		});
*/
		println("Tyvars: " + toString(set2array(ge2.unresolvedTyvars)));

		// Build the relation graph
		mroot = popMinSet(ge2.unresolvedTyvars);
		switch (mroot) {
			None(): {}
			Some(root): {
				dot = simpleGraph2dot(ge2.relations, GTypeVar(root.value), [], 
					\n -> [DotLabel(gtype2string(ge2, n))], 
					\e -> []
				);
				setFileContent(name + ".dot", dot);

				batch = getFileContent("mkdot.bat");
				batch0 = batch + "dot "+ name + ".dot -Tsvg -o" + name + ".svg\n";
				setFileContent("mkdot.bat", batch0);
				{}
			}
		}
	}

	ge2;
}

unifyGType(env : GEnv, output : GType, input : GType, onError : (string) -> void) -> GEnv {
	if (output == input) {
		env;
	} else {
		tr = Pair(output, input);
		if (containsSet(env.seen, tr)) {
			env;
		} else {
			// We set an entry in the cache to avoid infinite recursion
			seen = insertSet(env.seen, tr);
			if (env.verbose >= 3)  {
				pt = \t -> gtype2string(env, t);
				printIndent(env.env, "Unify " + gtype2string(env, output) + " c= " + gtype2string(env, input));
			}
			env2 = GEnv(env with seen = seen);
			env3 = unifyAndRecurseGType(env2, output, input, onError);

			if (env.verbose >= 3)  {
				printDedent(env.env, "Done " + gtype2string(env3, output) + " c= " + gtype2string(env3, input));
			}
			env3;
		}
	}
}

// Alright, these GTypes meet. We have to recursively spiral down on these guys
unifyAndRecurseGType(env : GEnv, left : GType, right : GType, onError : (string) -> void) -> GEnv {
	if (env.verbose >= 4)  {
		printIndent(env.env, "Unify  " + gtype2string(env, left) + " c= " + gtype2string(env, right));
	}

	todo = \ -> {
		printStay(env.env, "TODO: " + gtype2string(env, left) + " c= " + gtype2string(env, right));
		env;
	}

	error = \ -> {
		onError(gtype2string(env, left) + " != " + gtype2string(env, right));
		env;
	}

	rest = \ -> {
		switch (right) {
			GTypeVar(rid): gunifyTyvar(env, left, right, onError);
			GFlow(): {
				explicit_flow = isConfigParameterTrue(env.env.program.acc.config.config, "explicit-flow");
				switch (left) {
					GFlow(): env;
					GBasicType(bt): {
						if (explicit_flow) {
							switch (bt) {
								FcTypeNative(__): env;
								default: {
									// We require explicit casts to/from flow
									error();
								}
							}
						} else env;
					}
					default: {
						todo();
					}
				}
			}
			default: {
/*
				if (left == GFlow()) {
					// OK, we find all unbound tyvars and bind them to flow!
					tyvars = extractFTypeVars(env, right, makeSet());
					acc2 = foldSet(tyvars, env, \acc, tv -> {
						if (containsKeyTree(acc.tyvars, tv)) acc
						else setFTypeVar(acc, tv, left);
					});
					FEnvType(acc2, 
						if (kind == FUnifyLeft() || kind == FReduceLeft()) left else right
					);
				} else {
					onError(ftype2string(env, left) + "   and   " + ftype2string(env, right) + " are incompatible");
						// we do not support toString(FType) at the moment
						// + (if (env.verbose > 1) "\n   " + toString(left) + "\nvs " + toString(right) else ""));
					simplest = switch (left) {
						FBasicType(__): left;
						default: right;
					}
					FEnvType(env, simplest);
				}*/
				todo();
			}
		}
	}

	nenv = switch (left) {
		GBasicType(ltype): {
			switch (right) {
				GBasicType(rtype): {
					if (isSameFcType(env.env, ltype, rtype, false)) {
						env;
					} else {
						error();
					}
				}
				default: rest();
			}
		}
		GFlow(): rest();
		GTypePar(lid): {
			switch (right) {
				GTypePar(rid): {
					if (lid == rid) {
						env;
					} else {
						strict = getConfigParameter(env.env.program.acc.config.config, "strict");
						if (strict == "1") {
							onError(lid + " and " + rid + " are distinct");
						}
						env;
					}
				}
				default: {
					rest();
				}
			}
		}
		GFunction(largs, lrt): {
			switch (right) {
				GFunction(rargs, rrt): {
					nenv = unifyGTypes(env, rargs, largs, onError);
					unifyGType(nenv, lrt, rrt, onError);
				}
				default: rest();
			}
		}
		GArray(ltype): {
			switch (right) {
				GArray(rtype): {
					unifyGType(env, ltype, rtype, onError);
				}
				default: rest();
			}
		}
		GRef(ltype): {
			switch (right) {
				GRef(rtype): {
					unifyGType(env, ltype, rtype, onError);
				}
				default: rest();
			}
		}
		GTypeVar(lid): {
			gunifyTyvar(env, left, right, onError);
		}
		GSubType(lexp): {
			switch (right) {
				GBasicType(t): error();
				GFlow(): rest();
				GTypePar(id): rest();
				GFunction(args, rt): error();
				GArray(type): error();
				GRef(type): error();
				GTypeVar(rid): {
					gunifyTyvar(env, left, right, onError);
				}
				GSubType(rexp): {
					gunifySubType(env, lexp, rexp, onError);
				}
			}
		}
	}

	if (env.verbose >= 4)  {
		printDedent(env.env, "Unify  " + gtype2string(env, left) + " c= " + gtype2string(env, right));
	}

	nenv;
}

unifyGTypes(env : GEnv, lefts : [GType], rights : [GType], onError : (string) -> void) -> GEnv {
	if (length(lefts) != length(rights)) {
		onError("Got " + i2s(length(lefts) + 1) + ", but expected " + i2s(length(rights) + 1));
		env;
	} else {
		foldi(lefts, env, \i, acc, l -> {
			unifyGType(acc, l, rights[i], onError)
		})
	}
}

gunifyTyvar(env : GEnv, left : GType, right : GType, onError : (string) -> void) -> GEnv {
	addTyvar = \ut, t -> switch (t) {
		GTypeVar(id): insertSet(ut, id);
		default: ut;
	}
	GEnv(
		env with 
		unresolvedTyvars = addTyvar(addTyvar(env.unresolvedTyvars, left), right),
		relations = addSimpleEdge(env.relations, left, right, true, 0);
	)
}

gunifySubType(env : GEnv, left : GSubTypeExpr, right : GSubTypeExpr, onError : (string) -> void) -> GEnv {
	todo = \ -> {
		printStay(env.env, "TODO: Subtype " + gtype2string(env, GSubType(left)) + " c= " + gtype2string(env, GSubType(right)));
		env;
	}
	switch (left) {
		GTypeVar(lid): unifyGType(env, left, GSubType(right), onError);
		GNamed(lname, ltypars): {
			switch (right) {
				GNamed(rname, rtypars): {
					if (lname == rname) {
						// Do the typars
						unifyGTypes(env, ltypars, rtypars, onError);
					} else {
						gunifyNamedTypes(env, left, right, onError);
					}
				}
				default: todo();
			}
		}
		GField(lname, ltype): {
			switch (right) {
				GNamed(rname, rtypars): {
					unifyGFieldAgainstName(env, left, right, onError);
				}
				default: {
					todo();
				}
			}
		}
		GAnd(lexprs): todo();
		GOr(lexprs): todo();
		GBounded(lower, upper): todo();
		GTopBottom(): todo();
	}
}

// We know the names are different, and that the right name is supposed to be a union.
gunifyNamedTypes(env : GEnv, left : GNamed, right : GNamed, onError : (string) -> void) -> GEnv {
	// From the name of a union to the structs, uninstantiated
	typenames : [FcTypeName] = union2typenames(env.env, right.name);

	mstruct = find(typenames, \tn -> tn.name == left.name);
	switch (mstruct) {
		None(): {
			// TODO: It could be that the left is a union.
			onError("Expected " + gtype2string(env, GSubType(left)) + " to be part of " + gtype2string(env, GSubType(right)));			
			env;
		}
		Some(ustruct): {
			// The struct as it appears in the union. Let us remap typars from the union to the struct
			istruct = ginstantiateStructFromUnion(env, right, ustruct, onError);
			// And then subtype with our struct
			unifyAndRecurseGType(env, GSubType(left), istruct, onError);
		}
	}
}

// We known that master is a union, and we want the instantiated struct which we know is part of it
ginstantiateStructFromUnion(env : GEnv, master : GNamed, ustruct : FcTypeName, onError : (string) -> void) -> GType {
	munion = lookupTree(env.env.program.acc.names.unions, master.name);
	switch (munion) {
		None(): {
			onError("Expected " + master.name + " to be a union");
			GSubType(GNamed(ustruct.name, []));
		}
		Some(union): {
			// Take the union def and map the typars
			typars = foldi(union.typeparameters, makeTree(), \i, acc, tp -> {
				setTree(acc, strLeft("????????????", i + 1), tp)
			});
			// Now we make a struct with typar names that correspond to the unions
			instantiated = instantiateTyParsToTypes(env.env, typars, ustruct, onError);
			gtype = fctype2gtype(env.env, env.tyvarIdGroup, instantiated);

			// Now, instantiate the typars in this gtype
			gtypars = foldi(master.typars, makeTree(), \i, acc, tp -> {
				setTree(acc, strLeft("????????????", i + 1), tp)
			});
			instantiateGTypePars(env, gtypars, gtype, onError);
		}
	}
}

unifyGFieldAgainstName(env : GEnv, left : GField, right : GNamed, onError : (string) -> void) -> GEnv {
	todo = \ -> {
		printStay(env.env, "TODO: Subtype " + gtype2string(env, GSubType(left)) + " c= union? " + gtype2string(env, GSubType(right)));
		env;
	}
	mstruct = lookupTree(env.env.program.acc.names.structs, right.name);
	switch (mstruct) {
		None(): {
			todo();
		}
		Some(struct): {
			sfield = find(struct.args, \a : FcStructArg -> {
				a.name == left.name;
			});
			switch (sfield) {
				None(): todo();
				Some(field): {
					// OK, instantiate the struct typars from our right hand side
					gtypars = foldi(right.typars, makeTree(), \i, acc, tp -> {
						setTree(acc, strLeft("????????????", i + 1), tp)
					});
					gfield = fctype2gtype(env.env, env.tyvarIdGroup, field.type);
					fieldType = instantiateGTypePars(env, gtypars, gfield, onError);
					unifyAndRecurseGType(env, left.type, fieldType, onError);
				}
			}
		}
	}
}
