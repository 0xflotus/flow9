import tools/flowc/fctypeenv;
import tools/flowc/manipulation/simplegraph;

export {
	GType ::=
		GBasicType, GFlow, GTypePar, GFunction, GArray, GRef,
		GTypeVar, GSubType;

		GBasicType(t : FcBaseType);
		GFlow();
		GTypePar(id : string);
		GFunction(args : [GType], rt : GType);
		GArray(type : GType);
		GRef(type : GType);
		GTypeVar(id : int);

		// Some named type, which we might know or might not know, but we
		// have a type expression that captures the requirements
		GSubType(exp : GSubTypeExpr);

	GSubTypeExpr ::= GTypeVar, GNamed, GField, GAnd, GOr, GBounded, GTopBottom;

		// A struct type S<T> is represented as "S" with T
		// A union type U<T> is represented as "U" with T
		GNamed(name : string, typars : [GType]);

		// We know there is a field with a given type
		GField(name : string, type : GType);

		// A type that has to satisfy all these subtypes (aka fields in a struct)
		GAnd(exprs : [GSubTypeExpr]);

		// A type which can be either of these subtypes (aka union)
		GOr(exprs : [GSubTypeExpr]);

		// An unnamed union is a set of lower named bounds. 
		// An unknown named value is GBounded with empty sets
		GBounded(lower : GSubTypeExpr, upper : GSubTypeExpr);

		GTopBottom();

	GEnv(
		// The normal environment
		env : FcTypeEnv,

		// The tyvar id group
		tyvarIdGroup : IdGroup,

		// The verbosity level for debugging
		verbose : int,

		// The binding of tyvars
		tyvars : Tree<int, GType>,

		seen : Set<Pair<GType, GType>>,

		// A "static" graph of named subtypes, disregarding polymorphism.
		// We have a node between subtype and supertypes. The edge is true
		// if it is equivalence, like in U ::= S;
		relations : SimpleGraph<GType, bool>
	);
}
