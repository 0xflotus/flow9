import tools/flowc/typechecker2/gtype;
import ds/easygraph_utils;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/debug;

export {
	// Resolve the graph
	resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv;
}

resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv {
	graph = env.relations.graph;

	println("Iterate graph");

	// TODO: We only have to do the reachableClosure on unbound tyvars in the graph 

	// What nodes define the upper bound for each node?
	upperBounds : Tree<int, Set<int>> = reachableClosure(graph);

	// What nodes define the lower bounds for each node?
	reverseGraph = reverseEasyGraph(graph);
	lowerBounds : Tree<int, Set<int>> = reachableClosure(reverseGraph);

	unresolved = sizeSet(env.unresolvedTyvars);

	nenv = foldTree(lowerBounds, env, \nodeid, lowerIds, acc -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): {
				println("Could not find node " + i2s(nodeid));
				acc;
			}
			Some(node): {
				type = node.data;
				switch (type) {
					GTypeVar(tyvarId): {
						if (!containsKeyTree(acc.tyvars, tyvarId)) {
							lower = buildGNodes(acc, graph, lowerIds);
							upperIds = lookupTreeDef(upperBounds, nodeid, makeSet());
							upper = buildGNodes(acc, graph, upperIds);
							clarifyGTyvar(acc, unify, tyvarId, lower, upper);
						} else {
							acc;
						}
					}
					default: {
						acc;
					}
				}
			}
		}
	});

	if (sizeSet(nenv.unresolvedTyvars) != unresolved) {
		resolveGGraph(nenv, name, unify)
	} else {
		nenv;
	}
}

// We know this tyvar is unbound
clarifyGTyvar(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvar : int, lower : GNodes, upper : GNodes) -> GEnv {
	lowerFree = isGNodesUnconstrained(env, lower);
	upperFree = isGNodesUnconstrained(env, upper);

	if (lowerFree && !upperFree) {
		setGTyvars(env, unify, tyvar, upper);
	} else if (!lowerFree && upperFree) {
		setGTyvars(env, \e, l, u -> unify(e, u, l), tyvar, lower);
	} else if (lowerFree && upperFree) {
		// OK, these tyvars are all identical and should be bound
		// to the next free typar
		tyvars = insertSet(mergeSets(lower.tyvars, upper.tyvars), tyvar);
		resolveGTypeVarToTyPar(env, tyvars);
	} else {
		// OK, check if it is fixed
		fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);
	
		// If the upper and lower types are fully contained in the fixed,
		// we are good.
		lowerMissing = differenceSets(mapSet(lower.subtypes, \s -> GSubType(s)), fixed);	
		upperMissing = differenceSets(mapSet(upper.subtypes, \s -> GSubType(s)), fixed);	

		if (isEmptySet(lowerMissing) 
			&& isEmptySet(upperMissing)
			&& !isEmptySet(fixed)) {

			// OK, if there are no outsanding subtype requirements in either end,
			// but we have a fixed type somewhere, we can set the entire thing
			setGTyvars(env, unify, tyvar, GNodes(
					mergeSets(lower.tyvars, upper.tyvars),
					fixed,
					makeSet()
				)
			);
		} else {
			println("TODO: Can we do something about " + gnodes2string(env, lower) + " c= α" + i2s(tyvar) + " c= " + gnodes2string(env, upper));
			env;
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 3) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
	});

}

isGNodesUnconstrained(env : GEnv, node : GNodes) -> bool {
	isEmptySet(node.fixedTypes) && isEmptySet(node.subtypes)
	&& foldSet(node.tyvars, true, \acc, tv -> {
		acc && !containsKeyTree(env.tyvars, tv)
	})
}

setGTyvars(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvar : int, node : GNodes) -> GEnv {
	mtype = resolveGNodes(env, node);
	switch (mtype) {
		None(): env;
		Some(type): {
			foldSet(insertSet(node.tyvars, tyvar), env, \acc, tv -> {
				if (env.verbose >= 3) {
					printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, type));
				}
				nacc = GEnv(
					acc with
					tyvars = setTree(acc.tyvars, tv, type),
					unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
				);
				unify(nacc, GTypeVar(tv), type)
			});
		}
	}
}

resolveGNodes(env : GEnv, nodes : GNodes) -> Maybe<GType> {
	fixed = set2array(nodes.fixedTypes);
	subtypes = set2array(nodes.subtypes);
	if (length(fixed) == 1 && subtypes == []) {
		Some(fixed[0]);
	} else if (length(subtypes) == 1 && fixed == []) {
		Some(GSubType(subtypes[0]));
	} else {
		println("TODO: Resolve " + gnodes2string(env, nodes));
		None();
	}
}

emptyGNodes() -> GNodes {
	GNodes(makeSet(), makeSet(), makeSet())
}

buildGNodes(env : GEnv, graph : EasyGraph<GType, bool>, nodes : Set<int>) -> GNodes {
	foldSet(nodes, emptyGNodes(), \acc : GNodes, nodeid : int -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc; // Not supposed to happen
			Some(node): addGTypeToGNodes(env, acc, node.data);
		}
	});
}

addGTypeToGNodes(env : GEnv, acc : GNodes, tt : GType) -> GNodes {
	fixed = \ -> GNodes(acc with fixedTypes = insertSet(acc.fixedTypes, tt));
	switch (tt) {
		GBasicType(t): fixed();
		GFlow(): fixed();
		GTypePar(id): fixed();
		GFunction(args, rt): fixed();
		GArray(type): fixed();
		GRef(type): fixed();
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): {
					GNodes(acc with tyvars = insertSet(acc.tyvars, id));
				}
				Some(type): {
					// If the tyvar is defined, we should put it to fixedTypes
					GNodes(acc with fixedTypes = insertSet(acc.fixedTypes, type));
				}
			}
		}
		GSubType(expr): GNodes(acc with subtypes = insertSet(acc.subtypes, expr));
	}
}

GNodes(tyvars : Set<int>, fixedTypes : Set<GType>, subtypes : Set<GSubTypeExpr>);

gnodes2string(env : GEnv, g : GNodes) -> string {
	"{"
	+ superglue(set2array(g.tyvars), \tv -> "α" + i2s(tv), ", ")
	+ " : " + superglue(set2array(g.fixedTypes), \t -> gtype2string(env, t), ", ")
	+ " : " + superglue(set2array(g.subtypes), \st -> gtype2string(env, GSubType(st)), ", ")
	+ "}"
}

isGTypeResolved(tt : GType) -> bool {
	switch (tt) {
		GBasicType(t): true;
		GFlow(): true;
		GTypePar(id): true;
		GFunction(args, rt): forall(args, isGTypeResolved) && isGTypeResolved(rt);
		GArray(type): isGTypeResolved(type);
		GRef(type): isGTypeResolved(type);
		GTypeVar(id): false;
		GSubType(expr): false;
	}
}

