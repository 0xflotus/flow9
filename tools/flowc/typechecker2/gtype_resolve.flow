import tools/flowc/typechecker2/gtype;
import ds/easygraph_utils;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/debug;
import tools/flowc/type_helpers;

export {
	// Resolve the graph
	resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv;
}


// TODO: Introduce a structure to keep lower and upper bounds for each tyvar
// along with a set of nodes we depend on, so we can more efficiently update
// and only recalc what is required

// TODO: findPotentialGSupertypes and findPotentialGSubtypes can be greatly optimized
// by having a subtype graph of structs and unions

resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv {
	doResolveGGraph(env, name, unify, false);
}

doResolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv, makeTypars : bool) -> GEnv {
	if (env.verbose >= 2) {
		if (makeTypars) {
			printIndent(env.env, "Make typars: " + toString(set2array(env.unresolvedTyvars)) + " {");
		} else {
			printIndent(env.env, "Resolve tyvars: " + toString(set2array(env.unresolvedTyvars)) + " {");
		}
	}

	reverseGraph = ref makeEasyGraph();
	nenv = foldSet(env.unresolvedTyvars, env, \acc, tv -> {
		// During the loop, we can resolve stuff, no need to redo that
		if (containsSet(acc.unresolvedTyvars, tv)) {
			if (acc.relations.graph.numberOfEdges != ^(reverseGraph).numberOfEdges) {
				// We got new edges in the graph. We have to redo the reverse graph
				reverseGraph := reverseEasyGraph(acc.relations.graph);
			}
			reqs = buildGTyvarRequirement(acc, ^reverseGraph, tv);
			if (env.verbose >= 2) {
				printIndent(env.env, "Clarify " + gtyvarReqs2string(acc, reqs) + " {");
			}
			res = clarifyGTyvar(acc, unify, reqs, makeTypars);
			if (env.verbose >= 2) {
				printDedent(env.env, "}");
			}
			res;
		} else acc;
	});
	
	if (env.verbose >= 2) {
		printDedent(env.env, "} Unresolved: " + toString(set2array(nenv.unresolvedTyvars)));
	}	

	if (sizeSet(nenv.unresolvedTyvars) != 0 && !equalSet(env.unresolvedTyvars, nenv.unresolvedTyvars)) {
		// There is more to do
		doResolveGGraph(nenv, name, unify, false)
	} else {
		if (makeTypars) {
			// OK, we are done
			nenv;
		} else {
			// Do a final round where we make typars
			doResolveGGraph(nenv, name, unify, true)
		}
	}
}


// The total set of requirements we know about for a given tyvar
GTyvarRequirements(
	tyvar : int, 
	lower : GBounds, 
	upper : GBounds, 
);

// The total (lower or upper) bounds of a given tyvar. We can depend on three different things
// The tyvars are all known to be unbound.
GBounds(tyvars : Set<int>, fixedTypes : Set<GType>, subtypes : Set<GSubTypeExpr>);

buildGTyvarRequirement(env : GEnv, reverseGraph : EasyGraph<GType, bool>, tyvarId : int) -> GTyvarRequirements {
	nodeid = getSimpleNodeId(env.relations, GTypeVar(tyvarId));
	if (nodeid == -1) {
		println("Could not find tyvar");
		GTyvarRequirements(tyvarId, emptyGBounds(), emptyGBounds())
	} else {
		lowerIds = reachableClosureFromNode(reverseGraph, nodeid);
		lower = buildGBounds(env, env.relations.graph, lowerIds);

		upperIds = reachableClosureFromNode(env.relations.graph, nodeid);
		upper = buildGBounds(env, env.relations.graph, upperIds);
		GTyvarRequirements(tyvarId, lower, upper);
	}
}

// We know this tyvar is unbound, and we know about all the bounds.
// See if we can solve it
clarifyGTyvar(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, req : GTyvarRequirements, makeTypars : bool) -> GEnv {
	tyvar = req.tyvar;
	lower = req.lower;
	upper = req.upper;

	// OK, check if it is fixed
	fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);

	if (!isEmptySet(fixed)) {
		// OK, we have something fixed. Let us go with that

		// If flow is there, we can ignore that
		sansFlow = removeSet(fixed, GFlow());
		nenv = if (sizeSet(sansFlow) == 1 || sizeSet(fixed) == 1) {
			fixedTypes = if (sizeSet(sansFlow) == 1) sansFlow else fixed;
			fixedType = set2array(fixedTypes)[0];

			// OK, we have a unique, fixed type for our guy
			setGTyvars(env, unify, makeSet1(tyvar), fixedType);
		} else env;

		// OK, unify the entire thing against everything to uncover what we can
		// TODO: This is a bit too much - we could only do half of these because of
		// symmetry
		foldSet(fixed, nenv, \acc, lt -> {
			foldSet(fixed, acc, \acc2, ut -> {
				unify(acc2, lt, ut)
			})
		});
	} else {
		// OK, no fixed
		lowerFree = isGBoundsUnconstrained(env, lower);
		upperFree = isGBoundsUnconstrained(env, upper);

		if (lowerFree && upperFree) {
			if (makeTypars) {
				// No constraints. All of these tyvars are all identical and should be bound
				// to the next free typar.
				tyvars = insertSet(mergeSets(lower.tyvars, upper.tyvars), tyvar);
				resolveGTypeVarToTyPar(env, tyvars);
			} else {
				// While we are working, do not pin these down since new contraints can appear
				// witch lift them away from type par land. test 1 is an example.
				env;
			}
		} else {
			// Subtypes only. Find any types that might be compatible
			ltypenames : [string] = findPotentialGSupertypes(env, lower.subtypes);
			ltypes = if (length(ltypenames) == 1) {
				// We know that there is only one type that will work. This is also true in the future, even if we
				// have lower tyvars that might be bound in the future, because if they conflict,
				// type verification will catch it and there would not be any solution
				solution = resolveGSubTypeToName(env, ltypenames[0], lower.subtypes);
				if (env.verbose >= 3) {
					printStay(env.env, "Made " + gtype2string(env, solution) + " to meet " + gbounds2string(env, lower));
				};
				[solution];
			} else [];

			utypenames = findPotentialGSubtypes(env, upper.subtypes);
			utypes = if (length(utypenames) == 1) {
				solution = resolveGSubTypeToName(env, utypenames[0], upper.subtypes) ;
				if (env.verbose >= 3) {
					printStay(env.env, "Made " + gtype2string(env, solution) + " to meet " + gbounds2string(env, upper));
				};
				[solution];
			} else [];

			if (lowerFree && !upperFree) {
				if (length(utypes) == 1) {
					// Upper decides and is unique, so set all lower to the result
					solution = utypes[0];
					nenv = setGTyvars(env, unify, makeSet1(tyvar), solution);
					// Also be sure to unify the result against all our top subtypes to extract gold
					foldSet(upper.subtypes, nenv, \acc, st -> {
						unify(acc, solution, GSubType(st))
					});
				} else {
					if (sizeSet(upper.subtypes) == 1) {
						// A single named struct/union as the bound - we just take it
						subtype = set2array(upper.subtypes)[0];
						switch (subtype) {
							GNamed(__, __): setGTyvars(env, \e, l, u -> unify(e, u, l), insertSet(lower.tyvars, tyvar), GSubType(subtype));
							default: {
								println("TODO: Upper should decide from " + gbounds2string(env, upper));
								println(utypes);
								env;
							}
						}
					} else {
						// test 103 has a case
						// { :  : Tree<string, FcGlobalVar<>>, Tree<string, α20003>}
						println("TODO: Upper should decide from " + gbounds2string(env, upper));
						println(utypes);
						env;
					}
				}
			} else if (!lowerFree && upperFree) {
				if (length(ltypes) == 1) {
					// Lower decides. We just have to make sure we unify the result backwards
					solution = ltypes[0];
					nenv = setGTyvars(env, \e, l, u -> unify(e, u, l), insertSet(upper.tyvars, tyvar), solution);
					// Also be sure to unify the result against all our lower subtypes to extract gold
					foldSet(lower.subtypes, nenv, \acc, st -> {
						unify(acc, GSubType(st), solution)
					});
				} else {
					if (sizeSet(lower.subtypes) == 1) {
						// A single named struct/union as the bound - we just take it
						subtype = set2array(lower.subtypes)[0];
						switch (subtype) {
							GNamed(__, __): setGTyvars(env, \e, l, u -> unify(e, u, l), insertSet(upper.tyvars, tyvar), GSubType(subtype));
							default: {
								println("TODO: Lower should decide from " + gbounds2string(env, lower));
								println(gtype2string(env, GSubType(subtype)));
								env;
							}
						}
					} else {
						println("TODO: Lower should decide from " + gbounds2string(env, lower));
						println(ltypenames);
						println(ltypes);
						env;
					}
				}
			} else {
				shared = intersection(ltypenames, utypenames);
				if (length(shared) >= 1) {
					// OK, pick the "smallest" type, prefering small structs to big unions
					scored = map(shared, \name -> Pair(getGNamedSize(env, name), name));
					cheapest = sort(scored);
					winner = cheapest[0].second;

					// OK, lower and upper can agree on at least one type. Construct it
					solution = resolveGSubTypeToName(env, winner, mergeSets(lower.subtypes, upper.subtypes));

					// And set ourselves to this
					nenv = setGTyvars(env, unify, makeSet1(tyvar), solution);

					// Also be sure to unify the result against all our top and lower subtypes to extract gold
					nenv1 = foldSet(upper.subtypes, nenv, \acc, st -> {
						unify(acc, solution, GSubType(st))
					});
					foldSet(lower.subtypes, nenv1, \acc, st -> {
						unify(acc, GSubType(st), solution)
					});
				} else {
					// TODO: If there are no tyvars in the lower one, then
					// pick the biggest that still fits upper
					// If there are no tyvars in the upper one, then pick the
					// smallest that still fits lower

					println("TODO: Caught betwen two rocks: "  + gbounds2string(env, lower) + " c= α" + i2s(tyvar) + " c= " + gbounds2string(env, upper));
					println(shared);

					// It is not clear yet. Let us unify the lowers with the upppers in an attempt to
					// uncover more constraints
					foldSet(lower.subtypes, env, \acc, lt -> {
						foldSet(upper.subtypes, acc, \acc2, ut -> {
							unify(acc2, GSubType(lt), GSubType(ut))
						})
					});
				}
			}
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 2) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
	});
}

// Does this only contain unresolved tyvars?
isGBoundsUnconstrained(env : GEnv, node : GBounds) -> bool {
	isEmptySet(node.fixedTypes) && isEmptySet(node.subtypes)
	&& foldSet(node.tyvars, true, \acc, tv -> {
		acc && !containsKeyTree(env.tyvars, tv)
	})
}

// Set all tyvars to this resolved type
setGTyvars(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvars : Set<int>, type : GType) -> GEnv {
	if (env.verbose >= 2) {
		printStay(env.env, superglue(set2array(tyvars), \tv -> "α" + i2s(tv), ", ") + " = " + gtype2string(env, type));
	}

	nenv = foldSet(tyvars, env, \acc, tv -> {
		nacc = GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, type),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
		unify(nacc, GTypeVar(tv), type)
	});

	// Extract any new, unbound tyvars in the type and add them to the pool that has to be resolved
	tyvarsInType = extractGTypeVars(nenv, type, makeSet());
	GEnv(
		nenv with
		unresolvedTyvars = mergeSets(nenv.unresolvedTyvars, tyvarsInType)
	);
}

// Given these constraints, what supertypes could meet all of these?
findPotentialGSupertypes(env : GEnv, exprs : Set<GSubTypeExpr>) -> [string] {
	foldi(set2array(exprs), [], \i, acc, expr -> {
		supers = findGSupertypes(env, expr);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}

// Find all types which type can be dominated by, including itself
findGSupertypes(env : GEnv, expr : GSubTypeExpr) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mst = lookupTree(env.env.program.acc.names.structs, name);
			switch (mst) {
				None(): {
					// A union: Expand to members
					typenames : [FcTypeName] = union2typenames(env.env, name);
					// And then do a recursive call on the members
					supers : Set<GSubTypeExpr> = buildSet(map(typenames, \tn -> GNamed(tn.name, [])));
					findPotentialGSupertypes(env, supers);
				}
				Some(st): {
					arrayPush(
						getTreeArrayValue(env.env.program.acc.names.struct2unions, name),
						name
					);
				}
			}
		}
		GField(field, __): {
			getTreeArrayValue(env.env.program.acc.names.field2structs, field);
		}
		GAnd(exprs): {
			findPotentialGSupertypes(env, buildSet(exprs));
		}
		GOr(exprs): {
			uniq(fold(exprs, [], \acc, sexpr -> {
				concat(acc, findGSupertypes(env, sexpr))
			}));
		}
	}
}

// Given these constraints, what subtypes could meet all of these?
findPotentialGSubtypes(env : GEnv, exprs : Set<GSubTypeExpr>) -> [string] {
	foldi(set2array(exprs), [], \i, acc, expr -> {
		supers = findGSubtypes(env, expr);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}


// Find all types which are subtypes of this constraint, including ourselves
findGSubtypes(env : GEnv, expr : GSubTypeExpr) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mun = lookupTree(env.env.program.acc.names.unions, name);
			switch (mun) {
				None(): {
					// A struct: It can only be ourselves
					[name];
				}
				Some(un): {
					// A union: It can be ourselves, any subunion or the structs
					uniq(fold(un.typenames, [name], \acc, tn -> {
						concat(acc, findGSubtypes(env, GNamed(tn.name, [])))
					}));
				}
			}
		}
		GField(field, __): {
			getTreeArrayValue(env.env.program.acc.names.field2structs, field);
		}
		GAnd(exprs): {
			println("TODO: Subtypes of this and");
			findPotentialGSupertypes(env, buildSet(exprs));
		}
		GOr(exprs): {
			println("TODO: Subtypes of this or");
			findPotentialGSupertypes(env, buildSet(exprs));
		}
	}
}

// Given these exprs, and a desired type name, extract it, if we directly have it.
// If we do not, then we should construct the type ourselves with type-pars.
resolveGSubTypeToName(env : GEnv, name : string, exprs : Set<GSubTypeExpr>) -> GType {
	result = foldSet(exprs, [], \acc, expr -> {
		switch (expr) {
			GNamed(gname, __): if (gname == name) arrayPush(acc, GSubType(expr)) else acc;
			default: acc;
		}
	});

	if (result == []) {
		// OK, we could not find it, so we have to construct it
		makeGNamedType(env, name)
	} else result[0];
}

// Build a type with this name, and empty typars
makeGNamedType(env : GEnv, name : string) -> GType {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	GSubType(switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): {
					// Not found.
					GNamed(name, []);
				}
				Some(union): {
					GNamed(name, map(union.typeparameters, \__ -> {
						mkGTypeVar(env)
					}))
				}
			}
		}
		Some(structdef): {
			GNamed(name, map(structdef.typars, \__ -> {
				mkGTypeVar(env)
			}))
		}
	})
}

// Get some kind of score for a name. Structs is the number of typars + fields. Unions is 10 * number of structs + number of fields in total
getGNamedSize(env : GEnv, name : string) -> int {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): intMax;
				Some(union): {
					fold(union.typenames, 1 + length(union.typeparameters), \acc, tn -> {
						acc + 10 * getGNamedSize(env, tn.name)
					});
				}
			}
		}
		Some(structdef): 1 + length(structdef.typars) + length(structdef.args);
	}
}

mkGTypeVar(env : GEnv) -> GTypeVar {
	GTypeVar(nextUniqueId(env.tyvarIdGroup));
}

emptyGBounds() -> GBounds {
	GBounds(makeSet(), makeSet(), makeSet())
}

buildGBounds(env : GEnv, graph : EasyGraph<GType, bool>, nodes : Set<int>) -> GBounds {
	foldSet(nodes, emptyGBounds(), \acc : GBounds, nodeid : int -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc; // Not supposed to happen
			Some(node): addGTypeToGBounds(env, acc, node.data);
		}
	});
}

addGTypeToGBounds(env : GEnv, acc : GBounds, tt : GType) -> GBounds {
	fixed = \ -> GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, resolveGType(env, tt)));
	switch (tt) {
		GBasicType(t): fixed();
		GFlow(): fixed();
		GTypePar(id): fixed();
		GFunction(args, rt): fixed();
		GArray(type): fixed();
		GRef(type): fixed();
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): {
					GBounds(acc with tyvars = insertSet(acc.tyvars, id));
				}
				Some(type): {
					// If the tyvar is defined, we should put it to fixedTypes
					GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, resolveGType(env, type)));
				}
			}
		}
		GSubType(expr): GBounds(acc with subtypes = insertSet(acc.subtypes, resolveGSubExpr(env, expr)));
	}
}

resolveGType(env : GEnv, tt : GType) -> GType {
	switch (tt) {
		GBasicType(t): tt;
		GFlow(): tt;
		GTypePar(id): tt;
		GFunction(args, rt): GFunction(resolveGTypes(env, args), resolveGType(env, rt));
		GArray(type): GArray(resolveGType(env, type));
		GRef(type): GRef(resolveGType(env, type));
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): tt;
				Some(type): resolveGType(env, type);
			}
		}
		GSubType(expr): GSubType(resolveGSubExpr(env, expr));
	}
}

resolveGTypes(env : GEnv, types : [GType]) -> [GType] {
	map(types, \t -> resolveGType(env, t));
}

resolveGSubExpr(env : GEnv, expr : GSubTypeExpr) -> GSubTypeExpr {
	switch (expr) {
		GNamed(name, typars): GNamed(name, resolveGTypes(env, typars));
		GField(name, type): GField(name, resolveGType(env, type));
		GAnd(exprs): GAnd(map(exprs, \e -> resolveGSubExpr(env, e)));
		GOr(exprs): GOr(map(exprs, \e -> resolveGSubExpr(env, e)));
	}
}

gtyvarReqs2string(env : GEnv, req : GTyvarRequirements) -> string {
	gbounds2string(env, req.lower) + " c= α" + i2s(req.tyvar) + " c= " + gbounds2string(env, req.upper);
}

gbounds2string(env : GEnv, g : GBounds) -> string {
	"{"
	+ superglue(set2array(g.tyvars), \tv -> "α" + i2s(tv), ", ")
	+ " : " + superglue(set2array(g.fixedTypes), \t -> gtype2string(env, t), ", ")
	+ " : " + superglue(set2array(g.subtypes), \st -> gtype2string(env, GSubType(st)), ", ")
	+ "}"
}

