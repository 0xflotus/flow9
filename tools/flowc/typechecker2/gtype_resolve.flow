import tools/flowc/typechecker2/gtype;
import ds/easygraph_utils;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/debug;
import tools/flowc/type_helpers;

export {
	// Resolve the graph
	resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv;
}

// TODO: findPotentialGSupertypes and findPotentialGSubtypes can be greatly optimized
// by having a subtype graph of structs and unions

// TODO: When we have loops in the deps, we have to unify the nodes. See test 59, where
// α40001, α40008, α40005 form a loop, and we can collapse to be a single node, which
// has inputs from TextSize and Selection.
// Also α40002 and α40006 are in a loop with Selection, and they can be joined together.

// TODO: Consider whether GBounds to have a bool for flow type, and GName separately 

resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv {
	doResolveGGraph(env, name, unify, GResolveSafeOnly());
}

doResolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv, stage : GResolutionStage) -> GEnv {
	if (env.verbose >= 2) {
		printIndent(env.env, "Resolve tyvars: " + toString(set2array(env.unresolvedTyvars)) + " " +  toString(stage) + " {");
	}

	reverseGraph = ref makeEasyGraph();
	nenv = foldSet(env.unresolvedTyvars, env, \acc, tv -> {
		// During the loop, we can resolve stuff, no need to redo that
		if (containsSet(acc.unresolvedTyvars, tv)) {
			if (acc.relations.graph.numberOfEdges != ^(reverseGraph).numberOfEdges) {
				// We got new edges in the graph. We have to redo the reverse graph
				reverseGraph := reverseEasyGraph(acc.relations.graph);
			}
			reqs = buildGTyvarRequirement(acc, ^reverseGraph, tv);
			if (env.verbose >= 2) {
				printIndent(env.env, "Clarify " + gtyvarReqs2string(acc, reqs) + " {");
			}
			res = clarifyGTyvar(acc, unify, reqs, stage);
			if (env.verbose >= 2) {
				printDedent(env.env, "}");
			}
			res;
		} else acc;
	});
	
	if (env.verbose >= 2) {
		printDedent(env.env, "} Unresolved: " + toString(set2array(nenv.unresolvedTyvars)));
	}	

	if (sizeSet(nenv.unresolvedTyvars) != 0 && !equalSet(env.unresolvedTyvars, nenv.unresolvedTyvars)) {
		// There were changes in some of the tyvars, so go again in a safe
		doResolveGGraph(nenv, name, unify, GResolveSafeOnly())
	} else {
		if (stage == GResolveTypars()) {
			// OK, we are done
			nenv;
		} else {
			nextStage = nextGResolutionStage(stage);
			// Do a final round where we make typars
			doResolveGGraph(nenv, name, unify, nextStage)
		}
	}
}

// We implement a staged heuristic for solving things.
GResolutionStage ::= GResolveSafeOnly, GResolveSafeButAmbiguous, GResolveSpeculative, GResolveTypars;
	// 1. Resolve all unambigious cases
	GResolveSafeOnly();

	// 2. If there is multiple solutions that might work, just pick one.
	GResolveSafeButAmbiguous();

	// 3. If we only have unbound tyvars remaining as stoppers for making progress, just
	//    ignore those, and assume they will be fine
	GResolveSpeculative();

	// 4. Convert connected, unbound tyvars to type pars
	GResolveTypars();

nextGResolutionStage(stage : GResolutionStage) -> GResolutionStage {
	switch (stage) {
		GResolveSafeOnly(): GResolveSafeButAmbiguous();
		GResolveSafeButAmbiguous(): GResolveSpeculative();
		GResolveSpeculative(): GResolveTypars();
		GResolveTypars(): GResolveTypars();
	}
}

// The total set of requirements we know about for a given tyvar
GTyvarRequirements(
	tyvars : Set<int>, 
	lower : GBounds, 
	upper : GBounds, 
);

// The total (lower or upper) bounds of a given tyvar. We can depend on three different things
// The tyvars are all known to be unbound.
GBounds(tyvars : Set<int>, fixedTypes : Set<GType>, subtypes : Set<GSubTypeExpr>);

buildGTyvarRequirement(env : GEnv, reverseGraph : EasyGraph<GType, bool>, tyvarId : int) -> GTyvarRequirements {
	reqs = buildGTyvarReqForOne(env, reverseGraph, tyvarId);

	loopingTyvars = intersectSets(reqs.lower.tyvars, reqs.upper.tyvars);
	res = if (!isEmptySet(loopingTyvars)) {
		// OK, we have a loop of tyvars. In that case, we can
		// collect the requirements for those tyvars as well, and join them up
		foldSet(loopingTyvars, reqs, \acc, tv -> {
			nreq = buildGTyvarReqForOne(env, reverseGraph, tv);
			joinGTyvarRequirements(acc, nreq)
		});
	} else {
		reqs
	}

	res;
}

buildGTyvarReqForOne(env : GEnv, reverseGraph : EasyGraph<GType, bool>, tyvarId : int) -> GTyvarRequirements {
	nodeid = getSimpleNodeId(env.relations, GTypeVar(tyvarId));
	if (nodeid == -1) {
		// This is because there are no requirements in the graph, and this is fine
		GTyvarRequirements(makeSet1(tyvarId), emptyGBounds(), emptyGBounds())
	} else {
		lowerIds = reachableClosureFromNode(reverseGraph, nodeid);
		lower = buildGBounds(env, env.relations.graph, lowerIds);

		upperIds = reachableClosureFromNode(env.relations.graph, nodeid);
		upper = buildGBounds(env, env.relations.graph, upperIds);

		GTyvarRequirements(makeSet1(tyvarId), lower, upper);
	}
}

joinGTyvarRequirements(left : GTyvarRequirements, right : GTyvarRequirements) -> GTyvarRequirements {

	tyvars = mergeSets(left.tyvars, right.tyvars);

	GTyvarRequirements(
		tyvars, 
		removeGBoundsTyvars(joinGBounds(left.lower, right.lower), tyvars),
		removeGBoundsTyvars(joinGBounds(left.upper, right.upper), tyvars)
	);
}


// We know this tyvar is unbound, and we know about all the bounds.
// See if we can solve it
clarifyGTyvar(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, req : GTyvarRequirements, stage : GResolutionStage) -> GEnv {
	lower = req.lower;
	upper = req.upper;

	// OK, check if it is fixed
	fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);

	if (!isEmptySet(fixed)) {
		// OK, we have something fixed. Let us go with that

		// If flow is there, we can ignore that
		sansFlow = removeSet(fixed, GFlow());
		if (sizeSet(sansFlow) == 1 || sizeSet(fixed) == 1) {
			fixedTypes = if (sizeSet(sansFlow) == 1) sansFlow else fixed;
			fixedType = set2array(fixedTypes)[0];

			// OK, we have a unique, fixed type for our guy
			setGTyvar(env, unify, req, fixedType);
		} else {
			// There are multiple solutions.
			pick = switch (stage) {
				GResolveSafeOnly(): false;
				GResolveSafeButAmbiguous(): true;
				GResolveSpeculative(): true;
				GResolveTypars(): true;
			}
			if (pick) {
				// There are multiple solutions. We just pick one
				fixedType = set2array(fixed)[0];
				setGTyvar(env, unify, req, fixedType);
			} else {
				// Nothing to do
				env;
			}
		}
	} else {
		// OK, no fixed. There can be tyvars and subtypes
		lowerOnlyTyvars = isGBoundsOnlyTyvars(env, lower);
		upperOnlyTyvars = isGBoundsOnlyTyvars(env, upper);

		if (lowerOnlyTyvars && upperOnlyTyvars) {
			switch (stage) {
				GResolveSafeOnly(): env;
				GResolveSafeButAmbiguous(): env;
				GResolveSpeculative(): env;
				GResolveTypars(): {
					// No constraints. All of these tyvars are all identical and should be bound
					// to the next free typar.
					tyvars = mergeSets(mergeSets(lower.tyvars, upper.tyvars), req.tyvars);
					resolveGTypeVarToTyPar(env, tyvars);
				}
			}
		} else {
			// We have subtypes
			ltypenames : [string] = findPotentialGSupertypes(env, lower.subtypes);
			utypenames : [string] = findPotentialGSubtypes(env, upper.subtypes);

			possible = if (isEmptySet(lower.subtypes)) utypenames
				else if (isEmptySet(upper.subtypes)) ltypenames
				else intersection(ltypenames, utypenames);

			// In case it is ambigious, should we pick the smallest?
			pickIfAmbiguos = switch (stage) {
				GResolveSafeOnly(): false;
				GResolveSafeButAmbiguous(): {
					// If there are no tyvars in either end, it is safe to go
					isGBoundsKnown(env, lower) && isGBoundsKnown(env, upper);
				}
				GResolveSpeculative(): {
					// OK, we have to make progress, so just take a chance
					true;
				}
				GResolveTypars(): true;
			}

			choice = if (pickIfAmbiguos) {
				// OK, pick the "smallest" type, prefering small structs to big unions
				scored = map(possible, \name -> Pair(getGNamedSize(env, name), name));
				cheapest = sort(scored);
				[cheapest[0].second];
			} else possible;

			if (length(choice) == 1) {
				// OK, lower and upper can agree on a type. Construct it
				winner = choice[0];
				solution = resolveGSubTypeToName(env, winner, mergeSets(lower.subtypes, upper.subtypes));

				// And set ourselves to this
				setGTyvar(env, unify, req, solution);
			} else {
				env;
			}
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 2) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
	});
}

// Does this only contain unresolved tyvars?
isGBoundsOnlyTyvars(env : GEnv, node : GBounds) -> bool {
	isEmptySet(node.fixedTypes) && isEmptySet(node.subtypes)
}

// Is this bound known, considering super and subtypes?
isGBoundsKnown(env : GEnv, bounds : GBounds) -> bool {
	!isEmptySet(bounds.fixedTypes)
	|| (isEmptySet(bounds.tyvars) && !isEmptySet(bounds.subtypes));
}

// Set this group of tyvars to this resolved type
setGTyvar(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, req : GTyvarRequirements, type : GType) -> GEnv {
	tyvars = req.tyvars;

	if (env.verbose >= 2) {
		printStay(env.env, superglue(set2array(tyvars), \tv -> "α" + i2s(tv), ", ") + " = " + gtype2string(env, type));
	}

	foldSet(tyvars, env, \env0, tyvar -> {
		nenv0 = GEnv(
			env0 with
			tyvars = setTree(env0.tyvars, tyvar, type),
			unresolvedTyvars = removeSet(env0.unresolvedTyvars, tyvar)
		);
		// Join with all lower fixed
		nenv1 = foldSet(req.lower.fixedTypes, nenv0, \acc, t -> unify(acc, t, type));
		// Join with all upper fixed
		nenv2 = foldSet(req.upper.fixedTypes, nenv1, \acc, t -> unify(acc, type, t));

		// Unify with subs
		nenv3 = foldSet(req.lower.subtypes, nenv2, \acc, st -> unify(acc, GSubType(st), type));

		// Unify with supers
		nenv4 = foldSet(req.upper.subtypes, nenv3, \acc, st -> unify(acc, type, GSubType(st)));

		// Extract any new, unbound tyvars in the type and add them to the pool that has to be resolved
		tyvarsInType = extractGTypeVars(nenv4, type, makeSet());
		GEnv(
			nenv4 with
			unresolvedTyvars = mergeSets(nenv4.unresolvedTyvars, tyvarsInType)
		);
	});
}

// Given these constraints, what supertypes could meet all of these?
findPotentialGSupertypes(env : GEnv, exprs : Set<GSubTypeExpr>) -> [string] {
	foldi(set2array(exprs), [], \i, acc, expr -> {
		supers = findGSupertypes(env, expr);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}

// Find all types which type can be dominated by, including itself
findGSupertypes(env : GEnv, expr : GSubTypeExpr) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mst = lookupTree(env.env.program.acc.names.structs, name);
			switch (mst) {
				None(): {
					// A union: Expand to members
					typenames : [FcTypeName] = union2typenames(env.env, name);
					// And then do a recursive call on the members
					supers : Set<GSubTypeExpr> = buildSet(map(typenames, \tn -> GNamed(tn.name, [])));
					findPotentialGSupertypes(env, supers);
				}
				Some(st): {
					arrayPush(
						getTreeArrayValue(env.env.program.acc.names.struct2unions, name),
						name
					);
				}
			}
		}
		GField(field, __): {
			getTreeArrayValue(env.env.program.acc.names.field2structs, field);
		}
		GAnd(exprs): {
			findPotentialGSupertypes(env, buildSet(exprs));
		}
		GOr(exprs): {
			uniq(fold(exprs, [], \acc, sexpr -> {
				concat(acc, findGSupertypes(env, sexpr))
			}));
		}
	}
}

// Given these constraints, what subtypes could meet all of these?
findPotentialGSubtypes(env : GEnv, exprs : Set<GSubTypeExpr>) -> [string] {
	foldi(set2array(exprs), [], \i, acc, expr -> {
		supers = findGSubtypes(env, expr);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}


// Find all types which are subtypes of this constraint, including ourselves
findGSubtypes(env : GEnv, expr : GSubTypeExpr) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mun = lookupTree(env.env.program.acc.names.unions, name);
			switch (mun) {
				None(): {
					// A struct: It can only be ourselves
					[name];
				}
				Some(un): {
					// A union: It can be ourselves, any subunion or the structs
					uniq(fold(un.typenames, [name], \acc, tn -> {
						concat(acc, findGSubtypes(env, GNamed(tn.name, [])))
					}));
				}
			}
		}
		GField(field, __): {
			getTreeArrayValue(env.env.program.acc.names.field2structs, field);
		}
		GAnd(exprs): {
			println("TODO: Subtypes of this and");
			findPotentialGSupertypes(env, buildSet(exprs));
		}
		GOr(exprs): {
			println("TODO: Subtypes of this or");
			findPotentialGSupertypes(env, buildSet(exprs));
		}
	}
}

// Given these exprs, and a desired type name, extract it, if we directly have it.
// If we do not, then we should construct the type ourselves with type-pars.
resolveGSubTypeToName(env : GEnv, name : string, exprs : Set<GSubTypeExpr>) -> GType {
	result = foldSet(exprs, [], \acc, expr -> {
		switch (expr) {
			GNamed(gname, __): if (gname == name) arrayPush(acc, GSubType(expr)) else acc;
			default: acc;
		}
	});

	if (result == []) {
		// OK, we could not find it, so we have to construct it
		makeGNamedType(env, name)
	} else result[0];
}

// Build a type with this name, and empty typars
makeGNamedType(env : GEnv, name : string) -> GType {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	GSubType(switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): {
					// Not found.
					GNamed(name, []);
				}
				Some(union): {
					GNamed(name, map(union.typeparameters, \__ -> {
						mkGTypeVar(env)
					}))
				}
			}
		}
		Some(structdef): {
			GNamed(name, map(structdef.typars, \__ -> {
				mkGTypeVar(env)
			}))
		}
	})
}

// Get some kind of score for a name. Structs is the number of typars + fields. Unions is 10 * number of structs + number of fields in total
getGNamedSize(env : GEnv, name : string) -> int {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): intMax;
				Some(union): {
					fold(union.typenames, 1 + length(union.typeparameters), \acc, tn -> {
						acc + 10 * getGNamedSize(env, tn.name)
					});
				}
			}
		}
		Some(structdef): 1 + length(structdef.typars) + length(structdef.args);
	}
}

mkGTypeVar(env : GEnv) -> GTypeVar {
	GTypeVar(nextUniqueId(env.tyvarIdGroup));
}

emptyGBounds() -> GBounds {
	GBounds(makeSet(), makeSet(), makeSet())
}

buildGBounds(env : GEnv, graph : EasyGraph<GType, bool>, nodes : Set<int>) -> GBounds {
	foldSet(nodes, emptyGBounds(), \acc : GBounds, nodeid : int -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc; // Not supposed to happen
			Some(node): addGTypeToGBounds(env, acc, node.data);
		}
	});
}

joinGBounds(left : GBounds, right : GBounds) -> GBounds {
	GBounds(mergeSets(left.tyvars, right.tyvars), mergeSets(left.fixedTypes, right.fixedTypes), mergeSets(left.subtypes, right.subtypes))
}

removeGBoundsTyvars(g : GBounds, tyvars : Set<int>) -> GBounds {
	GBounds(g with tyvars = differenceSets(g.tyvars, tyvars));
}


addGTypeToGBounds(env : GEnv, acc : GBounds, tt : GType) -> GBounds {
	fixed = \ -> GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, resolveGType(env, tt)));
	switch (tt) {
		GBasicType(t): fixed();
		GFlow(): fixed();
		GTypePar(id): fixed();
		GFunction(args, rt): fixed();
		GArray(type): fixed();
		GRef(type): fixed();
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): {
					GBounds(acc with tyvars = insertSet(acc.tyvars, id));
				}
				Some(type): {
					// If the tyvar is defined, resolve it, and place it where it needs to go
					addGTypeToGBounds(env, acc, type);
				}
			}
		}
		GSubType(expr): GBounds(acc with subtypes = insertSet(acc.subtypes, resolveGSubExpr(env, expr)));
	}
}

resolveGType(env : GEnv, tt : GType) -> GType {
	switch (tt) {
		GBasicType(t): tt;
		GFlow(): tt;
		GTypePar(id): tt;
		GFunction(args, rt): GFunction(resolveGTypes(env, args), resolveGType(env, rt));
		GArray(type): GArray(resolveGType(env, type));
		GRef(type): GRef(resolveGType(env, type));
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): tt;
				Some(type): resolveGType(env, type);
			}
		}
		GSubType(expr): GSubType(resolveGSubExpr(env, expr));
	}
}

resolveGTypes(env : GEnv, types : [GType]) -> [GType] {
	map(types, \t -> resolveGType(env, t));
}

resolveGSubExpr(env : GEnv, expr : GSubTypeExpr) -> GSubTypeExpr {
	switch (expr) {
		GNamed(name, typars): GNamed(name, resolveGTypes(env, typars));
		GField(name, type): GField(name, resolveGType(env, type));
		GAnd(exprs): GAnd(map(exprs, \e -> resolveGSubExpr(env, e)));
		GOr(exprs): GOr(map(exprs, \e -> resolveGSubExpr(env, e)));
	}
}

gtyvarReqs2string(env : GEnv, req : GTyvarRequirements) -> string {
	gbounds2string(env, req.lower) + " c= " + superglue(set2array(req.tyvars), \tyvar -> "α" + i2s(tyvar), ", ") + " c= " + gbounds2string(env, req.upper);
}

gbounds2string(env : GEnv, g : GBounds) -> string {
	"{"
	+ superglue(set2array(g.tyvars), \tv -> "α" + i2s(tv), ", ")
	+ " : " + superglue(set2array(g.fixedTypes), \t -> gtype2string(env, t), ", ")
	+ " : " + superglue(set2array(g.subtypes), \st -> gtype2string(env, GSubType(st)), ", ")
	+ "}"
}
