import tools/flowc/typechecker2/gtype;
import ds/easygraph_utils;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/debug;
import tools/flowc/type_helpers;

export {
	// Resolve the graph
	resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv, makeTypars : bool) -> GEnv;
}

// TODO: We only have to do the reachableClosure on unbound tyvars in the graph 
// TODO: We only have to recalc this when related part of the graph changes
// TODO: Introduce a structure to keep lower and upper bounds for each tyvar
// along with a set of nodes  we depend on, so we can more efficiently update
// and only recalc what is required

// TODO: findPotentialGSupertypes and findPotentialGSubtypes can be greatly optimized
// by having a subtype graph of structs and unions

resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv, makeTypars : bool) -> GEnv {
	if (env.verbose >= 2) {
		println("Resolving tyvars: " + toString(set2array(env.unresolvedTyvars)) + " making typars: " + b2s(makeTypars));
	}
	graph = env.relations.graph;

	// What nodes define the transitive upper bounds for each node?
	upperBounds : Tree<int, Set<int>> = reachableClosure(graph);

	// What nodes define the transitive lower bounds for each node?
	reverseGraph = reverseEasyGraph(graph);
	lowerBounds : Tree<int, Set<int>> = reachableClosure(reverseGraph);

	unresolved = sizeSet(env.unresolvedTyvars);
	nenv = foldTree(lowerBounds, env, \nodeid, lowerIds, acc -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc;
			Some(node): {
				type = node.data;
				switch (type) {
					GTypeVar(tyvarId): {
						if (!containsKeyTree(acc.tyvars, tyvarId)) {
							lower = buildGBounds(acc, graph, lowerIds);
							upperIds = lookupTreeDef(upperBounds, nodeid, makeSet());
							upper = buildGBounds(acc, graph, upperIds);
							clarifyGTyvar(acc, unify, tyvarId, lower, upper, makeTypars);
						} else {
							acc;
						}
					}
					default: {
						acc;
					}
				}
			}
		}
	});

	if (sizeSet(nenv.unresolvedTyvars) != unresolved) {
		resolveGGraph(nenv, name, unify, false)
	} else {
		if (makeTypars) {
			nenv;
		} else {
			// Do a final round where we make typars
			resolveGGraph(nenv, name, unify, true)
		}
	}
}

// We know this tyvar is unbound, and we know about all the bounds.
// See if we can solve it
clarifyGTyvar(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvar : int, lower : GBounds, upper : GBounds, makeTypars : bool) -> GEnv {
	// OK, check if it is fixed
	fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);

	if (!isEmptySet(fixed)) {
		// OK, we have something fixed. Let us go with that

		// What remains of the subtypes bounds once the fixed types are removed?
		lowerMissing = differenceSets(mapSet(lower.subtypes, \s -> GSubType(s)), fixed);	
		upperMissing = differenceSets(mapSet(upper.subtypes, \s -> GSubType(s)), fixed);	

		if (isEmptySet(lowerMissing) && isEmptySet(upperMissing)) {
			// OK, some fixed type. If flow is there, we can ignore that
			sansFlow = removeSet(fixed, GFlow());
			if (sizeSet(sansFlow) == 1 || sizeSet(fixed) == 1) {
				fixedTypes = if (sizeSet(sansFlow) == 1) sansFlow else fixed;
				fixedType = set2array(fixedTypes)[0];

				// OK, we have a unique, fixed type
				setGTyvars(env, unify, insertSet(mergeSets(lower.tyvars, upper.tyvars), tyvar), fixedType);
			} else {
				// It is not clear yet. Let us unify the lowers with the upppers in an attempt to
				// uncover more constraints
				foldSet(lower.fixedTypes, env, \acc, lt -> {
					foldSet(upper.fixedTypes, acc, \acc2, ut -> {
						unify(acc2, lt, ut)
					})
				})
			}
		} else {
			// This is a mixed bag, so probably this is an error?
			println("TODO: Can we do something about " + gbounds2string(env, lower) + " c= α" + i2s(tyvar) + " c= " + gbounds2string(env, upper));
			env;
		}
	} else {
		// OK, no fixed
		lowerFree = isGBoundsUnconstrained(env, lower);
		upperFree = isGBoundsUnconstrained(env, upper);

		if (lowerFree && upperFree) {
			if (makeTypars) {
				// No constraints. All of these tyvars are all identical and should be bound
				// to the next free typar.
				tyvars = insertSet(mergeSets(lower.tyvars, upper.tyvars), tyvar);
				resolveGTypeVarToTyPar(env, tyvars);
			} else {
				// While we are working, do not pin these down since new contraints can appear
				// witch lift them away from type par land. test 1 is an example.
				env;
			}
		} else {
			// Subtypes only. Find any types that might be compatible
			ltypenames : [string] = findPotentialGSupertypes(env, lower.subtypes);
			ltypes = if (length(ltypenames) == 1) {
				// We know that there is only one type that will work. This is also true in the future, even if we
				// have lower tyvars that might be bound in the future, because if they conflict,
				// type verification will catch it and there would not be any solution
				solution = resolveGSubTypeToName(env, ltypenames[0], lower.subtypes);
				if (env.verbose >= 3) {
					printStay(env.env, "Made " + gtype2string(env, solution) + " to meet " + gbounds2string(env, lower));
				};
				[solution];
			} else [];

			utypenames = findPotentialGSubtypes(env, upper.subtypes);
			utypes = if (length(utypenames) == 1) {
				solution = resolveGSubTypeToName(env, utypenames[0], upper.subtypes) ;
				if (env.verbose >= 3) {
					printStay(env.env, "Made " + gtype2string(env, solution) + " to meet " + gbounds2string(env, upper));
				};
				[solution];
			} else [];

			if (lowerFree && !upperFree) {
				if (length(utypes) == 1) {
					// Upper decides and is unique, so set all lower to the result
					solution = utypes[0];
					nenv = setGTyvars(env, unify, insertSet(lower.tyvars, tyvar), solution);
					// Also be sure to unify the result against all our top subtypes to extract gold
					foldSet(upper.subtypes, nenv, \acc, st -> {
						unify(acc, solution, GSubType(st))
					});
				} else {
					if (sizeSet(upper.subtypes) == 1) {
						// A single named struct/union as the bound - we just take it
						subtype = set2array(upper.subtypes)[0];
						switch (subtype) {
							GNamed(__, __): setGTyvars(env, \e, l, u -> unify(e, u, l), insertSet(lower.tyvars, tyvar), GSubType(subtype));
							default: {
								println("TODO: Upper should decide from " + gbounds2string(env, upper));
								println(utypes);
								env;
							}
						}
					} else {
						println("TODO: Upper should decide from " + gbounds2string(env, upper));
						println(utypes);
						env;
					}
				}
			} else if (!lowerFree && upperFree) {
				if (length(ltypes) == 1) {
					// Lower decides. We just have to make sure we unify the result backwards
					solution = ltypes[0];
					nenv = setGTyvars(env, \e, l, u -> unify(e, u, l), insertSet(upper.tyvars, tyvar), solution);
					// Also be sure to unify the result against all our lower subtypes to extract gold
					foldSet(lower.subtypes, nenv, \acc, st -> {
						unify(acc, GSubType(st), solution)
					});
				} else {
					if (sizeSet(lower.subtypes) == 1) {
						// A single named struct/union as the bound - we just take it
						subtype = set2array(lower.subtypes)[0];
						switch (subtype) {
							GNamed(__, __): setGTyvars(env, \e, l, u -> unify(e, u, l), insertSet(upper.tyvars, tyvar), GSubType(subtype));
							default: {
								println("TODO: Lower should decide from " + gbounds2string(env, lower));
								println(gtype2string(env, GSubType(subtype)));
								env;
							}
						}
					} else {
						println("TODO: Lower should decide from " + gbounds2string(env, lower));
						println(ltypenames);
						println(ltypes);
						env;
					}
				}
			} else if (length(ltypenames) == 1 && ltypenames == utypenames) {
				// OK, they agree on the type. Cosntruct it
				solution = resolveGSubTypeToName(env, utypenames[0], mergeSets(lower.subtypes, upper.subtypes));

				// And set ourselves to this
				nenv = setGTyvars(env, unify, makeSet1(tyvar), solution);

				// Also be sure to unify the result against all our top and lower subtypes to extract gold
				nenv1 = foldSet(upper.subtypes, nenv, \acc, st -> {
					unify(acc, solution, GSubType(st))
				});
				foldSet(lower.subtypes, nenv1, \acc, st -> {
					unify(acc, GSubType(st), solution)
				});
			} else {
				// TODO: Check the intersection and if that is unique
				// without anything missing, we also solved it

				// TODO: If there are no tyvars in the lower one, then
				// pick the biggest that still fits upper
				// If there are no tyvars in the upper one, then pick the
				// smallest that still fits lower

				println("TODO: Caught betwen two rocks: "  + gbounds2string(env, lower) + " c= α" + i2s(tyvar) + " c= " + gbounds2string(env, upper));
				println(ltypenames);
				println(utypenames);

				// It is not clear yet. Let us unify the lowers with the upppers in an attempt to
				// uncover more constraints
				foldSet(lower.subtypes, env, \acc, lt -> {
					foldSet(upper.subtypes, acc, \acc2, ut -> {
						unify(acc2, GSubType(lt), GSubType(ut))
					})
				});
			}
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 3) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
	});
}

// Does this only contain unresolved tyvars?
isGBoundsUnconstrained(env : GEnv, node : GBounds) -> bool {
	isEmptySet(node.fixedTypes) && isEmptySet(node.subtypes)
	&& foldSet(node.tyvars, true, \acc, tv -> {
		acc && !containsKeyTree(env.tyvars, tv)
	})
}

// Set all tyvars to this resolved type
setGTyvars(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvars : Set<int>, type : GType) -> GEnv {
	if (env.verbose >= 2) {
		printStay(env.env, superglue(set2array(tyvars), \tv -> "α" + i2s(tv), ", ") + " = " + gtype2string(env, type));
	}

	nenv = foldSet(tyvars, env, \acc, tv -> {
		nacc = GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, type),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
		unify(nacc, GTypeVar(tv), type)
	});

	// Extract any new, unbound tyvars in the type and add them to the pool that has to be resolved
	tyvarsInType = extractGTypeVars(nenv, type, makeSet());
	GEnv(
		nenv with
		unresolvedTyvars = mergeSets(nenv.unresolvedTyvars, tyvarsInType)
	);
}

// Given these constraints, what supertypes could meet all of these?
findPotentialGSupertypes(env : GEnv, exprs : Set<GSubTypeExpr>) -> [string] {
	foldi(set2array(exprs), [], \i, acc, expr -> {
		supers = findGSupertypes(env, expr);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}

// Find all types which type can be dominated by, including itself
findGSupertypes(env : GEnv, expr : GSubTypeExpr) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mst = lookupTree(env.env.program.acc.names.structs, name);
			switch (mst) {
				None(): {
					// A union: Expand to members
					typenames : [FcTypeName] = union2typenames(env.env, name);
					// And then do a recursive call on the members
					supers : Set<GSubTypeExpr> = buildSet(map(typenames, \tn -> GNamed(tn.name, [])));
					findPotentialGSupertypes(env, supers);
				}
				Some(st): {
					arrayPush(
						getTreeArrayValue(env.env.program.acc.names.struct2unions, name),
						name
					);
				}
			}
		}
		GField(field, __): {
			getTreeArrayValue(env.env.program.acc.names.field2structs, field);
		}
		GAnd(exprs): {
			findPotentialGSupertypes(env, buildSet(exprs));
		}
		GOr(exprs): {
			uniq(fold(exprs, [], \acc, sexpr -> {
				concat(acc, findGSupertypes(env, sexpr))
			}));
		}
	}
}

// Given these constraints, what subtypes could meet all of these?
findPotentialGSubtypes(env : GEnv, exprs : Set<GSubTypeExpr>) -> [string] {
	foldi(set2array(exprs), [], \i, acc, expr -> {
		supers = findGSubtypes(env, expr);
		if (i == 0) supers
		else intersection(supers, acc)
	});
}


// Find all types which are subtypes of this constraint, including ourselves
findGSubtypes(env : GEnv, expr : GSubTypeExpr) -> [string] {
	switch (expr) {
		GNamed(name, __): {
			mun = lookupTree(env.env.program.acc.names.unions, name);
			switch (mun) {
				None(): {
					// A struct: It can only be ourselves
					[name];
				}
				Some(un): {
					// A union: It can be ourselves, any subunion or the structs
					uniq(fold(un.typenames, [name], \acc, tn -> {
						concat(acc, findGSubtypes(env, GNamed(tn.name, [])))
					}));
				}
			}
		}
		GField(field, __): {
			getTreeArrayValue(env.env.program.acc.names.field2structs, field);
		}
		GAnd(exprs): {
			println("TODO: Subtypes of this and");
			findPotentialGSupertypes(env, buildSet(exprs));
		}
		GOr(exprs): {
			println("TODO: Subtypes of this or");
			findPotentialGSupertypes(env, buildSet(exprs));
		}
	}
}

// Given these exprs, and a desired type name, extract it, if we directly have it.
// If we do not, then we should construct the type ourselves with type-pars.
resolveGSubTypeToName(env : GEnv, name : string, exprs : Set<GSubTypeExpr>) -> GType {
	result = foldSet(exprs, [], \acc, expr -> {
		switch (expr) {
			GNamed(gname, __): if (gname == name) arrayPush(acc, GSubType(expr)) else acc;
			default: acc;
		}
	});

	if (result == []) {
		// OK, we could not find it, so we have to construct it
		makeGNamedType(env, name)
	} else result[0];
}

// Build a type with this name, and empty typars
makeGNamedType(env : GEnv, name : string) -> GType {
	mstruct = lookupTree(env.env.program.acc.names.structs, name);
	GSubType(switch (mstruct) {
		None(): {
			munion = lookupTree(env.env.program.acc.names.unions, name);
			switch (munion) {
				None(): {
					// Not found.
					GNamed(name, []);
				}
				Some(union): {
					GNamed(name, map(union.typeparameters, \__ -> {
						mkGTypeVar(env)
					}))
				}
			}
		}
		Some(structdef): {
			GNamed(name, map(structdef.typars, \__ -> {
				mkGTypeVar(env)
			}))
		}
	})
}

mkGTypeVar(env : GEnv) -> GTypeVar {
	GTypeVar(nextUniqueId(env.tyvarIdGroup));
}

emptyGBounds() -> GBounds {
	GBounds(makeSet(), makeSet(), makeSet())
}

buildGBounds(env : GEnv, graph : EasyGraph<GType, bool>, nodes : Set<int>) -> GBounds {
	foldSet(nodes, emptyGBounds(), \acc : GBounds, nodeid : int -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc; // Not supposed to happen
			Some(node): addGTypeToGBounds(env, acc, node.data);
		}
	});
}

addGTypeToGBounds(env : GEnv, acc : GBounds, tt : GType) -> GBounds {
	fixed = \ -> GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, tt));
	switch (tt) {
		GBasicType(t): fixed();
		GFlow(): fixed();
		GTypePar(id): fixed();
		GFunction(args, rt): fixed();
		GArray(type): fixed();
		GRef(type): fixed();
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): {
					GBounds(acc with tyvars = insertSet(acc.tyvars, id));
				}
				Some(type): {
					// If the tyvar is defined, we should put it to fixedTypes
					GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, type));
				}
			}
		}
		GSubType(expr): GBounds(acc with subtypes = insertSet(acc.subtypes, expr));
	}
}

// The total (lower or upper) bounds of a given tyvar. We can depend on three different things
// The tyvars are all known to be unbound.
GBounds(tyvars : Set<int>, fixedTypes : Set<GType>, subtypes : Set<GSubTypeExpr>);

gbounds2string(env : GEnv, g : GBounds) -> string {
	"{"
	+ superglue(set2array(g.tyvars), \tv -> "α" + i2s(tv), ", ")
	+ " : " + superglue(set2array(g.fixedTypes), \t -> gtype2string(env, t), ", ")
	+ " : " + superglue(set2array(g.subtypes), \st -> gtype2string(env, GSubType(st)), ", ")
	+ "}"
}

