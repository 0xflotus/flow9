import tools/flowc/typechecker2/gtype;
import ds/easygraph_utils;
import text/blueprint;
import tools/flowc/typechecker2/gtype_util;
import tools/flowc/debug;

export {
	// Resolve the graph
	resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv;
}


// TODO: We only have to do the reachableClosure on unbound tyvars in the graph 
// TODO: We only have to recalc this when related part of the graph changes

resolveGGraph(env : GEnv, name : string, unify : (GEnv, GType, GType) -> GEnv) -> GEnv {
	graph = env.relations.graph;

	// What nodes define the transitive upper bounds for each node?
	upperBounds : Tree<int, Set<int>> = reachableClosure(graph);

	// What nodes define the transitive lower bounds for each node?
	reverseGraph = reverseEasyGraph(graph);
	lowerBounds : Tree<int, Set<int>> = reachableClosure(reverseGraph);

	unresolved = sizeSet(env.unresolvedTyvars);
	nenv = foldTree(lowerBounds, env, \nodeid, lowerIds, acc -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc;
			Some(node): {
				type = node.data;
				switch (type) {
					GTypeVar(tyvarId): {
						if (!containsKeyTree(acc.tyvars, tyvarId)) {
							lower = buildGBounds(acc, graph, lowerIds);
							upperIds = lookupTreeDef(upperBounds, nodeid, makeSet());
							upper = buildGBounds(acc, graph, upperIds);
							clarifyGTyvar(acc, unify, tyvarId, lower, upper);
						} else {
							acc;
						}
					}
					default: {
						acc;
					}
				}
			}
		}
	});

	if (sizeSet(nenv.unresolvedTyvars) != unresolved) {
		resolveGGraph(nenv, name, unify)
	} else {
		nenv;
	}
}

// We know this tyvar is unbound, and we know about all the bounds.
// See if we can solve it
clarifyGTyvar(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvar : int, lower : GBounds, upper : GBounds) -> GEnv {
	// OK, check if it is fixed
	fixed = mergeSets(lower.fixedTypes, upper.fixedTypes);

	if (!isEmptySet(fixed)) {
		// OK, we have something fixed. Let us go with that

		// What remains of the subtypes bounds once the fixed types are removed?
		lowerMissing = differenceSets(mapSet(lower.subtypes, \s -> GSubType(s)), fixed);	
		upperMissing = differenceSets(mapSet(upper.subtypes, \s -> GSubType(s)), fixed);	

		if (isEmptySet(lowerMissing) && isEmptySet(upperMissing)) {
			// OK, some fixed type. If flow is there, we can ignore that
			sansFlow = removeSet(fixed, GFlow());
			if (sizeSet(sansFlow) == 1 || sizeSet(fixed) == 1) {
				// OK, we have a unique, fixed type
				setGTyvars(env, unify, tyvar, GBounds(
						mergeSets(lower.tyvars, upper.tyvars),
						sansFlow,
						makeSet()
					)
				);
			} else {
				// It is not clear yet. Let us unify the lowers with the upppers in an attempt to
				// uncover more constraints
				foldSet(lower.fixedTypes, env, \acc, lt -> {
					foldSet(upper.fixedTypes, acc, \acc2, ut -> {
						unify(acc2, lt, ut)
					})
				})
			}
		} else {
			// This is a mixed bag, so probably this is an error?
			println("TODO: Can we do something about " + gnodes2string(env, lower) + " c= α" + i2s(tyvar) + " c= " + gnodes2string(env, upper));
			env;
		}
	} else {
		// OK, no fixed
		lowerFree = isGBoundsUnconstrained(env, lower);
		upperFree = isGBoundsUnconstrained(env, upper);

		if (lowerFree && upperFree) {
			// No constraints. Al lof these tyvars are all identical and should be bound
			// to the next free typar
			tyvars = insertSet(mergeSets(lower.tyvars, upper.tyvars), tyvar);
			resolveGTypeVarToTyPar(env, tyvars);
		} else if (lowerFree && !upperFree) {
			// Upper decides to be the subtype
			setGTyvars(env, unify, tyvar, upper);
		} else if (!lowerFree && upperFree) {
			// Lower decides. We just have to make sure we unify the result backwards
			setGTyvars(env, \e, l, u -> unify(e, u, l), tyvar, lower);
		} else {
			// OK, we only have subtyping constraints, but from both ends
			resolveGSubtypeBounds(env, unify, tyvar, lower, upper)			
		}
	}
}

// Set all these tyvars to the next free typar
resolveGTypeVarToTyPar(env : GEnv, tyvars : Set<int>) -> GEnv {
	// Find the next free type par
	typars = foldTree(env.tyvars, makeSet(), \tv, type, acc -> {
		extractGTypePars(env, type, acc)
	});
	mtypar = popMaxSet(typars);
	lasttypar = eitherMap(mtypar, \r -> r.value, "");
	typar = GTypePar(lasttypar + "?");

	// Now, set all tyvars to this typar		
	foldSet(tyvars, env, \acc, tv -> {
		if (env.verbose >= 3) {
			printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, typar));
		}
		GEnv(
			acc with
			tyvars = setTree(acc.tyvars, tv, typar),
			unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
		);
	});
}

resolveGSubtypeBounds(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvar : int, lower : GBounds, upper : GBounds) -> GEnv {
	println("TODO: Resolve subtype bounds " + gnodes2string(env, lower) + " c= α" + i2s(tyvar) + " c= " + gnodes2string(env, upper));

	env;
}

isGBoundsUnconstrained(env : GEnv, node : GBounds) -> bool {
	isEmptySet(node.fixedTypes) && isEmptySet(node.subtypes)
	&& foldSet(node.tyvars, true, \acc, tv -> {
		acc && !containsKeyTree(env.tyvars, tv)
	})
}

// Set all tyvars (also in the bounds) to a resolved type, assuming it exists 
setGTyvars(env : GEnv, unify : (GEnv, GType, GType) -> GEnv, tyvar : int, node : GBounds) -> GEnv {
	mtype = resolveGBounds(env, node);
	switch (mtype) {
		None(): env;
		Some(type): {
			foldSet(insertSet(node.tyvars, tyvar), env, \acc, tv -> {
				if (env.verbose >= 3) {
					printStay(env.env, "α" + i2s(tv) + " = " + gtype2string(env, type));
				}
				nacc = GEnv(
					acc with
					tyvars = setTree(acc.tyvars, tv, type),
					unresolvedTyvars = removeSet(acc.unresolvedTyvars, tv)
				);
				unify(nacc, GTypeVar(tv), type)
			});
		}
	}
}

resolveGBounds(env : GEnv, nodes : GBounds) -> Maybe<GType> {
	fixed = set2array(nodes.fixedTypes);

	missingSubTypes : Set<GType> = differenceSets(mapSet(nodes.subtypes, \s -> GSubType(s)), nodes.fixedTypes);	
	subtypes = set2array(missingSubTypes);

	if (fixed != [] && subtypes == []) {
		// OK, some fixed type
		if (length(fixed) == 1) {
			// A single fixed
			Some(fixed[0]);
		} else {
			println("TODO: Resolve fixed conflict " + gnodes2string(env, nodes));
			None();
		}
	} else if (fixed == [] && subtypes != []) {
		if (length(subtypes) == 1) {
			// A single subtype
			Some(subtypes[0]);
		} else {
			println("TODO: Find union for " + gnodes2string(env, nodes));
			None();
		}
	} else {
		println("TODO: Conflict " + gnodes2string(env, nodes));
		None();
	}
}

emptyGBounds() -> GBounds {
	GBounds(makeSet(), makeSet(), makeSet())
}

buildGBounds(env : GEnv, graph : EasyGraph<GType, bool>, nodes : Set<int>) -> GBounds {
	foldSet(nodes, emptyGBounds(), \acc : GBounds, nodeid : int -> {
		mnode = lookupTree(graph.nodes, nodeid);
		switch (mnode) {
			None(): acc; // Not supposed to happen
			Some(node): addGTypeToGBounds(env, acc, node.data);
		}
	});
}

addGTypeToGBounds(env : GEnv, acc : GBounds, tt : GType) -> GBounds {
	fixed = \ -> GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, tt));
	switch (tt) {
		GBasicType(t): fixed();
		GFlow(): fixed();
		GTypePar(id): fixed();
		GFunction(args, rt): fixed();
		GArray(type): fixed();
		GRef(type): fixed();
		GTypeVar(id): {
			mtype = lookupTree(env.tyvars, id);
			switch (mtype) {
				None(): {
					GBounds(acc with tyvars = insertSet(acc.tyvars, id));
				}
				Some(type): {
					// If the tyvar is defined, we should put it to fixedTypes
					GBounds(acc with fixedTypes = insertSet(acc.fixedTypes, type));
				}
			}
		}
		GSubType(expr): GBounds(acc with subtypes = insertSet(acc.subtypes, expr));
	}
}

// The total (lower or upper) bounds of a given tyvar. We can depend on three different things
// The tyvars are all known to be unbound.
GBounds(tyvars : Set<int>, fixedTypes : Set<GType>, subtypes : Set<GSubTypeExpr>);

gnodes2string(env : GEnv, g : GBounds) -> string {
	"{"
	+ superglue(set2array(g.tyvars), \tv -> "α" + i2s(tv), ", ")
	+ " : " + superglue(set2array(g.fixedTypes), \t -> gtype2string(env, t), ", ")
	+ " : " + superglue(set2array(g.subtypes), \st -> gtype2string(env, GSubType(st)), ", ")
	+ "}"
}

isGTypeResolved(tt : GType) -> bool {
	switch (tt) {
		GBasicType(t): true;
		GFlow(): true;
		GTypePar(id): true;
		GFunction(args, rt): forall(args, isGTypeResolved) && isGTypeResolved(rt);
		GArray(type): isGTypeResolved(type);
		GRef(type): isGTypeResolved(type);
		GTypeVar(id): false;
		GSubType(expr): false;
	}
}

