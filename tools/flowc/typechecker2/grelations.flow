import tools/flowc/typechecker2/gtype;
import tools/flowc/typechecker2/gtype_util;
import ds/treeutils;

export {
	// This exposes the unifications we need to consider
	makeGRelations() -> GRelations;

	addGRelation(r : GRelations, lower : GType, upper : GType, pos : int) -> GRelations;

	getGUpperRelations(r : GRelations, from : GType) -> Set<GType>;
	getGLowerRelations(r : GRelations, from : GType) -> Set<GType>;
	getGRelationPositions(r : GRelations, from : GType) -> Set<int>;

	getGUpperTransitiveRelations(r : GRelations, from : GType) -> Set<GType>;
	getGLowerTransitiveRelations(r : GRelations, from : GType) -> Set<GType>;

	transitiveGUpperRelations(r : GRelations, from : GType, seen : Set<GType>) ->  Set<GType>;
	transitiveGLowerRelations(r : GRelations, from : GType, seen : Set<GType>) ->  Set<GType>;

	// Add .dot output to help debug these graphs
	saveGDot(env : GEnv, name : string) -> void;
}

makeGRelations() -> GRelations {
	GRelations(makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), makeTree());
}
 
addGRelation(r : GRelations, from : GType, to : GType, pos : int) -> GRelations {
	if (containsMultimap(r.uppers, from, to)) r
	else {
		//
		// Calculate the transitive closure for the uppers
		//

		// What new upper nodes do we get access to with this node?
		newUppers = insertSet(
			lookupMultimap(r.uppersTransitive, to),
			to
		);

		// What do we already know, and what is truly new?
		knownUppers = lookupMultimap(r.uppersTransitive, from);
		trulyNewUppers = differenceSets(newUppers, knownUppers);

		// What types are dependent on us, and have to get the new upper nodes?
		lowersAndUsToUpdate = insertSet(lookupMultimap(r.lowersTransitive, from), from);

		upperTransitives = if (isEmptySet(trulyNewUppers)) {
			// There are no real new ones, so we are good
			r.uppersTransitive
		} else {
			foldSet(lowersAndUsToUpdate, r.uppersTransitive, \acc, toUpdate -> {
				upTrans0 = lookupMultimap(r.uppersTransitive, toUpdate);
				upTrans = mergeSets(upTrans0, trulyNewUppers);
				setTree(acc, toUpdate, upTrans);
			});
		}

		//
		// Calculate the transitive closure for the lowers
		//

		// What new lower nodes do we get access to with this node?
		newLowers = insertSet(
			lookupMultimap(r.lowersTransitive, from),
			from
		);

		// What do we already know, and what is truly new?
		knownLowers = lookupMultimap(r.lowersTransitive, to);
		trulyNewLowers = differenceSets(newLowers, knownLowers);

		// What types are dependent on us, and have to get the new upper nodes?
		uppersAndUsToUpdate = insertSet(lookupMultimap(r.uppersTransitive, to), to);
		lowerTransitives = if (isEmptySet(trulyNewLowers)) {
			// We are good
			r.lowersTransitive
		} else {
			foldSet(uppersAndUsToUpdate, r.lowersTransitive, \acc, toUpdate -> {
				upTrans = lookupMultimap(r.lowersTransitive, toUpdate);
				setTree(acc, toUpdate, mergeSets(upTrans, trulyNewLowers));
			});
		}

		// Reset the queue for these guys
		totalUpdates = mergeSets(lowersAndUsToUpdate, uppersAndUsToUpdate);
		queue = foldSet(totalUpdates, r.tyvarQueue, \acc, type -> {
			switch (type) {
				GTypeVar(tyvarid): {
					// This tyvar is reset back to priority 0
					// println("Redo tyvar " + i2s(tyvarid));
					setTree(acc, GQueueItem(0, tyvarid), tyvarid);
				}
				default: acc;
			}
		});

		GRelations(
			insertMultimap(r.uppers, from, to),
			insertMultimap(r.lowers, to, from),
			upperTransitives,
			lowerTransitives,
			insertMultimap(
				insertMultimap(r.positions, to, pos),
				from, pos
			),
			queue
		);
	}
}

getGUpperRelations(r : GRelations, from : GType) -> Set<GType> {
	lookupMultimap(r.uppers, from);
}

getGLowerRelations(r : GRelations, from : GType) -> Set<GType> {
	lookupMultimap(r.lowers, from);
}

getGUpperTransitiveRelations(r : GRelations, from : GType) -> Set<GType> {
	lookupMultimap(r.uppersTransitive, from);
}

getGLowerTransitiveRelations(r : GRelations, from : GType) -> Set<GType> {
	lookupMultimap(r.lowersTransitive, from);
}

getGRelationPositions(r : GRelations, from : GType) -> Set<int> {
	lookupMultimap(r.positions, from);
}

transitiveGUpperRelations(r : GRelations, from : GType, acc : Set<GType>) -> Set<GType> {
	if (containsSet(acc, from)) {
		acc
	} else {
		uppers = getGUpperRelations(r, from);
		foldSet(uppers, acc, \acc2, edge -> {
			nacc = insertSet(acc2, edge);
			transitiveGUpperRelations(r, edge, nacc)
		});
	}
}

transitiveGLowerRelations(r : GRelations, from : GType, acc : Set<GType>) -> Set<GType> {
	if (containsSet(acc, from)) {
		acc
	} else {
		uppers = getGLowerRelations(r, from);
		foldSet(uppers, acc, \acc2, edge -> {
			nacc = insertSet(acc2, edge);
			transitiveGLowerRelations(r, edge, nacc)
		});
	}
}

saveGDot(env : GEnv, name : string) -> void {
	dot = grelations2dot(env, env.grelations);
	setFileContent(name + ".dot", dot);

	{}
}

grelations2dot(env : GEnv, g : GRelations) -> string {
	type2node = \type -> {
		"\"" + gtype2string(env, type) + "\""
	}
	types = foldTree(g.uppers, makeSet(), \k, v, acc -> {
		insertSet(acc, k);
	});
	nodesDump = foldSet(types, "", \acc, type -> {
		text = type2node(type);
		acc + text + " [label=" + text + "];\n"
	});
	edgesDump0 = foldTree(g.uppers, "", \from, tos, acc -> {
		foldSet(tos, acc, \acc1, to -> {
			acc1 + type2node(from) + " -> " + type2node(to) + ";\n"
		});
	});

	edgesDump = if (true) edgesDump0 else foldTree(g.lowersTransitive, edgesDump0, \from, tos, acc -> {
		text = type2node(from);
		foldSet(tos, acc, \acc1, to -> {
			acc1 + type2node(to) + " -> " + type2node(from) + " [color=grey label=" + text +  "];\n"
		});
	});

	"digraph graphname {\n" +
		nodesDump + "\n" +
		edgesDump + "\n" +
	"}"
}
