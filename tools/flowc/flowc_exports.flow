import ds/bitvector;
import stringmath;
import tools/flowc/manipulation/freevars;
import tools/flowc/fctypeenv;
import tools/flowc/flowc_helpers;
import tools/flowc/incremental/fiprettyprint;
import tools/flowc/incremental/fi_helpers;

export {
	fcCheckExports(env : FiProgram, onError : (FcError) -> void) -> void;
}

ProgramExportsAcc(
	env : FiProgram,

	// All exported global names in the programm.
	allNames : [string],
	
	// Mapping from exported global names to their indexes in 'allNames'.
	name2index : Tree<string, int>,

	// Cumulative imported names, which are available at given module.
	// Strictly speaking, we store the bits of presence/non-presence
	// of some global name from 'allNames' in the BitVector, corresponding to the module.
	moduleImports : Tree<string, BitVector>,
);

fcCheckExports(env : FiProgram, onError : (FcError) -> void) -> void {
	time_start = timestamp();
	allExported = foldTree(env.modules, makeSet(),
		\name, module, acc -> fold(module.exports, acc, \a, n -> insertSet(acc, n))
	);
	allNames = set2array(allExported);
	name2index = foldi(allNames, makeTree(), \i, acc, name -> setTree(acc, name, i));
	aaa = fold(env.traversal, ProgramExportsAcc(env, allNames, name2index, makeTree()), 
		\acc, name -> {
			module = lookupTreeDef(env.modules, name, dummyFiModule);
			fcCheckModuleExports(acc, module,
				\e, s -> onError(FcError(e, [FcPosition(module.fileinfo.flowfile, s, s)]))
			)
		}
	);
	fcPrintln("EXPORTS CHECKED IN: " + d2st((timestamp() - time_start) / 1000.0, 2) + "s\n");
	{ }
}

fcCheckModuleExports(progAcc : ProgramExportsAcc, module : FiModule, onError : (string, int) -> void) -> ProgramExportsAcc {

	

	locals0 = buildSet(module.initOrder);
	locals = fold(module.natives, locals0, \acc, n -> insertSet(acc, n.name));
	localTypenames0 = fold(module.structs, makeSet(), \acc, s -> insertSet(acc, s.name));
	localTypenames = fold(module.unions, localTypenames0, \acc, u -> insertSet(acc, u.name));
	flowfile = module.fileinfo.flowfile;
	exportsSet = buildSet(module.exports);
	
	
	thisModuleImports = fold(
			module.imports,
			makeBitVector(length(progAcc.allNames), 
				\i -> containsSet(exportsSet, progAcc.allNames[i])
			),
			\a, imp -> bitVectorOr(a, 
				lookupTreeDef(progAcc.moduleImports, imp.flowfile, makeEmptyBitVector(length(progAcc.allNames)))
			)
		);
	
	newModuleImports = setTree(
		progAcc.moduleImports,
		flowfile,
		thisModuleImports
	);
	
	acc = ModuleExportsAcc(
		progAcc,
		/*switch (progAcc.env.program.exported) {
			FcExportedSeparate(names): lookupTreeDef(names, flowfile, makeSet());
			FcExportedCommon(names): names;
		},*/
		thisModuleImports,
		localTypenames,
		fold(module.structs,
			fold(module.unions,
				makeTree(),
				\acc : Tree<string, FiStructOrUnion>, union -> setTree(acc, union.name, union)
			),
			\acc, struct -> setTree(acc, struct.name, struct)
		),
		onError,
		flowfile
	);
	iter(module.functions, \f -> fcExpCheckExports(acc, locals, f.lambda));
	iter(module.globalVars, \g -> fcExpCheckExports(acc, locals, g.value));
	progAcc
}

ModuleExportsAcc(
	progAcc : ProgramExportsAcc,
	//exports : Set<string>,
	bitVectorExports : BitVector,
	localTypeNames : Set<string>,
	moduleStructsUnions : Tree<string, FiStructOrUnion>,
	onError : (string, int) -> void,
	moduleName : string
);

fcExpCheckExports(eacc : ModuleExportsAcc, bound : Set<string>, expr : FiExp) -> void {
	// fcExpCheckType(eacc, fiExpType(expr), expr.start);
	fold_exports = \es -> iter(es, \e -> fcExpCheckExports(eacc, bound, e));
	switch (expr) {
		FiLambda(args, e, __, __): fcExpCheckExports(eacc, fold(args, bound, \acc, arg -> insertSet(acc, arg.name)), e);
		FiCall(f, es, __, __): {
			fcExpCheckExports(eacc, bound, f);
        	fold_exports(es);
		}
		FiVar(x, t, i): {
			if (!containsSet(bound, x) && /*!containsSet(eacc.exports, x)*/ !checkForExportsName(eacc, x)) {
				eacc.onError(x + " : " + prettyFiType(dummyPretty, t, makeSet()) + "; is not exported" + 
					fcAddMessageSuggestingProperImport(eacc, x), expr.start
				);
			}
		}
		FiLet(x, __, e1, e2, __, __): {
			fcExpCheckExports(eacc, bound, e1);
			fcExpCheckExports(eacc, insertSet(bound, x), e2);
		}
		FiIf(e1, e2, e3, __, __):     fold_exports([e1, e2, e3]);
		FiSwitch(e, __, cs, __, __):{
			fcExpCheckExports(eacc, bound, e);
			iter(cs, \c -> {
				if (c.struct != "default" && !containsSet(eacc.localTypeNames, c.struct) && /*!containsSet(eacc.exports, c.struct)*/ !checkForExportsName(eacc, c.struct)) {
					eacc.onError("Can not deconstruct " + c.struct + " since that struct is not exported" + 
						fcAddMessageSuggestingProperImport(eacc, c.struct), expr.start
					);
				}
				fcExpCheckExports(eacc, mergeSets(bound, buildSet(c.argNames)), c.body)
			});
		}
		FiCast(e, __, __, __, __):    fcExpCheckExports(eacc, bound, e);
		FiSeq(es, __, __):            fold_exports(es);
		FiCallPrim(o, es, ty, start): {
			switch (o) {
				FcStructPrim(name): {
					if (!containsSet(eacc.localTypeNames, name) && /*!containsSet(eacc.exports, name)*/ !checkForExportsName(eacc, name)) {
						eacc.onError("Can not construct " + name + " : " + prettyFiType(dummyPretty, fiExpType(expr), makeSet()) + " since it is not exported" +
							fcAddMessageSuggestingProperImport(eacc, name), expr.start
						);
					}
				}
				FcFieldPrim(fn): {
					switch (ty) {
						FiTypeName(tn, __): {
							if (containsSet(eacc.localTypeNames, tn) || /*containsSet(eacc.exports, tn)*/ checkForExportsName(eacc, tn)) {
								// Check, that the given field name exists
								switch (fiExpType(es[0])) {
									FiTypeName(type_name, __): {
										fieldExists = fiEnsureFieldExists(
											eacc.progAcc.env.names,
											eacc.moduleStructsUnions,
											fn, type_name, \__ -> {},
											eacc.moduleName, start
										);
										if (!fieldExists) {
											eacc.onError("Type name " + type_name + " doesn't have field " + fn, expr.start);
										} else { }
									}
									FiTypeFlow(): {}  // We can't do better, if type is flow
									default: {}       // This branch must never occur
								}
							}
							else {
								eacc.onError("Can not do " + "." + fn + " since struct " + tn + " is not exported" +
									fcAddMessageSuggestingProperImport(eacc, tn), expr.start
								);
							}
						}
						default: {}
					}
				}
				FcSetMutablePrim(fn): {
					switch (ty) {
						FiTypeName(n, __): {
							if (!containsSet(eacc.localTypeNames, n) && /*!containsSet(eacc.exports, n)*/ !checkForExportsName(eacc, n)) {
								eacc.onError("Can not set " + "." + fn + " since struct " + n + " is not exported" +
									fcAddMessageSuggestingProperImport(eacc, n), expr.start
								);
							}
						}
						default: {}
					}
				}
				FcCreateClosurePrim(structName, functionName): {
					if (!containsSet(eacc.localTypeNames, structName) && /*!containsSet(eacc.exports, structName)*/ !checkForExportsName(eacc, structName)) {
						eacc.onError("Struct " + structName + " is not exported" + fcAddMessageSuggestingProperImport(eacc, structName), expr.start);
					}
					if (!containsSet(eacc.localTypeNames, functionName) && /*!containsSet(eacc.exports, functionName)*/ !checkForExportsName(eacc, functionName)) {
						eacc.onError("Function " + functionName + " is not exported" + fcAddMessageSuggestingProperImport(eacc, functionName), expr.start);
					}
				}
				default: {};
			}
			fold_exports(es);
		} 
		FiString(__, __):             {}; // here I would want to match simply on union FcConst
		FiBool(__, __):               {};
		FiDouble(__, __):             {};
		FiVoid(__):                   {};
		FiInt(__, __):                {};
        FiRequire(__, e, __, __):     fcExpCheckExports(eacc, bound, e);
        FiUnsafe(__, fb, __, __):     fcExpCheckExports(eacc, bound, fb);
	}
}

fcExpCheckType(eacc : ModuleExportsAcc, type : FiType, start : int) -> void {
	switch (type) {
		FiTypeName(name, typeparameters): {
			iter(typeparameters, \a -> fcExpCheckType(eacc, a, start));
			if (containsSet(eacc.localTypeNames, name) || checkForExportsName(eacc, name)/*containsSet(eacc.exports, name)*/) {}
			else {
				// TODO: We have to refine this and have a list of mentioned names in exports
				// which are OK to have as types, just not constructions
				// eacc.onError(prettyFiType(dummyPretty, type, makeSet()) + " is not exported", start);
			}
		}
		FiTypeVoid(): {}
		FiTypeBool(): {}
		FiTypeInt(): {}
		FiTypeDouble(): {}
		FiTypeString(): {}
		FiTypeFlow(): {}
		FiTypeNative(): {}
		FiTypeFunction(args, returnType): {
			iter(args, \a -> fcExpCheckType(eacc, a.type, start));
			fcExpCheckType(eacc, returnType, start);
		}
		FiTypeArray(t): fcExpCheckType(eacc, t, start);
		FiTypeRef(t): fcExpCheckType(eacc, t, start);
		FiTypeParameter(n): {}
	}
}

checkForExportsName(eacc : ModuleExportsAcc, name : string) -> bool {
	switch (lookupTree(eacc.progAcc.name2index, name)) {
		Some(nameInd): 
			switch (getBitVector(eacc.bitVectorExports, nameInd)) {
				Some(v): v;
				None(): false;
			}
		None(): false;
	}
}

fcAddMessageSuggestingProperImport(eacc : ModuleExportsAcc, name : string) -> string {
	definitionModule = fiModuleWhereNameIsDefined(eacc.progAcc.env.names, name);
	if (definitionModule != "") {
		"\nadd 'import " + fiModuleWhereNameIsDefined(eacc.progAcc.env.names, name) + ";' to the imports section"
	} else {
		""
	}
}
