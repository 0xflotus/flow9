import tools/flowc/incremental/fiexp;
import tools/flowc/backends/wasm/wasm_type_descriptor;
import tools/flowc/backends/wasm/wasm_exp;
import array;
import tools/flowc/backends/wasm/wasm_print;
import tools/flowc/backends/wasm/f2wasm_utils;

export {
	fiexp2wasmexp(context : WasmContext, names : FiGlobalNames, e : FiExp) -> WasmExp;
	wasmExpType(e : WasmExp) -> WasmTypeDescriptor;
}

// we will cache types for var since we need to now correct type when perform Call convert.
// i.e. situation
// 1	Let(FFF, typeFunction)
// 2		Call(
// 3			Var(function1, typeFunction), 
// 4			args1, 
// 5			typeFunction
// 6		),
// 7		Call(
// 8			Var(FFF, typeFunction), 
// 9			args2,
// 10			type2
// 11		)
// if function1 on line 3 is native function then it will return not a simple function but JS callback.
// So,  with caching we'll get proper type for FFF on line 8 and convert Call (line 7) to WasmCallHost
lookupCachedVar(locals : ref Tree<string, WasmTypeDescriptor>, nameToFind : string, type : WasmTypeDescriptor) {
	lookupTreeSet(locals, nameToFind, \n -> type);
}

fivar2wasmvar(names : FiGlobalNames, v : FiVar, local : ref Tree<string, WasmTypeDescriptor>, isnative : bool, get : bool) -> WasmVar {
	name2 = getWasmLocalVarName(v.name, fitype2wasmtype(names, v.type));
	t = fitype2wasmtypeEx(names, v.type, isnative);
	var = WasmVar(v.name, lookupCachedVar(local, name2, t));

	// in fact 'get' will be true for Var in Call node (var which define function to call) since we should know 
	// correct function type (to distinquish simple call from js callback call)
	if (get) {
		s1 = fiPrintWasmType(wasmUnifyType(t));
		s2 = fiPrintWasmType(wasmUnifyType(var.type));
		if (s1 != s2) {
			println("WARNING! Cached type differs from actual one for " + var.name);
			println("expected: " + s1);
			println("got:      " + s2);
		}

		var;
	} else {
		WasmVar(v.name, t);
	}
}

fiTypeFromType(type : WasmTypeDescriptor) -> WasmTypeDescriptor {
	switch (type) {
		WasmTypeFunction(args, returnType): returnType;
		WasmTypeJSCallback(args, returnType): returnType;
		default: type;
	}
}

fiTypeFromExp(e : WasmExp, local : ref Tree<string, WasmTypeDescriptor>) -> WasmTypeDescriptor {
	checkVar = \e1, t -> {
		switch (e1) {
			WasmVar(name, type): {
				fiTypeFromType(type);		
			}
			default: t;
		}
	}

	switch (e) {
		WasmLambda(args, b, type) : type;
		WasmCall(e1, args, type) : checkVar(e1, type);
		WasmCallNative(e1, args, type) : checkVar(e1, type);
		WasmCallHost(e1, args, type) : checkVar(e1, type);
		WasmVar(name, type) : lookupCachedVar(local, name, type);
		WasmLet(__, __, __, __, type2) : fiTypeFromType(type2);
		WasmIf(__, __, __, type) : type;
		WasmSwitch(__, __, __, type) : type;
		WasmCast(__, __, __, type) : type;
		WasmSeq(__, type) : type;
		WasmCallPrim(__, __, type) : type;
		WasmRequire(__, __, type) : type;
		WasmUnsafe(__, __, type) : type;
		WasmVoid() : WasmTypeVoid();
		WasmDouble(__) : WasmTypeDouble();
		WasmInt(__) : WasmTypeInt();
		WasmString(__) : WasmTypeString();
		WasmBool(__) : WasmTypeBool();
	}
}

dofiexp2wasmexp(context : WasmContext, names : FiGlobalNames, e : FiExp, local : ref Tree<string, WasmTypeDescriptor>, isnative : bool) {
	do_type	= \t -> fitype2wasmtypeEx(names, t, false);
	do_exp	= \ex    -> dofiexp2wasmexp(context, names, ex, local, false);
	do_exp2	= \ex, n -> dofiexp2wasmexp(context, names, ex, local, n);
	do_var	= \v, n, g	 -> fivar2wasmvar(names, v, local, n, g);

	switch (e) {
		FiLambda(args, b, type, __): {
			args2 = map(args, \a -> WasmFunArg(a.name, do_type(a.type)));
			WasmLambda(args2, do_exp(b), do_type(type))
		}
		FiCall(f, args, type, __): {
			switch (f) {
				FiVar(fname, ftype, __): {
					is_native_call = containsKeyTree(context.natives, fname);
					ee = do_var(f, is_native_call, true);
					// ee = do_exp2(f, is_native_call);
					tt = fiTypeFromExp(ee, local);
					ttt = fiTypeFromType(fitype2wasmtypeEx(names, ftype, is_native_call));

					args_new = map(args, \a -> do_exp2(a, is_native_call));

					switch (tt) {
						WasmTypeJSCallback(__, __): {	
							WasmCallHost(
								ee, 
								concat(
									// add a function index (returned from JS)
									[WasmVar(fname, WasmTypeInt())],
									args_new
								), 
								ttt
							);
						}

						default: {
							if (is_native_call) {
								WasmCallNative(ee, args_new, ttt);
							} else {
								WasmCall(ee, args_new, ttt);
							}
						}
					}

				}
				default: {
					WasmCall(do_exp(f), map(args, \a -> do_exp(a)), do_type(type));
				}
			}
		}
		FiVar(name, type, __): {
			do_var(e, isnative, false);	// isnative needed here
		}
		FiLet(name, type, e1, e2, type2, __): {
			e1_conv = do_exp(e1);
			name2 = getWasmLocalVarName(name, do_type(type));
			t1_conv = lookupCachedVar(local, name2, fiTypeFromExp(e1_conv, local));
			e2_conv = do_exp(e2);
			t2_conv = do_type(type2);
			WasmLet(name, t1_conv, e1_conv, e2_conv, t2_conv)
		}
		FiIf(e1, e2, e3, type, __): 
			WasmIf(do_exp(e1), do_exp(e2), do_exp(e3), do_type(type));
		FiSwitch(x, switchType, cases, type, __): {
			cases2 = map(cases, \c -> WasmCase(c.struct, c.argNames, do_exp(c.body)));
			WasmSwitch(do_var(x, false, false), do_type(switchType), cases2, do_type(type))
		}
		FiCast(ex, tFrom, tTo, type, __): 
			WasmCast(do_exp(ex), do_type(tFrom), do_type(tTo), do_type(type));
		FiSeq(es, type, __): 
			WasmSeq(map(es, \stmt -> do_exp(stmt)), do_type(type));
		FiCallPrim(op, es, type, __): 
			WasmCallPrim(op, map(es, \stmt -> do_exp(stmt)), do_type(type));
		FiVoid(start): WasmVoid();
		FiDouble(d, __): WasmDouble(d);
		FiInt(i, __): WasmInt(i);
		FiString(s, __): WasmString(s);
		FiBool(b, __): WasmBool(b);
		FiRequire(flowfile, ex, type, __): 
			WasmRequire(flowfile, do_exp(ex), do_type(type)); 
		FiUnsafe(name, fallback, type, __): 
			WasmUnsafe(name, do_exp(fallback), do_type(type));
	}
}

fiexp2wasmexp(context : WasmContext, names : FiGlobalNames, e : FiExp) {
	dofiexp2wasmexp(context, names, e, ref makeTree(), false);
}

wasmExpType(e : WasmExp) -> WasmTypeDescriptor {
	switch (e) {
		WasmLambda(__, __, type) : type;
		WasmCall(__, __, type) : type;
		WasmCallNative(__, __, type) : type;
		WasmCallHost(__, __, type) : type;
		WasmVar(__, type) : type;
		WasmLet(__, __, __, __, type2) : type2;
		WasmIf(__, __, __, type) : type;
		WasmSwitch(__, __, __, type) : type;
		WasmCast(__, __, __, type) : type;
		WasmSeq(__, type) : type;
		WasmCallPrim(__, __, type) : type;
		WasmRequire(__, __, type) : type;
		WasmUnsafe(__, __, type) : type;
		WasmVoid() : WasmTypeVoid();
		WasmDouble(__) : WasmTypeDouble();
		WasmInt(__) : WasmTypeInt();
		WasmString(__) : WasmTypeString();
		WasmBool(__) : WasmTypeBool();
	}
}

wasmUnifyType(type : WasmTypeDescriptor) -> WasmTypeDescriptor {
	rec = \t -> wasmUnifyType(t);
	func = \args, rt -> {
		args2 = filtermapi(args, \i, a -> {
			if ((i+1 < length(args)) || !strContains(a.name, "__closure__")) {
				Some(WasmFunArg("", rec(a.type)))
			} else None();
		});
		WasmTypeFunction(args2, rec(rt))
	}
	switch (type) {
		WasmTypeVoid(): type;
		WasmTypeBool(): type;
		WasmTypeInt(): type;
		WasmTypeDouble(): type;
		WasmTypeString(): type;
		WasmTypeFlow(): type;
		WasmTypeArray(t): WasmTypeArray(rec(t));
		WasmTypeRef(t): WasmTypeRef(rec(t));
		WasmTypeNative(): type;
		WasmTypeStruct(name, fields): WasmTypeStruct(name, map(fields, \f -> WasmStructField(f.name, rec(f.type))));
		WasmTypeUnion(name, structs): type;
		WasmTypeFunction(args, returnType): func(args, returnType);
		WasmTypeJSCallback(args, returnType): func(args, returnType);
	}
}
