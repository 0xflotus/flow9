import tools/flowc/backends/wasm/wasm_type;
import tools/flowc/fcexp;

export {
	// This mirrors FiExp with some extensions
	WasmExp ::= WasmLambda, WasmCall, WasmCallNative, WasmCallHost, WasmVar, WasmLet, WasmIf, WasmSwitch, WasmCast, WasmSeq, 
			  WasmCallPrim, WasmConst, WasmRequire, WasmUnsafe;
		WasmLambda(args: [WasmFunArg], body: WasmExp, type : WasmTypeDescriptor);
		WasmCall(f: WasmExp, args: [WasmExp], type : WasmTypeDescriptor);
		WasmCallNative(f: WasmExp, args: [WasmExp], type : WasmTypeDescriptor);
		WasmCallHost(f: WasmExp, args: [WasmExp], type : WasmTypeDescriptor);
		WasmVar(name: string, type : WasmTypeDescriptor);
		WasmLet(name: string, type : WasmTypeDescriptor, e1: WasmExp, e2: WasmExp, type2 : WasmTypeDescriptor);
		WasmIf(e1: WasmExp, e2: WasmExp, e3: WasmExp, type : WasmTypeDescriptor);
		WasmSwitch(x: WasmVar, switchType : WasmTypeDescriptor, cases: [WasmCase], type : WasmTypeDescriptor);
			// struct is "default" for default case
			WasmCase(struct: string, argNames : [string], body: WasmExp);
		WasmCast(e: WasmExp, tFrom : WasmTypeDescriptor, tTo : WasmTypeDescriptor, type : WasmTypeDescriptor);
		WasmSeq(es: [WasmExp], type : WasmTypeDescriptor);
		WasmCallPrim(op: FcPrim, es: [WasmExp], type : WasmTypeDescriptor);
		WasmRequire(flowWasmle : string, e : WasmExp, type : WasmTypeDescriptor);
		WasmUnsafe(name : string, fallback : WasmExp, type : WasmTypeDescriptor);

	WasmConst ::= WasmVoid, WasmDouble, WasmInt, WasmString, WasmBool;
		WasmVoid();
		WasmDouble(d : double);
		WasmInt(i : int);
		WasmString(s : string);
		WasmBool(b: bool);
}
