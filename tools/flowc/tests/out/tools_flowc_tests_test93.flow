Tree<?, ??> ::= TreeNode<?, ??>, TreeEmpty;
	TreeNode : (key : ?, value : ??, left : Tree<?, ??>, right : Tree<?, ??>, depth : int);
	TreeEmpty : ();

foldTree_deferred(tree : Tree<?, ??>, fn : (?, ??, ???) -> ???) -> void {
	foldedTree : [TreeNode<?, ??>] = [];
	fold_deferred(
		foldedTree, 
		\acc, node -> {
			if (node.depth <= 3)
				foldTree(node, acc, fn)
			else
				fn(node.key, node.value, acc)
		}
	)
}

fold_deferred(a : [?], fn : (acc : ??, x : ?) -> ??) -> void {

}

foldTree(tree: Tree<?, ??>,
				acc: ???,
				f: (key: ?, value: ??, acc: ???) -> ???
				) -> ??? {
	acc
}

----------

foldTree = (\tree:Tree<?, ??>, acc:???, f:(key : ?, value : ??, acc : ???) -> ??? ->
	(acc : ???)
 : (tree : Tree<?, ??>, acc : ???, f : (key : ?, value : ??, acc : ???) -> ???) -> ???);

fold_deferred = (\a:[?], fn:(acc : ??, x : ?) -> ?? ->
	({} : void)
 : (a : [?], fn : (acc : ??, x : ?) -> ??) -> void);

foldTree_deferred = (\tree:Tree<?, ??>, fn:(?, ??, ???) -> ??? ->
	(foldedTree : [TreeNode<?, ??>] = ([] : [TreeNode<?, ??>]);
	({
		((fold_deferred : (a : [TreeNode<?, ??>], fn : (acc : ???, x : TreeNode<?, ??>) -> ???) -> void)((foldedTree : [TreeNode<?, ??>]), (\acc:???, node:TreeNode<?, ??> ->
			(if (((((node : TreeNode<?, ??>).depth : int) <= (3 : int)) : bool)) {
				((foldTree : (tree : Tree<?, ??>, acc : ???, f : (key : ?, value : ??, acc : ???) -> ???) -> ???)((node : TreeNode<?, ??>), (acc : ???), (fn : (?, ??, ???) -> ???)) : ???)
			} else {
				((fn : (?, ??, ???) -> ???)(((node : TreeNode<?, ??>).key : ?), ((node : TreeNode<?, ??>).value : ??), (acc : ???)) : ???)
			}
			 : ???)
		 : (acc : ???, node : TreeNode<?, ??>) -> ???)) : void)
	}
	 : void) : void)
 : (tree : Tree<?, ??>, fn : (?, ??, ???) -> ???) -> void);
