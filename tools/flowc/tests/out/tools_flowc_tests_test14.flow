import array;

for(init, predicate, f) {
	if (predicate(init)) for(f(init), predicate, f) else init
}

native strlen : (string) -> int = Native.strlen;
native strIndexOf : (string, string) -> int = Native.strIndexOf;
native substring : (s : string, start : int, length : int) -> string = Native.substring;

strsubsmart(s : string, start : int, len : int) -> string {
	if (start >= 0 && len > 0) {
		substring(s, start, len)
	} else {
		slen = strlen(s);
		trueStart = if (start >= 0) start else { ss = slen + start; if (ss >= 0) ss else 0; };
		trueLength = if (len > 0) len else slen + len - trueStart;

		substring(s, trueStart, trueLength)
	}
}

// Implemented natively by targets where substring actually copies characters & cpp
native strRangeIndexOf : (string, string, int, int) -> int = Native.strRangeIndexOf;

strRangeIndexOf(str, substr, start, end) {
	rv = strIndexOf(substring(str, start, end-start), substr);
	if (rv < 0) rv else start+rv;
}


countUntil(start, maxcount, predicate) {
	if (start >= maxcount) maxcount
	else if (predicate(start)) start
	else countUntil(start + 1, maxcount, predicate);
}

strLastIndexOf(s, p) {
	i = strIndexOf(s, p);
	if (i == -1) {
		-1;
	} else {
		l = strlen(s);
		pl = strlen(p);
		if (pl == 0) {
			0;
		} else {
			// TODO: We could skip until i and call ourselves recursively
			f = countUntil(0, l - pl + 1, \i2 -> {
				substring(s, l - pl - i2, pl) == p;
			});
			l - pl - f;
		}
	}
}

strReplaceCustomRec(prefix, suffix, old, new, charBeforeFn, charAfterFn) {
	if (old == "") {
		prefix + suffix
	} else {
		// assuming prefix is part with replacement done
		i = strIndexOf(suffix, old);
		if (i >= 0) {
			oldLen = strlen(old);
			getCharBefore = \ -> {
				if (i == 0) strsubsmart(prefix, -1, 0)
				else substring(suffix, i-1, 1);
			}

			isCharBeforeGood = \ -> eitherMap(charBeforeFn, \fn -> fn(getCharBefore()), true);
			ischarAfterGood = \ ->  eitherMap(charAfterFn, \fn -> fn(substring(suffix, i + oldLen, 1)), true);

			l = strlen(suffix);
			if (isCharBeforeGood() && ischarAfterGood()) {
				// do replace and continue search
				strReplaceCustomRec(prefix + substring(suffix, 0, i) + new, substring(suffix, i + oldLen, l - i - oldLen), old, new, charBeforeFn, charAfterFn);
			} else {
				// continue search
				if (i + 1 < l)
					strReplaceCustomRec(prefix + substring(suffix, 0, i + 1), substring(suffix, i + 1, l - (i + 1)), old, new, charBeforeFn, charAfterFn)
				else
					prefix + suffix  // end of string reached, stopping
			}
		} else {
			prefix + suffix // no more matches, stopping
		}
	}
}

----------

countUntil = (\start:int, maxcount:int, predicate:(int) -> bool ->
	(if ((((start : int) >= (maxcount : int)) : bool)) {
		(maxcount : int)
	} else {
		(if (((predicate : (int) -> bool)((start : int)) : bool)) {
			(start : int)
		} else {
			((countUntil : (start : int, maxcount : int, predicate : (int) -> bool) -> int)((((start : int) + (1 : int)) : int), (maxcount : int), (predicate : (int) -> bool)) : int)
		}
		 : int)
	}
	 : int)
 : (start : int, maxcount : int, predicate : (int) -> bool) -> int);

for = (\init:?, predicate:(?) -> bool, f:(?) -> ? ->
	(if (((predicate : (?) -> bool)((init : ?)) : bool)) {
		((for : (init : ?, predicate : (?) -> bool, f : (?) -> ?) -> ?)(((f : (?) -> ?)((init : ?)) : ?), (predicate : (?) -> bool), (f : (?) -> ?)) : ?)
	} else {
		(init : ?)
	}
	 : ?)
 : (init : ?, predicate : (?) -> bool, f : (?) -> ?) -> ?);

strRangeIndexOf = (\str:string, substr:string, start:int, end:int ->
	(rv : int = ((strIndexOf : (string, string) -> int)(((substring : (s : string, start : int, length : int) -> string)((str : string), (start : int), (((end : int) - (start : int)) : int)) : string), (substr : string)) : int);
	({
		(if ((((rv : int) < (0 : int)) : bool)) {
			(rv : int)
		} else {
			(((start : int) + (rv : int)) : int)
		}
		 : int)
	}
	 : int) : int)
 : (str : string, substr : string, start : int, end : int) -> int);

strsubsmart = (\s:string, start:int, len:int ->
	(if ((((((start : int) >= (0 : int)) : bool) && (((len : int) > (0 : int)) : bool)) : bool)) {
		((substring : (s : string, start : int, length : int) -> string)((s : string), (start : int), (len : int)) : string)
	} else {
		(slen : int = ((strlen : (string) -> int)((s : string)) : int);
		({
			(trueStart : int = (if ((((start : int) >= (0 : int)) : bool)) {
				(start : int)
			} else {
				(ss : int = (((slen : int) + (start : int)) : int);
				({
					(if ((((ss : int) >= (0 : int)) : bool)) {
						(ss : int)
					} else {
						(0 : int)
					}
					 : int)
				}
				 : int) : int)
			}
			 : int);
			({
				(trueLength : int = (if ((((len : int) > (0 : int)) : bool)) {
					(len : int)
				} else {
					(((((slen : int) + (len : int)) : int) - (trueStart : int)) : int)
				}
				 : int);
				({
					((substring : (s : string, start : int, length : int) -> string)((s : string), (trueStart : int), (trueLength : int)) : string)
				}
				 : string) : string)
			}
			 : string) : string)
		}
		 : string) : string)
	}
	 : string)
 : (s : string, start : int, len : int) -> string);

strLastIndexOf = (\s:string, p:string ->
	(i : int = ((strIndexOf : (string, string) -> int)((s : string), (p : string)) : int);
	({
		(if ((((i : int) == (-1 : int)) : bool)) {
			(-1 : int)
		} else {
			(l : int = ((strlen : (string) -> int)((s : string)) : int);
			({
				(pl : int = ((strlen : (string) -> int)((p : string)) : int);
				({
					(if ((((pl : int) == (0 : int)) : bool)) {
						(0 : int)
					} else {
						(f : int = ((countUntil : (start : int, maxcount : int, predicate : (int) -> bool) -> int)((0 : int), (((((l : int) - (pl : int)) : int) + (1 : int)) : int), (\i2:int ->
							((((substring : (s : string, start : int, length : int) -> string)((s : string), (((((l : int) - (pl : int)) : int) - (i2 : int)) : int), (pl : int)) : string) == (p : string)) : bool)
						 : (i2 : int) -> bool)) : int);
						({
							(((((l : int) - (pl : int)) : int) - (f : int)) : int)
						}
						 : int) : int)
					}
					 : int)
				}
				 : int) : int)
			}
			 : int) : int)
		}
		 : int)
	}
	 : int) : int)
 : (s : string, p : string) -> int);

strReplaceCustomRec = (\prefix:string, suffix:string, old:string, new:string, charBeforeFn:Maybe<(string) -> bool>, charAfterFn:Maybe<(string) -> bool> ->
	(if ((((old : string) == ("" : string)) : bool)) {
		(((prefix : string) + (suffix : string)) : string)
	} else {
		(i : int = ((strIndexOf : (string, string) -> int)((suffix : string), (old : string)) : int);
		({
			(if ((((i : int) >= (0 : int)) : bool)) {
				(oldLen : int = ((strlen : (string) -> int)((old : string)) : int);
				({
					(getCharBefore : () -> string = (\ ->
						(if ((((i : int) == (0 : int)) : bool)) {
							((strsubsmart : (s : string, start : int, len : int) -> string)((prefix : string), (-1 : int), (0 : int)) : string)
						} else {
							((substring : (s : string, start : int, length : int) -> string)((suffix : string), (((i : int) - (1 : int)) : int), (1 : int)) : string)
						}
						 : string)
					 : () -> string);
					({
						(isCharBeforeGood : () -> bool = (\ ->
							((eitherMap : (m : Maybe<(string) -> bool>, fn : ((string) -> bool) -> bool, alternative : bool) -> bool)((charBeforeFn : Maybe<(string) -> bool>), (\fn:(string) -> bool ->
								((fn : (string) -> bool)(((getCharBefore : () -> string)() : string)) : bool)
							 : (fn : (string) -> bool) -> bool), (true : bool)) : bool)
						 : () -> bool);
						({
							(ischarAfterGood : () -> bool = (\ ->
								((eitherMap : (m : Maybe<(string) -> bool>, fn : ((string) -> bool) -> bool, alternative : bool) -> bool)((charAfterFn : Maybe<(string) -> bool>), (\fn:(string) -> bool ->
									((fn : (string) -> bool)(((substring : (s : string, start : int, length : int) -> string)((suffix : string), (((i : int) + (oldLen : int)) : int), (1 : int)) : string)) : bool)
								 : (fn : (string) -> bool) -> bool), (true : bool)) : bool)
							 : () -> bool);
							({
								(l : int = ((strlen : (string) -> int)((suffix : string)) : int);
								({
									(if (((((isCharBeforeGood : () -> bool)() : bool) && ((ischarAfterGood : () -> bool)() : bool)) : bool)) {
										((strReplaceCustomRec : (prefix : string, suffix : string, old : string, new : string, charBeforeFn : Maybe<(string) -> bool>, charAfterFn : Maybe<(string) -> bool>) -> string)((((((prefix : string) + ((substring : (s : string, start : int, length : int) -> string)((suffix : string), (0 : int), (i : int)) : string)) : string) + (new : string)) : string), ((substring : (s : string, start : int, length : int) -> string)((suffix : string), (((i : int) + (oldLen : int)) : int), (((((l : int) - (i : int)) : int) - (oldLen : int)) : int)) : string), (old : string), (new : string), (charBeforeFn : Maybe<(string) -> bool>), (charAfterFn : Maybe<(string) -> bool>)) : string)
									} else {
										(if ((((((i : int) + (1 : int)) : int) < (l : int)) : bool)) {
											((strReplaceCustomRec : (prefix : string, suffix : string, old : string, new : string, charBeforeFn : Maybe<(string) -> bool>, charAfterFn : Maybe<(string) -> bool>) -> string)((((prefix : string) + ((substring : (s : string, start : int, length : int) -> string)((suffix : string), (0 : int), (((i : int) + (1 : int)) : int)) : string)) : string), ((substring : (s : string, start : int, length : int) -> string)((suffix : string), (((i : int) + (1 : int)) : int), (((l : int) - (((i : int) + (1 : int)) : int)) : int)) : string), (old : string), (new : string), (charBeforeFn : Maybe<(string) -> bool>), (charAfterFn : Maybe<(string) -> bool>)) : string)
										} else {
											(((prefix : string) + (suffix : string)) : string)
										}
										 : string)
									}
									 : string)
								}
								 : string) : string)
							}
							 : string) : string)
						}
						 : string) : string)
					}
					 : string) : string)
				}
				 : string) : string)
			} else {
				(((prefix : string) + (suffix : string)) : string)
			}
			 : string)
		}
		 : string) : string)
	}
	 : string)
 : (prefix : string, suffix : string, old : string, new : string, charBeforeFn : Maybe<(string) -> bool>, charAfterFn : Maybe<(string) -> bool>) -> string);
