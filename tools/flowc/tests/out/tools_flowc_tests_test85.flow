native fold : (xs : [?], init : ??, fn : (??, ?)->??) -> ?? = Native.fold;

Maybe<?> ::= None, Some<?>;
	None();
	Some(value : ?);

FcExp ::= FcLambda, FcVar;
	FcLambda(body: FcExp);
	FcVar(name: string);

FcFunctionDec(
	name: string,
	lambda: Maybe<FcLambda>,
);

either(m: Maybe<?>, alternative: ?) -> ? {
	switch (m : Maybe) {
		None(): alternative;
		Some(v): v;
	}
}

countProgramVars(mo, v : FcExp) -> void {
	fold(mo, v, \acc2, fun -> {
		either(fun.lambda, v);
	});
	{}
}

----------

either = (\m:Maybe<?>, alternative:? ->
	(switch (m : Maybe<?>) {
		None(): {
			(alternative : ?)
		}
		Some(v): {
			(v : ? = ((m : Some<?>).value : ?);
			(v : ?) : ?)
		}
	} : ?)
 : (m : Maybe<?>, alternative : ?) -> ?);

countProgramVars = (\mo:[FcFunctionDec], v:FcExp ->
	({
		((fold : (xs : [FcFunctionDec], init : FcExp, fn : (FcExp, FcFunctionDec) -> FcExp) -> FcExp)((mo : [FcFunctionDec]), (v : FcExp), (\acc2:FcExp, fun:FcFunctionDec ->
			((either : (m : Maybe<FcLambda>, alternative : FcLambda) -> FcLambda)(((fun : FcFunctionDec).lambda : Maybe<FcLambda>), (v : FcExp)) : FcLambda)
		 : (acc2 : FcExp, fun : FcFunctionDec) -> FcLambda)) : FcExp);
		({} : void)
	}
	 : void)
 : (mo : [FcFunctionDec], v : FcExp) -> void);
