Tree<?, ??> ::= TreeNode<?, ??>, TreeEmpty;
	TreeNode : (key : ?, value : ??);
	TreeEmpty : ();

Set : (tree : Tree<?, bool>);

Label();

makeTree() -> Tree<?, ??> {
	TreeEmpty();
}

makeSet() -> Set<?> {
	Set(makeTree())
}

foldSet(init : ??, fn : (??, ?) -> ??) -> ?? {
	init;
}

id(acc: ???) -> ??? {
	acc;
}

// Does the partition, and returns the final partition
doHopcroft() -> void {
	// Nodes that transitions into any element of A
	XT : Set<int> = id(makeSet());

	// Partitions over X
	XG = foldSet(makeTree(), \acc : Tree<Label, [int]>, xt -> {
		acc;
	});
}

----------

foldSet = (\init:??, fn:(??, ?) -> ?? ->
	(init : ??)
 : (init : ??, fn : (??, ?) -> ??) -> ??);

id = (\acc:??? ->
	(acc : ???)
 : (acc : ???) -> ???);

makeTree = (\ ->
	(TreeEmpty() : TreeEmpty<?, ??>)
 : () -> TreeEmpty<?, ??>);

makeSet = (\ ->
	(Set(((makeTree : () -> Tree<?, bool>)() : Tree<?, bool>)) : Set<?>)
 : () -> Set<?>);

doHopcroft = (\ ->
	(XT : Set<int> = ((id : (acc : Set<int>) -> Set<int>)(((makeSet : () -> Set<int>)() : Set<int>)) : Set<int>);
	({
		(XG : Tree<Label, [int]> = ((foldSet : (init : Tree<Label, [int]>, fn : (Tree<Label, [int]>, ?) -> Tree<Label, [int]>) -> Tree<Label, [int]>)(((makeTree : () -> Tree<Label, [int]>)() : Tree<Label, [int]>), (\acc:Tree<Label, [int]>, xt:? ->
			(acc : Tree<Label, [int]>)
		 : (acc : Tree<Label, [int]>, xt : ?) -> Tree<Label, [int]>)) : Tree<Label, [int]>);
		({

		}
		 : void) : void)
	}
	 : void) : void)
 : () -> void);
