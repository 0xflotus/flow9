import tools/flowc/incremental/fitype;
import tools/flowc/backends/common;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/manipulation/lambda_lifting;
import tools/flowc/manipulation/explicit_casts;

export {
	// this is a general cast-processing pass that does the following:
    // 1. expand implicit casts to and from flow (see explicit_casts)
    // 2. expand type-erasing casts ? -> flow -> ?? to something more manageable whenever possible
	expandCasts(prg : FiProgram) -> FiProgram;
}

optimizeTypeErasure(ex : FiExp) {
	switch (ex) {
		FiBool(b, start): ex;
		FiInt(i, start): ex;
		FiString(s, start): ex;
		FiDouble(d, start): ex;
		FiVoid(start): ex;
		FiVar(name, type, start): ex;
		FiCall(f, args, type, start): ex;
		FiSwitch(__, __, __, __, __): ex;
		FiLambda(args, body, type, start): ex;
		FiLet(name, type, e1, e2, type2, start):  ex;
		FiIf(e1, e2, e3, type, start): ex;
		FiCallPrim(__, es, __, __): ex;
		FiRequire(flowfile, e, type, start): ex;
		FiUnsafe(name, fallback, type, start): ex;
		FiSeq(es, type, start): ex;
		FiCast(__, __, __, __, __): ex;
	}
}

expandCasts(prg : FiProgram) {
	fold(prg.traversal, prg, \program, moduleName -> {
		switch (lookupTree(program.modules, moduleName)) {
			None(): program;
			Some(m): {

				functions0 = map(m.functions, \f : FiFunctionDec -> {
					FiFunctionDec(f with lambda = 
                        FiLambda(f.lambda with body = optimizeTypeErasure(expandFlowCastsExp(f.lambda.body))))
				});

				globalVars = map(m.globalVars, \v -> FiGlobalVar(v with value = 
                    optimizeTypeErasure(injectFlowCast(v.type, v.value))));
					
				natives = map(m.natives, \n -> {
					switch (n.fallbackLambda) {
						FiLambda(args, body, type, start): {
							wrapped = optimizeTypeErasure(expandFlowCastsExp(body));
							if (wrapped != body) {
								FiNativeDec(n with fallbackLambda = FiLambda(args, wrapped, type, start))
							} else n;
						}
						default: n;
					}
				});

				module = FiModule(m with
					functions = functions0,
					globalVars = globalVars,
					natives = natives,
				);

				FiProgram(program with modules = setTree(program.modules, moduleName, module));
			}
		};
	});
}

