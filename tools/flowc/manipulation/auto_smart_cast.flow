import tools/flowc/incremental/fitype;
import tools/flowc/backends/common;
import tools/flowc/incremental/fi_helpers;
import tools/flowc/manipulation/lambda_lifting;

export {
	// This function will wrap ... with lambdas
	fiSmartCast(prg : FiProgram) -> FiProgram;
}

doSmartCast(ex : FiExp) {
	switch (ex) {
		FiBool(b, start): ex;
		FiInt(i, start): ex;
		FiString(s, start): ex;
		FiDouble(d, start): ex;
		FiVoid(start): ex;
		FiVar(name, type, start): ex;
		FiCall(f, args, type, start): ex;
		FiSwitch(__, __, __, __, __): ex;
		FiLambda(args, body, type, start): ex;
		FiLet(name, type, e1, e2, type2, start):  ex;
		FiIf(e1, e2, e3, type, start): ex;
		FiCallPrim(__, es, __, __): ex;
		FiRequire(flowfile, e, type, start): ex;
		FiUnsafe(name, fallback, type, start): ex;
		FiSeq(es, type, start): ex;
		FiCast(__, __, __, __, __): ex;
	}
}

fiSmartCast(prg : FiProgram) {
	fold(prg.traversal, prg, \program, moduleName -> {
		switch (lookupTree(program.modules, moduleName)) {
			None(): program;
			Some(m): {
				doCast = \expr -> doSmartCast(expr);

				functions0 = map(m.functions, \f : FiFunctionDec -> {
					FiFunctionDec(f with lambda = FiLambda(f.lambda with body = doCast(f.lambda.body)))
				});

				globalVars = map(m.globalVars, \v -> FiGlobalVar(v with value = doCast(v.value)));
					
				natives = map(m.natives, \n -> {
					switch (n.fallbackLambda) {
						FiLambda(args, body, type, start): {
							wrapped = doCast(body);
							if (wrapped != body) {
								FiNativeDec(n with fallbackLambda = FiLambda(args, wrapped, type, start))
							} else n;
						}
						default: n;
					}
				});

				module = FiModule(m with
					functions = functions0,
					globalVars = globalVars,
					natives = natives,
				);

				prgTmp = FiProgram(program with modules = setTree(program.modules, moduleName, module));

				lift_lambdas_module(prgTmp, moduleName);
			}
		};
	});
}

