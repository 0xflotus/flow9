<link rel="stylesheet" type="text/css" media="screen" href="style.css?v1" />
<h1><em>flow</em> runtimes</h1>

<p>There are many different ways of executing <em>flow</em> code. This document attempts to document them all.</p>

<p>Targets identified as "production" are, of course, the most critical.</p>

<h2>haXe based runtimes</h2>

<table>
    <tr>
        <th>Target platform</th>
        <th>Rendering target</th>
        <th>Main implementation file</th>
        <th>How to run</th>
        <th>Program representation</th>
        <th>Runtime value representation</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td>JavaScript</td>
        <td>HTML5 via RenderSupportJsPixiHx.hx</td>
        <td>(JsWriter.hx)</td>
        <td>program.js, made using neko flow.n --js program.js program.flow</td>
        <td>Compiles to Javascript.</td>
        <td>Native JavaScript values.</td>
        <td>Our production target for HTML5. Consider to optimise further using Google closure compiler:<br/>
java -jar compiler.jar --compilation_level ADVANCED_OPTIMIZATIONS --js test.js --js_output_file testopt.js
        </td>
    </tr>
</table>

<h2>C++ based runtimes</h2>

<table>
    <tr>
        <th>Target platform</th>
        <th>Rendering target</th>
        <th>Main implementation file</th>
        <th>Program representation</th>
        <th>Runtime value representation</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td>Windows, Mac OS X, Linux</td>
        <td>Qt with OpenGL</td>
        <td>QtByterunner/core/ByteCodeRunner.cpp</td>
        <td>flow bytecode. See bytecode.hx</td>
        <td>Bytememory, 12 bytes per value</td>
        <td>Useful for development, not for end users</td>
    </tr>
    <tr>
        <td>Android</td>
        <td>Android native API with OpenGL ES</td>
        <td>QtByterunner/core/ByteCodeRunner.cpp</td>
        <td>flow bytecode. See bytecode.hx</td>
        <td>Bytememory, 12 bytes per value</td>
        <td>Production use</td>
    </tr>
    <tr>
        <td>iOS</td>
        <td>iOS native API with OpenGL ES</td>
        <td>QtByterunner/core/ByteCodeRunner.cpp</td>
        <td>flow bytecode. See bytecode.hx</td>
        <td>Bytememory, 12 bytes per value</td>
        <td>Production use</td>
    </tr>
    <tr>
        <td>Windows, Mac, Linux, Android, iOS</td>
        <td></td>
        <td>(Bytecode2cpp.hx)</td>
        <td>C++, made using neko flow.n --cpp outputdir program.flow</td>
        <td>Bytememory, 12 bytes per value</td>
        <td>Generates big C++ files that take long time to compile, but the fastest target. In production server-side</td>
    </tr>
</table>

<h2>Java based runtime</h2>

<p>This is a relatively fast target. For computational stuff, it can be 14 times faster than the C++ bytecode target.</p>

<table>
    <tr>
        <th>Target platform</th>
        <th>Rendering target</th>
        <th>Main implementation file</th>
        <th>Program representation</th>
        <th>Runtime value representation</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td>Windows, Mac OS X, Linux</td>
        <td>JavaFX</td>
        <td>src/java/?</td>
        <td>Java</td>
        <td>Java</td>
        <td>Production for command line</td>
    </tr>
</table>

<p>Get the Java SDK. Be sure to have version 8 or later in 64-bit version:</p>

<pre><code>http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
</code></pre>

<p>Test with something like</p>

<pre><code>flowjava sandbox/fun.flow
</code></pre>

<p>or on Linux and Mac,</p>

<pre><code>flowjava.sh sandbox/fun.flow
</code></pre>

<h2>C# based runtime</h2>

<table>
    <tr>
        <th>Target platform</th>
        <th>Rendering target</th>
        <th>Main implementation file</th>
        <th>Program representation</th>
        <th>Runtime value representation</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td>Windows 10/8.1/8.0</td>
        <td>XAML</td>
        <td>src/csharp/?</td>
        <td>C#</td>
        <td>C#</td>
        <td>Experimental</td>
    </tr>
</table>

<p>Get Visual Studio Express with C#, and download the Windows SDK for Windows 8.1.</p>

<p>Compile using</p>

<pre><code>flow --csharp src/csharp/flowgen sandbox/helloworld.flow
</code></pre>

<p>and then open the flow\src\csharp\WindowsApp\WindowsApp.sln solution file in Visual Studio and
compile and run. In the solution there are separate projects for Universal Windows (Windows 10) 
and Windows 8.1.</p>

<h2>Compiling to C++</h2>

<p><code>flow --cpp</code> compiles the bytecode to inlined C++ for additional performance benefits.</p>

<p>The problem with this work is that the gcc compiler has a hard time compiling the resulting C++ files.
As a result, compile times are very long.
To reduce this problem, you can try to do a profile-guided compilation instead. To do this, first collect a
representative timing profile using the instructions above - typically, the --profile-bytecode option
works best.</p>

<p>Next, construct a static profile of the top-100 functions in your program using the flowprof-selfrating
script:</p>

<pre><code>flowprof-rating flowprof.ins foo.debug &gt;top.txt
</code></pre>

<p>Next, recompile your program like this:</p>

<pre><code>flow --cpp foo --profile top.txt foo.flow
</code></pre>

<p>Here, <code>foo</code> is the name of a directory where the generated <code>.cpp</code> and <code>.h</code> files
will be stored.</p>

<p>As the third step, then add a</p>

<pre><code>DEFINES += COMPILED
</code></pre>

<p>configuration item in the QtByteRunner.pro file. Also, be sure to add the files in the <code>foo</code> directory
under <code>SOURCES</code>.</p>

<p>Currently, the profile information is happily ignored when generating the C++, so you might want to add</p>

<pre><code>QMAKE_CXXFLAGS_RELEASE += -O1 -g
QMAKE_LFLAGS_RELEASE += -g
</code></pre>

<p>to avoid using -O2 when compiling the resulting program, which most likely would blow up for any interesting
program.</p>

<p>Finally, rebuild all of the QtBytecodeRunner, and launch it with the bytecode as the argument
(since the program uses a mix of the bytecode and the compiled code).</p>

<h2>Rendering</h2>

<p>Rendering is triggered by a range of natives, most of them declared in <code>rendersupport.flow</code>.
These natives have been carefully designed to allow a relatively straight-forward implementation
in all our targets.</p>

<p>An especially important native is <code>RealHTML</code>, which handles embedded HTML. RealHTML is 
implemented by communicating with the hosting HTML page, which will construct an iframe.</p>

<p>Rendering in JS is done using PixiJs in a <code>&lt;canvas&gt;</code> .</p>

<p>Rendering in Android and iOS targets is done from C++ using OpenGL ES. RealHTML is done
with an embedded web browser.</p>

<p>Rendering in Windows, Linux, Mac targets is done from C++ using Qt OpenGL. RealHTML is done
with an embedded Qt WebKit browser.</p>

<h2>Running with NWJS.io</h2>

<p>You can compile flow code to Javascript and run it with NWJS.io</p>

<p>1) Download NWJS:</p>

<p>Get the SDK version of NWJS from</p>

<p>http://nwjs.io/downloads </p>

<p>and extract it somewhere.</p>

<p>2) Install bindings to nodej for haxe</p>

<pre><code>haxelib install hxnodejs
</code></pre>

<p>3) Compile your program:</p>

<pre><code>flowc1 sandbox/fun.flow es6=fun.js nwjs=1
</code></pre>

<p>4) Create file <code>package.json</code> in flow repo with content:</p>

<p>{
  "name": "nw",
  "main": "www/flownw.html?name=fun"
}</p>

<p>5) At flow folder run:</p>

<p>(Windows)
c:\path\to\nw . fun</p>

<p>(MacOS X)
nwjs/nwjs.app/Contents/MacOS/nw . fun</p>

<p>You can call developer console of NWJS for debugging purpose, press F12 on Windows and 
Cmd+Alt+I on MacOS X.</p>
