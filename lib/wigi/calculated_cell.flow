import arrayutils; // subtractA
import movable2; // makeWindowXY

import tropic/ttextinput;
import tropic/tropic2form;
import ui/listbox;

import wigi/editor_types;
import wigi/table_selection;
import wigi/wigi_builtins;

import ui/messagebox;
import styleform;
import wigi/wigi_button_api;

import wigi/testcaserecorder_api;

export {
	// Shows dialog where user can enter calculated formula, see case http://process.area9.dk/cases/default.asp?34549
	showCalculatedCellDialog(state: WigiEditorState, formula: string, onOK: (string) -> void) -> void;

	getExcellFunctionList() -> [string];
}

showCalculatedCellDialog(state: WigiEditorState, initialFormula: string, onOK: (string) -> void) {
	if (getValue(state.editMode)) {
		doc = getValue(state.document);

		editableFormula = make(initialFormula);
		cursorPos = getValue(state.cursor);

		// We should clear the selection and then when it starts, we'll start inserting range in the formula
		nextDistinct(state.selection, wigiClearSelection(doc));
		nextDistinct(state.selectionAnchor, None());

		// Where in editable formula the dynamic selection range is, for example:
		// formula: "=SUM(A1:B2)", start would be 5, end would be 10
		startRangePosition = ref -1;
		endRangePosition = ref -1;

		disposers = ref [];

		currentRangeStr = selectu(state.selection, \selection -> {
			switch (getRectangularSelection(selection, doc, true)) {
				Some(rectSelection): {
					// We've got some selection
					rectSelection.rangeStr
				}
				None(): {
					// We have no selection
					""
				}
			}
		});
		refArrayPush(disposers, currentRangeStr.second);

		settingFormulaNow = ref false;

		refArrayPush(disposers, subscribe2(state.selection, \selection -> {
			switch (getRectangularSelection(selection, doc, true)) {
				Some(rectSelection): {
					// We've got some selection
					curFormula = getValue(editableFormula);

					if (^startRangePosition < 0 || ^startRangePosition >= strlen(curFormula)) {
						startRangePosition := strlen(curFormula);
						endRangePosition := ^startRangePosition;
					}

					newFormula = strLeft(curFormula, ^startRangePosition) + getValue(currentRangeStr.first) + strRight(curFormula, ^endRangePosition);
					endRangePosition := ^startRangePosition + strlen(getValue(currentRangeStr.first));

					settingFormulaNow := true;
					next(editableFormula, newFormula);
					settingFormulaNow := false;

					// Select document back
					updateKeyboardFocus(^(state.focusId));
				}
				None(): {
					// We have no selection
				}
			}
		}));

		// If formula gets manually edited, we should clear selection and reset this range feature
		refArrayPush(disposers, subscribe2(editableFormula, \formula -> {
			if (!^settingFormulaNow) {
				startRangePosition := -1;
				endRangePosition := -1;

				setWigiEditorSelection(state, wigiClearSelection(doc), false);
			}
		}));

		closeFn = ref nop;
		closeMe = \ -> {
			next(state.editMode, true);
			nextDistinct(state.cursor, cursorPos);
			^closeFn();
		}

		form = {
			helpText = "Examples of formulas for calculations:\n=2 * slider + 4\n=if checkbox1 then slider + 5 else slider - 5\n=if slider &lt; 5 then \"Small\" else if slider = 5 then \"Five\" else \"Big\"";
			helpListBoxText = "Functions are compatible\nwith Excel functions\nof the same name";

			okButton = callWigiButtonWithWidth(60.0, ^withTranslation("OK"), const(true), "Ctrl+Enter", \ -> {
				closeMe();
				onOK(getValue(editableFormula));
			});

			cancelButton = callWigiButtonWithWidth(60.0, ^withTranslation("Cancel"), const(true), "esc", \ -> {
				closeMe();
			});

			focusB = make(true);
			positionB = make(strlen(initialFormula));

			editor = tropic2form(TTextInput(editableFormula, [FontSize(14.0), Multiline(true), WordWrap(true)],
					[TTextInputFocus(focusB), TTextInputPosition(positionB)], TFixed(375.0, 207.0)), emptyStylesheet);

			fillListSelected = make(-1);
			arr = getExcellFunctionList();
			listBox = ListBox(map(arr, \txt -> Text(txt, [FontSize(12.0)])), [WidthHeight(117.0, 200.0), ResetChoice(true)], fillListSelected);

			selectedName = make(-1);
			selectedFormula = make(-1);
			wigiEnv = ^(state.engine.env);
			names = concat(
				wigiEnv.cellnames |> getTreeKeys |> filterNames,
				^(getGlobalWVEnvironment().doubles) |> getTreeKeys |> filterWikiNames
			) |> uniq;
			formulas = wigiEnv.cellformulas |> getTreeKeys |> filterFormulas;

			insertText = \text, shift -> {
				curPosition = getValue(positionB);
				curFormula = getValue(editableFormula);
				newFormula = strLeft(curFormula, curPosition) + text + strRight(curFormula, curPosition);
				next(editableFormula, newFormula);
				next(focusB, true);
				next(positionB, curPosition + shift);
			}

			refArrayPush(disposers, subscribe2(fillListSelected, \v -> if (v > -1) {
				funcName = arr[v];
				insertText(funcName + "()", strlen(funcName) + 1)
			}));
			refArrayPush(disposers, subscribe2(selectedName, \v -> if (v > -1) {
				name = names[v];
				insertText(name, strlen(name))
			}));
			refArrayPush(disposers, subscribe2(selectedFormula, \v -> if (v > -1) {
				formula = formulas[v];
				insertText(formula, strlen(formula))
			}));

			definedNamesAndFormulas = \ -> {
				makeListBox = \arr1, sel -> ListBox(
					map(arr1, \txt -> Text(txt, [])),
					[WidthHeight(117.0, 76.0), ResetChoice(true)], sel
				) |> localFrame;

				Lines([
					Text("Interactives", [FontSize(14.0)]),
					makeListBox(names, selectedName),
					Fixed(0.0, 7.0),
					Text("Calculated", [FontSize(14.0)]),
					makeListBox(formulas, selectedFormula)
				])
			}

			textElements = Cols([
				Lines([Fixed(0.0, 1.0), editor]),
				Fixed(4.0, 0.0),
				localFrame(listBox),
				Fixed(4.0, 0.0),
				definedNamesAndFormulas()
			]);

			content = Lines([
				Fixed(0.0, 4.0),
				textElements,
				Cols([Text(helpText, []), Fixed(90.0, 0.0), Text(helpListBoxText, [])]),
				Fixed(0.0, 4.0),
				Group([
					Align(1.0 / 6.0, 0.0, okButton),
					Align(5.0 / 6.0, 0.0, cancelButton)
				]),
				Fixed(0.0, 4.0)
			]) |> \f -> Constructor(f, \ -> \ -> applyall(^disposers));

			// We need to make the window non-transparent for clicks, etc.
			wh = makeWH();

			opaqueContent = Access([AccessRole("dialog")],
				Group([
					Select(wh, \_wh -> {
							Interactive([
								MouseDown2(\handled, gm -> gm.inside()),
								MouseMove2(\handled, gm -> gm().inside),
								MouseUp2(\handled, gm -> gm().inside)
							],
							Rectangle(_wh.width, _wh.height, [Fill(white)]))
						}
					),
					Inspect([ISize(wh)], content)
				])
			);

			Center(makeWindowXY(make(0.0), make(0.0), opaqueContent, "Enter calculated cell"));
		}

		// Switch to the selection mode
		next(state.editMode, false);

		// And show the whole thing
		closeFn := showModal(form);
	} else {
		// We show this dialog already, so just ignore
	}
}

getExcellFunctionList() -> [string] {
	subtractA(sort(getTreeKeys(getWigiBuiltIns())),
		["+","-","*","/","=","<>","!=","<=",">=",">","<","&","[","and","or","not"])
}

localFrame(f : Form) frameAround(Border(4.0, 4.0, 4.0, 4.0, f), 1.0, black);
getNames(arr : [WigiCellName]) map(arr, \e -> toLowerCase(e.name));

filterNamesStartsWith(a : [string], text : [string]) -> [string] {
	fold(text, a, \acc, item ->
		filter(acc, \e -> !startsWith(e, item))
	)
}

filterFormulas(arr : [WigiCellName]) -> [string] {
	if (isDevMode()) getNames(arr)
	else {
		arr
		|> \a1 : [WigiCellName] -> filter(a1, \e -> length(e.namespace.names) == 0 || (!startsWith(toLowerCase(e.namespace.names[0]), "sheet")))
		|> getNames
		|> \a2 -> filterNamesStartsWith(a2, ["choice", "feedback"])
	}
}

filterNames(arr : [WigiCellName]) -> [string] {
	res = getNames(arr);
	if (isDevMode()) res
	else {
		filterNamesStartsWith(res, ["__counting", "table"])
	}
}

filterWikiNames(arr : [string]) -> [string] {
	if (isDevMode()) arr
	else {
		arr
		|> \a1 : [string] -> map(a1, \e -> ltrim2(e, "$") |> toLowerCase)
		|> \a2 : [string] -> filterNamesStartsWith(a2, ["pi", "table", "overrideconditions", "scored"])
	}
}
