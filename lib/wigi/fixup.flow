import binarytreeutils;
import form;
import wigi/types;
import formats/json/json;

export {
	wigiFixup() -> Tree<string, (args : [flow]) -> flow>;
}

makeWigiFixup() -> Tree<string, (args : [flow]) -> flow> {
	tree : ref Tree<string, (args : [flow]) -> flow> = ref makeTree();

	/*---Fixups for structs which should contain double values, but comes with int instead,
		this is probably caused by wrong serialization.
		Those are known cases which could have such problem:
			WidthHeight(width : double, height : double);
			PictureWidthHeight(width : double, height : double);
			ImageCrop : (x : double, y : double, width : double, height : double);

			WigiTableColumnWidths(widths : [double]);
			WigiTableRowHeights(heights : [double]);
	*/
	argsToDoubles = \args_ -> {
		map(args_, number2double)
	};
	makeDoublesFixup = \structName : string -> {
		tree := setTree(^tree, structName, \_args -> {
			makeStructValue(structName, argsToDoubles(_args), IllegalStruct());
		});
	}
	structsForFixup = [
		"WidthHeight",
		"PictureWidthHeight",
		"ImageCrop"
	];

	iter(structsForFixup, makeDoublesFixup);

	argsToDoublesInArray = \structName -> {
		tree := setTree(^tree, structName, \args0 -> {
			makeStructValue(
				structName,
				[if (length(args0) == 1) argsToDoubles(args0[0]) else []],
				IllegalStruct()
			)
		});
	}
	argsToDoublesInArray("WigiTableColumnWidths");
	argsToDoublesInArray("WigiTableRowHeights");
	/*---end of doubles fixup--*/

	tree := setTree(^tree, "WigiPageBreak", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 0) {
				// from 	WigiPageBreak()
				// to 		WigiPageBreak(append: bool, autoScroll: bool)
				[
					false,
					false,
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiPageBreak", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiTableCell", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 1) {
				// from 	WigiTableCell(cellStyle : [WigiTableCellStyle])
				// to 		WigiTableCell(widthHeight : DynamicBehaviour<WidthHeight>, cellStyle : [WigiTableCellStyle])
				[
					make(zeroWH),
					args[0],
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiTableCell", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiSpreadsheetCell", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 2) {
				// from 	WigiSpreadsheetCell(editMode : DynamicBehaviour<bool>, cellStyle : [WigiTableCellStyle])
				// to 		WigiSpreadsheetCell(widthHeight : DynamicBehaviour<WidthHeight>, editMode : DynamicBehaviour<bool>, cellStyle : [WigiTableCellStyle])
				[
					make(zeroWH),
					args[0],
					args[1],
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiSpreadsheetCell", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiPageName", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 1) {
				// from 	WigiPageName(name: string)
				// to 		WigiPageName(name: string, disableCondition: string)
				[
					args[0],
					"",
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiPageName", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiComboBox", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 2) {
				// from 	WigiComboBox(selected : DynamicBehaviour<int>, values : string)
				// to 		WigiComboBox(selected : DynamicBehaviour<int>, values : string, reorderElements : bool, width : double)
				[
					args[0],
					args[1],
					flow(false),
					flow(0.0),
				];
			} else if (length(args) == 3) {
				// from 	WigiComboBox(selected : DynamicBehaviour<int>, values : string, width: double)
				// to 		WigiComboBox(selected : DynamicBehaviour<int>, values : string, reorderElements : bool, width : double)
				[
					args[0],
					args[1],
					false,
					args[2],
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiComboBox", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiReferenceDocument", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 1) {
				// from 	WigiReferenceDocument(document)
				// to 		WigiReferenceDocument(title, document)
				[
					"",
					args[0]
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiReferenceDocument", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiCellFormattingNumber", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 3) {
				// from 	WigiCellFormattingNumber(decimal: int, useSeparator: bool, negativeFormat: NegativeNumberStyle)
				// to 		WigiCellFormattingNumber(decimal: int, useSeparator: bool, negativeFormat: NegativeNumberStyle, scientific: bool)
				[
					args[0],
					args[1],
					args[2],
					false
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiCellFormattingNumber", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiCellFormattingSignificant", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 1) {
				// from 	WigiCellFormattingSignificant(digits: int)
				// to 		WigiCellFormattingSignificant(digits: int, scientific: bool)
				[
					args[0],
					false
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiCellFormattingSignificant", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiRadioOption", \_args -> {
		str2int = \args : [flow] -> {
			if (length(args) == 2) {
				// from 	WigiRadioOption: (id: string, value: string)
				// to 		WigiRadioOption: (id: string, value: int)
				[
					args[0],
					args[1] |> toString |> s2i // We have to do cast each time as it is not possible to distinguish flow(string) and flow(int)
				];
			} else {
				args
			}
		}

		finalArgs = _args |> str2int;
		makeStructValue("WigiRadioOption", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiFeedbackBlock", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 2) {
				// from 	WigiFeedbackBlock(formula : string, choices: [WigiFeedbackChoice])
				// to 		WigiFeedbackBlock(formula : string, visibilityCondition : string, interactiveType: WigiFeedbackInteractiveType, choices: [WigiFeedbackChoice])
				[
					args[0],
					flow("scored=1"),
					flow(ComboboxOther()),
					args[1]
				];
			} else if (length(args) == 3) {
				// from 	WigiFeedbackBlock(formula : string, visibilityCondition : string, choices: [WigiFeedbackChoice])
				// to 		WigiFeedbackBlock(formula : string, visibilityCondition : string, interactiveType: WigiFeedbackInteractiveType, choices: [WigiFeedbackChoice])
				[
					args[0],
					args[1],
					ComboboxOther(),
					args[2]
				];
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiFeedbackBlock", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiReference", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 3) {
				// from 	WigiReference(tableName : string, columnName : string, formula : string)
				// to 		WigiReference(tree : Tree<string, string>)
				[
					pairs2tree([
						Pair("tableName", args[0]),
						Pair("columnName", args[1]),
						Pair("formula", args[2]),
						Pair("storeToDoc", "false")
					])
				]
			} else {
				args
			}
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiReference", finalArgs, IllegalStruct());
	});

	tree := setTree(^tree, "WigiEditorTestState", \_args -> {
		addValues = \args : [flow] -> {
			if (length(args) == 7) { // the case for old test cases, recorded for wigi in flow repo.
				[
					args[0],	// document: WigiElement,
					args[1],	// viewSize: WidthHeight
					args[2],	// cursor: [int]
					args[3],	// selectionAnchor: Maybe<[int]>
					args[4],	// selection: WigiSelection
					args[5],	// clipboard: Maybe<WigiElement>
					args[6],	// defaultStyles: [WigiStyles]
					flow(JsonNull()), // env: Json
					flow(None()),		// systemClipboard: Maybe<SystemClipboardData>
					flow(None())		// cursorCoord: Maybe<Point>
				];
			} else if (length(args) == 9) { // the case for old test cases with env and clipboard
				[
					args[0],	// document: WigiElement,
					args[1],	// viewSize: WidthHeight
					args[2],	// cursor: [int]
					args[3],	// selectionAnchor: Maybe<[int]>
					args[4],	// selection: WigiSelection
					args[5],	// clipboard: Maybe<WigiElement>
					args[6],	// defaultStyles: [WigiStyles]
					args[7], 	// env: Json
					args[8],	// systemClipboard: Maybe<SystemClipboardData>
					flow(None())		// cursorCoord: Maybe<Point>
				];
			} else args
		}

		finalArgs = _args |> addValues;
		makeStructValue("WigiEditorTestState", finalArgs, IllegalStruct());
	});

	tree := mergeTree(^tree, imageDecoratedFixups()); //Wigi refers images decorated's structs

	^tree
}

wigiFixupGenerated : ref Maybe<Tree<string, (args : [flow]) -> flow>> = ref None();

wigiFixup() {
	onlyOnce(wigiFixupGenerated, makeWigiFixup)
}


