import formats/wiki/wikivariables;
import wigi/wigi_engine_types;
import wigi/wigi_evaluate;
import http;

export {
	// For constants and variables, define a name into the engine. Returns an unsubscriber.
	// This will happily override any existing name
	addValueToEngine(engine : WigiEngine, namespace : WigiScope, x : string, value : Behaviour<WigiValue>, registerToEngine : bool) -> () -> void;

	addValueToWigiEngine(engine : WigiEngine, cell : WigiCellName, value : Behaviour<WigiValue>) -> () -> void;
	addValueToWigiEngineExtended(engine : WigiEngine, cell : WigiCellName, value : Behaviour<WigiValue>, style : [WigiEngineStyle]) -> () -> void;

	// The same, except that if the name is already defined, we set up a bidirectional link instead
	// linkToWiki is true by default, but you may choose not to link to string variables (in inputBox, for example)
	linkValueToEngine(engine : WigiEngine, namespace : WigiScope, x : string, expr : Behaviour<WigiValue>, linkToWiki: bool) -> () -> void;
	linkValueToEngineExtended(engine : WigiEngine, cell : WigiCellName, expr : Behaviour<WigiValue>, style : [WigiEngineStyle]) -> () -> void;

	// Add a formula to the engine - returns the value, and a function to dispose of the formula again.
	// nsForSearch parameter shows where to search built-in variable names
	addFormulaToEngine(engine : WigiEngine, namespace : WigiScope, x : string, nsForSearch : WigiScope, expr : WigiExpr,
			registerToEngine : bool, linkToWiki : bool) -> Pair<Behaviour<WigiValue>, [() -> void]>;
	addFormulaToEngineExtended(engine : WigiEngine, namespace : WigiScope, x : string, nsForSearch : WigiScope, expr : WigiExpr,
			style : [WigiEngineStyle]) -> Pair<Behaviour<WigiValue>, [() -> void]>;

	// Some of functions which are used in Calculated cells can't be calculated if we know only current values of parameters,
	// because they need previous values of parameters or previous result of itself, for example ON, GATE, COUNTING and etc.
	// These functions are implemented using Behaviours, which are created at preprocessing step "prepareExp".
	prepareExp(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr, uns : ref [() -> void]) -> WigiExpr;

	addAutonameFormulaToEngine(engine : WigiEngine, namespace : WigiScope, basename : string, nsForSearch : WigiScope,
			expr : WigiExpr, style : [WigiEngineStyle]) -> Pair<Behaviour<WigiValue>, [()->void]>;

	// expr should contain a name and may consist only of WigiVarRef, WigiCellRefA1, WigiNamespace
	// otherwise the name is considered empty
	getValueFromEngine(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr, def_ : WigiValue) -> Behaviour<WigiValue>;

	// If onlyInNamespace == false, then it searches in other namespaces which are specified inside resolveWigiCell fn.
	// If in doubt which mode to use, onlyInNamespace = false is your choice.
	getValueFromEngine2(engine : WigiEngine, namespace : WigiScope, x : string, onlyInNamespace: bool) -> Maybe<Behaviour<WigiValue>>;

	// changes value of the cell in the engine for existing cell or creates new cell as DeathlessVariable with const(newValue)
	setValueToEngine(engine : WigiEngine, cell : WigiCellName, newValue : WigiValue) -> void;

	updateEngineVariable(engine : WigiEngine, cell : WigiCellName) -> void;
	updateEngineFormula(engine : WigiEngine, cell : WigiCellName, nsForSearch : WigiScope) -> void;

	// Just calculate a formula without any engine registrations and behaviours
	calculateWigiValueFromFormula(formula : string, engine : WigiEngine, nsForSearch : WigiScope) -> WigiValue;

	// Calculates value if input parameter is formula
	calculateValueFromFormula(valueOrFormula : string, engine : WigiEngine, nsForSearch : WigiScope) -> string;

	calculateWigiValueFromExpr(expr : WigiExpr, engine : WigiEngine, nsForSearch : WigiScope) -> WigiValue;

	defaultPreprocessingValue = WigiError("Isn't set");

	// You can subscribe on the changes of some expression, and be able to unsubscribe,
	// without specifying low-level details like namespace and formula name, unlike addAutonameFormulaToEngine.
	addTemporaryFormulaToEngine(expr : WigiExpr, engine : WigiEngine, nsForSearch : WigiScope) -> Pair<Behaviour<WigiValue>, [() -> void]>;

	dumpWigiEngineDependencies(caption : string, dependencies :  Tree<WigiCellName, [WigiCellName]>) -> void;
}

addValueToEngine(engine : WigiEngine, namespace : WigiScope, x : string, value : Behaviour<WigiValue>, registerToEngine : bool) -> () -> void {
	u1 = addValueToEngineOnly(engine, namespace, x, value, registerToEngine);
	u2 = makeLinkToWiki(engine, wigiCellName(x, namespace), value, true);
	\-> {
		u1();
		u2();
	}
}

addValueToEngineOnly(engine : WigiEngine, namespace : WigiScope, x : string, value : Behaviour<WigiValue>, registerToEngine : bool) -> () -> void {
	cell = wigiCellName(x, namespace);

	if (registerToEngine) {
		addValueToWigiEngine(engine, cell, value);
	} else {
		switch (lookupWigiCellName(^(engine.env), cell)) {
			Some(__): linkValueToEngine(engine, namespace, x, value, true);
			None(): addValueToWigiEngine(engine, cell, value)
		}
	}
}

linkValueToEngine(engine : WigiEngine, namespace : WigiScope, x : string, value : Behaviour<WigiValue>, linkToWiki: bool) -> () -> void {
	linkValueToEngineExtended(engine, wigiCellName(x, namespace), value, [LinkToWiki(linkToWiki)])
}

linkValueToEngineExtended(engine : WigiEngine, cell : WigiCellName, value : Behaviour<WigiValue>, style : [WigiEngineStyle]) -> () -> void {
	createBidirectionalLinkOrUpdateOldValue = \old : DynamicBehaviour<WigiValue> -> {
		switch (value) {
			ConstBehaviour(__): {
				nextDistinct(old, getValue(value));
				nop
			}
			DynamicBehaviour(__, __): {
				vars = if (contains(style, OverrideWigiVariableByNewValue())) Pair(value, old) else Pair(old, value);
				bidirectionalLinkNonDistinct(vars.first, vars.second, idfn, idfn)
			}
		}
	}

	unsub1 = switch (lookupWigiCellName(^(engine.env), cell)) {
		None(): switch (lookupWigiFormula(^(engine.env), cell)) {
			None(): {
				addValueToWigiEngineExtended(engine, cell, value, style)
			}
			Some(formula): {
				// Despite of it is a formula with some WigiExpr (not only DynamicBehaviour<WigiValue>),
				// nevertheless we do override it's value (but do not touch expression).
				// It's a feature, not a bug. So probably at some point formula has the state where
				// its value is not equal to the calculated expression.
				// Let's consider we have a calculated cell where: a = 1 + 2, i.e. we have a formula
				// like <"a", "=1+2", 3>. And we also have a button with the same var_name "a" and value 7.
				// When we click the button the formula for "a" changes to <"a", "=1+2", 7>.
				createBidirectionalLinkOrUpdateOldValue(formula.value)
			}
		}
		Some(ev): switch (ev : Behaviour<WigiValue>) {
			ConstBehaviour(__): {
				if (!contains(style, OverrideWigiVariableByNewValue())) {
					switch (value : Behaviour<WigiValue>) {
						ConstBehaviour(__): {} // We can not bind, so we just override.
						DynamicBehaviour(__, __): nextDistinct(value, getValue(ev));
					}
				}
				addValueToWigiEngineExtended(engine, cell, value, arrayPush(style, DeathlessVariable(true)))
			}
			DynamicBehaviour(__, __): {
				// println("Setting bidirectionalLink for " + cellName2string(cell));
				createBidirectionalLinkOrUpdateOldValue(ev)
			}
		}
	}

	linkToWiki = extractStruct(style, LinkToWiki(false)).v;
	unsub2 = if (linkToWiki) makeLinkToWiki(engine, cell, value, true) else nop;
	\ -> {
		unsub1();
		unsub2();
	}
}

addValueToWigiEngine(engine : WigiEngine, cell : WigiCellName, value : Behaviour<WigiValue>) -> () -> void {
	addValueToWigiEngineExtended(engine, cell, value, [])
}

addValueToWigiEngineExtended(engine : WigiEngine, cell : WigiCellName, value : Behaviour<WigiValue>, style : [WigiEngineStyle]) -> () -> void {
	engine.env := addWigiName(^(engine.env), cell, value);

	unsub = subscribe(value, \__ -> {
		updateEngineVariable(engine, cell);
	});

	disposer = \ -> {
		engine.env := removeWigiName(^(engine.env), cell);
		// Send an update, since we are dead!
		updateEngineVariable(engine, cell);
		// Don't forget to clean up dependencies
		engine.dependencies := removeFromTree(^(engine.dependencies), cell);
		unsub();
	}

	\ -> {
		if (extractStruct(style, DeathlessVariable(false)).v) {
			// Some other cells have already linked to this variable, so just save its disposer and call it later
			refArrayPush(engine.callbacks, disposer);
		} else {
			disposer();
		}
	}
}

// make bidirectionalLink to wiki world with higher priority of wiki variable
// if bidirectional is false will be only one-directional link from wigi to wiki
makeLinkToWiki(engine : WigiEngine, cell : WigiCellName, value : Behaviour<WigiValue>, bidirectional : bool) -> () -> void {
	switch(value) {
		ConstBehaviour(constv): {
			nop
		}
		DynamicBehaviour(__, __): {
			doLink = \wikiname -> {
				// First, check if it exists in the Wiki world
				env = getGlobalWVEnvironment();
				wikivar = lookupTree(^(env.doubles), wikiname);

				wiki2wigiValue = \w : double -> {
					// Check what form we already had!
					switch (getValue(value) : WigiValue) {
						WigiDouble(v): {
							WigiDouble(w);
						}
						WigiInt(v): WigiInt(round(w));
						WigiBool(v): WigiBool(w != 0.0);
						WigiDefaultValue(): WigiDouble(w);
						WigiString(v): WigiString(i2s(round(w)));
						default: getValue(value);
					}

/*
					if (newValue != getValue(value)) {
						println("Wiki changed variable " + cellName2string(cell) + " from " + toString(getValue(value)) + " to " + toString(newValue));
					}
*/
				}

				link = switch (wikivar) {
					None(): {
						// No, it does not exist in Wiki: Wigi wins!
						// println("Does not exist in Wiki, adding " + wikiname);
						dv = getDoubleVarBehaviour(env, wikiname);
						\ -> {
							u = if (bidirectional) {
								bidirectionalLink(value, dv, wigiValue2Double, wiki2wigiValue)
							} else {
								subscribe(value, \v -> next(dv, wigiValue2Double(v)))
							}
							\ -> {
								u();
								removeDoubleVar(env, wikiname);
							}
						}
					}
					Some(dv): {
						// Yep, it does exist, so Wiki wins
						if (bidirectional) {
							\ -> bidirectionalLink(dv, value, wiki2wigiValue, wigiValue2Double)
						} else {
							\ -> subscribe(value, \v -> next(dv, wigiValue2Double(v)))
						}
					}
				}

				isValidDouble = \v: string -> d2s(s2d(v)) == v;

				wg = getValue(value);
				switch (wg : WigiValue) {
					WigiDouble(v): link();
					WigiInt(v): link();
					WigiBool(v): link();
					WigiDefaultValue(): link();
					WigiString(v): {
						if (isValidDouble(v))
							link()
						else {
							// println("Skipped linking " + wikiname + " to wiki, because it's not a number: " + v);
							nop
						}
					}
					default: nop;
				}
			}
			namespacedWikiname = "$" +  toLowerCase(strGlue(reverseA(namespaceOfCellName(cell).names), "_"));
			uns1 = doLink(namespacedWikiname);
			env = ^(engine.env);
			firstScope = firstElement(filter(getTreeKeys(env.namespaces), neq(WigiScope([]))), WigiScope([]));
			nonNamespacedWikiname = "$" +  toLowerCase(cell.name);
			uns2 = if ((tail(namespaceOfCellName(cell).names) == firstScope.names) && (namespacedWikiname != nonNamespacedWikiname)) {
				doLink(nonNamespacedWikiname)
			} else nop;
			\-> {
				uns1();
				uns2();
			}
		}
	}
}


addFormulaToEngine(engine : WigiEngine, namespace : WigiScope, x : string, nsForSearch : WigiScope, expr : WigiExpr,
		registerToEngine : bool, linkToWiki : bool) -> Pair<Behaviour<WigiValue>, [() -> void]> {
	addFormulaToEngineExtended(engine, namespace, x, nsForSearch, expr,
		[RegisterToEngine(registerToEngine), LinkToWiki(linkToWiki)]
	)
}

addFormulaToEngineExtended(engine : WigiEngine, namespace : WigiScope, x : string, nsForSearch : WigiScope, expr : WigiExpr,
		style : [WigiEngineStyle]) -> Pair<Behaviour<WigiValue>, [() -> void]> {

	registerToEngine = extractStruct(style, RegisterToEngine(true)).v;
	linkToWiki = extractStruct(style, LinkToWiki(false)).v;
	deathlessVariable = extractStruct(style, DeathlessVariable(false)).v;
	isEvaluatedValue = containsStruct(style, EvaluatedValue(WigiDefaultValue()));

	uns = ref [];
	// Any names linked to Wiki need to be hooked up
	expr0 = if (linkToWiki) prepareExpWiki(engine, nsForSearch, expr, uns) else expr;
	// Call-by-name functions need to be hooked up
	expr1 = prepareExp(engine, nsForSearch, expr0, uns);
	cell = wigiCellName(x, namespace);

	evaluated = if (isEvaluatedValue) {
		extractStruct(style, EvaluatedValue(WigiDefaultValue())).value
	} else {
		evaluateEngineExpr(engine.env, ^(engine.externalFunctions), nsForSearch, x, expr1)
	}

	add = \value : DynamicBehaviour<WigiValue> -> {
		unsub = subscribe(value, \__ -> {
			updateEngineVariable(engine, cell);
		});

		engine.env := addWigiFormula(^(engine.env), cell, WigiFormulaType(expr1, value, nsForSearch));
		refArrayPush(uns, \ -> {
			engine.env := removeWigiFormula(^(engine.env), cell);
			updateEngineVariable(engine, cell);
			unsub();
		});

		value
	}

	v = if (registerToEngine) {
		add(make(evaluated))
	} else {
		switch(lookupWigiFormula(^(engine.env), cell)) {
			None(): add(make(evaluated));
			Some(formula): {
				next(formula.value, evaluated);
				engine.env := addWigiFormula(^(engine.env), cell, WigiFormulaType(expr1, formula.value, nsForSearch));
				formula.value
			}
		}
	}

	// Add dependencies
	refConcat(uns, addEngineDependencies(engine, cell, expr1, nsForSearch));
	// Add a one-directional link from wigi to wiki
	if (linkToWiki) refArrayPush(uns, makeLinkToWiki(engine, cell, v, false));

	updateEngineVariable(engine, cell);

	disposer = \ -> {
		if (deathlessVariable) {
			// Some other cells have already linked to this variable, so just save its disposer and call it later
			refConcat(engine.callbacks, ^uns);
		} else {
			applyall(^uns);
		}
	}

	Pair(v, [disposer])
}

addAutonameFormulaToEngine(engine : WigiEngine, namespace : WigiScope, basename : string, nsForSearch : WigiScope,
		expr : WigiExpr, style : [WigiEngineStyle]) -> Pair<Behaviour<WigiValue>, [()->void]> {
	x = generateUniqWigiName(^(engine.env), namespace, basename);
	addFormulaToEngineExtended(engine, namespace, x, nsForSearch, expr, style)
}

prepareExp(engine : WigiEngine, nsForSearch : WigiScope, expr : WigiExpr, uns : ref [() -> void]) -> WigiExpr {
	mapWigiExpr(expr, \e -> {
		switch (e : WigiExpr) {
			WigiCall(fn, args): {
				switch(fn) {
					WigiVarRef(name): {
						either(callPreprocessingFunction(engine, nsForSearch, name, e, uns), e)
					}
					WigiCellRefA1(name): {
						either(callPreprocessingFunction(engine, nsForSearch, name, e, uns), e)
					}
					WigiString(name): {
						either(callPreprocessingFunction(engine, nsForSearch, name, e, uns), e)
					}
					default: e;
				}
			}
			default: e;
		}
	})
}

// It's preprocessing step to support wiki variables.
// We replace all unknown variables with corresponding wiki variables
prepareExpWiki(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr, uns : ref [() -> void]) -> WigiExpr {
	addWikiVar = \_x : string -> {
		env = ^(engine.env);
		switch (resolveWigiCell(env, namespace, _x)) {
			None(): {
				b = lookupTree(getWigiBuiltIns(), _x);
				switch(b) {
					None(): {
						exFn = lookupTree(^(engine.externalFunctions), _x);
						switch(exFn) {
							Some(__): {}
							None(): {
								// Completely unknown in Wigi world, so check if it exists in the Wiki environment!
								wikiname = "$" + toLowerCase(_x);
								wikiEnv = getGlobalWVEnvironment();
								wikivar = lookupTree(^(wikiEnv.doubles), wikiname);
								switch (wikivar) {
									None(): {}
									Some(dv): {
										// Yes, it does, so let's add it to the wigi world as well
										cell = wigiCellName(_x, namespace);
										println("Added $" + _x + " from the Wiki environment as " + cellName2string(cell));
										distinctValues = selectDistinctu(dv, \_dv -> WigiDouble(_dv));
										refArrayPush(uns, distinctValues.second);
										refArrayPush(uns, addValueToWigiEngine(engine, cell, distinctValues.first));
									}
								}
							}
						}
					}
					Some(__): {};
				}
			}
			Some(__): {};
		}
	};

	mapWigiExpr(expr, \e -> {
		switch (e : WigiExpr) {
			WigiVarRef(_x): addWikiVar(_x);
			WigiCellRefA1(_x): addWikiVar(_x);
			default: {};
		}
		e
	})
}

dumpWigiEngineDependencies(caption : string, dependencies :  Tree<WigiCellName, [WigiCellName]>) -> void {
	println("=== WigiEngineDependencies (" + caption + ") ===");
	traverseInOrder(dependencies, \key, value -> {
		println("  " + cellName2string(key) + ": [" + superglue(value, cellName2string, ", ") + "]")
	});
	println("==============================================");
}

addEngineDependencies(engine : WigiEngine, cell : WigiCellName, to : WigiExpr, namespace : WigiScope) -> [() -> void] {
	add = \x -> {
		qualified = switch (resolveWigiCell(^(engine.env), namespace, x)) {
			Some(v): v.first;
			None(): {
				nc = wigiCellName(x, namespace);
				//println("Do not know about " + x + " yet, so assume it is " + cellName2string(nc));
				// If we can not find it, we just add it here
				nc
			}
		}

		if (qualified != cell) {
			engine.dependencies := treePushToArrayUnique(^(engine.dependencies), qualified, cell);

			[\ -> {
				engine.dependencies := treeRemoveFromArrayValue(^(engine.dependencies), qualified, cell);
			}]
		} else []
	}

	simpleRecursiveCall = \arr -> fold(arr, [], \acc, p -> concat(acc, addEngineDependencies(engine, cell, p, namespace)));

	switch (to : WigiExpr) {
		WigiBool(v): [];
		WigiInt(v): [];
		WigiDouble(v): [];
		WigiString(v): [];
		WigiDate(y, m, d): [];
		WigiTime(h, m, s): [];
		WigiError(message): [];
		WigiDefaultValue(): [];
		WigiElementValue(e): [];
		WigiArray(exprs): [];
		WigiRecord(fs): [];
		WigiBuiltInName(name): [];
		WigiVarRef(x): {
			add(x);
		}
		WigiCellRefA1(x): {
			add(x |> simplifyWigiCellRef);
		}
		WigiCellRefRC(r, c): {
			a1 = convertCellRefRC2A1(to);
			addEngineDependencies(engine, cell, a1, namespace);
		}
		WigiLambda(args, body): {
			addEngineDependencies(engine, cell, body, namespace);
		}
		WigiCall(fn, args): {
			u1 = addEngineDependencies(engine, cell, fn, namespace);

			fold(args, u1, \acc, a -> {
				concat(acc, addEngineDependencies(engine, cell, a, namespace));
			});
		}
		WigiIf(condition, then, else_): {
			concat3(
				addEngineDependencies(engine, cell, condition, namespace),
				addEngineDependencies(engine, cell, then, namespace),
				addEngineDependencies(engine, cell, else_, namespace),
			);
		}
		WigiSequence(exprs): simpleRecursiveCall(exprs);
		WigiMatch(value, cases): {
			u0 = addEngineDependencies(engine, cell, value, namespace);
			fold(cases, u0, \acc, c -> {
				u1 = addEngineDependencies(engine, cell, c.pattern, namespace);
				u2 = addEngineDependencies(engine, cell, c.body, namespace);
				concat3(acc, u1, u2);
			});
		}
		WigiRangeA1(start, end): {
			fold(getRangeA1Names(start, end), [], \acc, name -> {
				env = ^(engine.env);
				concat(acc, addEngineDependencies(engine, cell, WigiCellRefA1(name), namespace))
			})
		}
		WigiRangeRC(start, end): {
			_start = convertCellRefRC2A1(start);
			_end = convertCellRefRC2A1(end);
			addEngineDependencies(engine, cell, WigiRangeA1(_start, _end), namespace)
		}
		WigiField(l, rs): {
			u1 = addEngineDependencies(engine, cell, l, namespace);
			fold(rs, u1, \acc, e -> {
				concat(acc, addEngineDependencies(engine, cell, e, namespace));
			});
		}
		WigiNamespace(ns, r): {
			nsResolved = resolveWigiNamespace(^(engine.env), cell, ns);
			addNamespacedEngineDependencies(engine, cell, r, nsResolved.names);
		}
		WigiMultiplicative(exprs): simpleRecursiveCall(exprs);
		WigiMult(op, expr): {
			addEngineDependencies(engine, cell, expr, namespace)
		}
		WigiMakeArray(values): simpleRecursiveCall(values);
		WigiMakeRecord(fields): {
			fold(fields, [], \acc, p -> {
				concat(acc, addEngineDependencies(engine, cell, p.second, namespace))
			})
		}

		WigiDatafunList(__, __) : simpleRecursiveCall(extractWigiExprsFromDatafunList(to));
		WigiDatafunInExpr(__, e) : addEngineDependencies(engine, cell, e, namespace);
	}
}

getRangeA1Names(left : WigiCellRefA1, right : WigiCellRefA1) -> [string] {
	l = simplifyWigiCellRef(left.x);
	r = simplifyWigiCellRef(right.x);
	concatA(getWigiRangeA1CellNames(l,r))
}

addNamespacedEngineDependencies(engine : WigiEngine, cell : WigiCellName, to : WigiExpr, ns : [string]) -> [() -> void] {
	add = \x -> {
		qualified = wigiCellName2(x, ns);

		engine.dependencies := treePushToArrayUnique(^(engine.dependencies), qualified, cell);

		[\ -> {
			engine.dependencies := treeRemoveFromArrayValue(^(engine.dependencies), qualified, cell);
		}]
	}

	switch (to : WigiExpr) {
		WigiVarRef(x): {
			add(x);
		}
		WigiCellRefA1(x): {
			add(x |> simplifyWigiCellRef);
		}
		WigiCellRefRC(r, c): {
			a1 = convertCellRefRC2A1(to);
			addNamespacedEngineDependencies(engine, cell, a1, ns);
		}
		WigiRangeA1(start, end): {
			fold(getRangeA1Names(start, end), [], \acc, name -> {
				concat(acc, add(name))
			})
		}
		default: addEngineDependencies(engine, cell, to, namespaceOfCellName(cell))
	}
}

updateEngineVariable(engine : WigiEngine, cell : WigiCellName) -> void {
	cleanVisited = isEmptySet(^(engine.visitedCells));

	visited = engine.visitedCells;

//	println("updateEngineVariable: " + cellName2string(cell) + " START. visited: " + set2stringExt(^visited, cellName2string));
	if (!containsSet(^visited, cell)) {
		visited := insertSet(^visited, cell);
		deps = getTreeArrayValue(^(engine.dependencies), cell);

//		println("updateEngineVariable: " + cellName2string(cell) + " updating, visited: " + set2stringExt(^visited, cellName2string));

		cellNamespace = namespaceOfCellName(cell);
		iter(deps, \f -> {
			updateEngineFormula(engine, f, cellNamespace);
		});
//		println("updateEngineVariable: " + cellName2string(cell) + " updated, visited: " + set2stringExt(^visited, cellName2string));
	}
//	println("updateEngineVariable: " + cellName2string(cell) + " END. visited: " + set2stringExt(^visited, cellName2string));

	if (cleanVisited) engine.visitedCells := makeSet();
}

updateEngineFormula(engine : WigiEngine, cell : WigiCellName, nsForSearch : WigiScope) -> void {
	visited = engine.visitedCells;
//	println("updateEngineFormula: " + cellName2string(cell) + " START. visited: " + set2stringExt(^visited, cellName2string));
	formula : WigiFormulaType = getWigiFormula(^(engine.env), cell);
	evaluateForNs = \ns -> evaluateEngineExpr(engine.env, ^(engine.externalFunctions), ns, cell.name, formula.formula);
	v0 = evaluateForNs(formula.nsForSearch);
	v = if (isWigiErrorVariableUndefined(v0)) evaluateForNs(nsForSearch) else v0;
	// TODO: Update a Wiki variable of the same name here
	nextDistinct(formula.value, v);
//	println("updateEngineFormula: " + cellName2string(cell) + " END. visited: " + set2stringExt(^visited, cellName2string));
}

getVariableName(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr) -> Maybe<Pair<WigiScope, string>> {
	switch(expr) {
		WigiVarRef(x): Some(Pair(namespace, x));
		WigiCellRefA1(x): Some(Pair(namespace, x));
		WigiNamespace(ns, r): {
			x = namespace.names[0];
			nsResolved = resolveWigiNamespace(^(engine.env), wigiCellName(x, namespace), ns);
			getVariableName(engine, WigiScope(concat([x], nsResolved.names)), r)
		}
		default: None()
	}
}

getValueFromEngine(e : WigiEngine, namespace : WigiScope, expr : WigiExpr, def_ : WigiValue) -> Behaviour<WigiValue> {
	eitherFn(getVariableName(e, namespace, expr),
		\cell -> either(getValueFromEngine2(e, cell.first, cell.second, false), const(def_)),
		\ -> const(def_))
}


getValueFromEngine2(e : WigiEngine, namespace : WigiScope, x : string, onlyInNamespace: bool) -> Maybe<Behaviour<WigiValue>> {
	env = ^(e.env);

	if (onlyInNamespace) {
		cell = wigiCellName(x, namespace);
		lookupWigiCellName(env, cell)
	} else {
		switch(resolveWigiCell(env, namespace, x)) {
			Some(v): Some(v.second);
			None(): None()
		}
	}
}

setValueToEngine(engine : WigiEngine, cell : WigiCellName, newValue : WigiValue) -> void {
	linkValueToEngineExtended(engine, cell, const(newValue), [DeathlessVariable(true)])()
}

pfOn(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	a = getValueFromEngine(engine, namespace, args[0], WigiError("Error"));
	selectWithLast(a, \last, new -> {
		if ((wigiValue2Double(last) == 0.0)&&(wigiValue2Double(new) == 1.0)) {
			b = evaluateEngineExpr(engine.env, ^(engine.externalFunctions), namespace, "", args[1]);
			next(bv, b);
		}
	});
	nop
}

pfGate(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	b = getValueFromEngine(engine, namespace, args[1], WigiError("Error"));
	subscribe(b, \_b -> {
		a = evaluateEngineExpr(engine.env, ^(engine.externalFunctions), namespace, "", args[0]);
		if (wigiValue2Double(a) == 1.0) {
			next(bv, _b);
		}
	});
}

pfCounting(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	a = getValueFromEngine(engine, namespace, args[0], WigiError("Error"));
	next(bv, WigiInt(0));
	selectWithLast(a, \last, new -> {
		if ((wigiValue2Double(last) == 0.0)&&(wigiValue2Double(new) == 1.0)) {
			next(bv, addWigiNumbers(getValue(bv), WigiInt(1)));
		}
	});
	nop
}

pfTimer(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	next(bv, WigiInt(0));
	timeout = pfExtractInt(engine, namespace, args[0]);
	timer(timeout, \ -> next(bv, WigiInt(1)));
	nop
}

pfRepeat(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	next(bv, WigiInt(0));
	timeout = pfExtractInt(engine, namespace, args[0]);
	t = ref nop;
	t := \-> {
		n = wigiValue2Int(getValue(bv))+1;
		next(bv, WigiInt(n));
		timer(timeout, ^t)
	};
	timer(timeout, ^t);
	\-> {
		t := nop;
	}
}

pfExtractInt(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr) -> int {
	round(pfExtractDouble(engine, namespace, expr))
}

pfExtractDouble(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr) -> double {
	v = evaluateEngineExpr(engine.env, ^(engine.externalFunctions), namespace, "", expr);
	wigiValue2Double(v)
}

pfMerge(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	arraySubscribe2(map(args, \arg -> getValueFromEngine(engine, namespace, arg, WigiError("Error"))), \i, before, after -> {
		next(bv, after)
	});
}

pfLastOf(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	arraySubscribe2(map(args, \arg -> getValueFromEngine(engine, namespace, arg, WigiError("Error"))), \i, before, after -> {
		next(bv, WigiInt(i))
	});
}

pfAllOn(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	calc = \-> WigiArray(sort(foldi(args, [], \idx, acc, arg -> {
		value = evaluateEngineExpr(engine.env, ^(engine.externalFunctions), namespace, "", arg);
		if (wigiValue2Double(value) == 1.0) arrayPush(acc, WigiInt(idx)) else acc;
	})));
	next(bv, calc());
	arraySubscribe2(map(args, \arg -> getValueFromEngine(engine, namespace, arg, WigiError("Error"))), \i, before, after -> {
		next(bv, calc());
	});
}

pfClick(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	a = getValueFromEngine(engine, namespace, args[0], WigiError("Error"));
	selectWithLast(a, \last, new -> {
		if ((wigiValue2Double(last) == 1.0)&&(wigiValue2Double(new) == 0.0)) {
			next(bv, WigiBool(true));
		}
		next(bv, WigiBool(false))
	});
	nop
}

// optional second argument of "request" - array of strings
// that specifies subset of json to extract
// example:
//   given json { results: [ { name: "a" }, { name: "b" } ] }
//   and array ["results", "name"]
//   the extracted subset would be ["a", "b"]
pfRequest(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	next(bv, pfRequestWrapValue([]));

	if (length(args) != 1 && length(args) != 2) {
		next(bv, pfRequestWrapValue([WigiError("Wrong number of arguments. Expected 1 or 2, but got " + i2s(length(args)))]));
		nop
	} else switch(if (length(args) == 2) args[1] else WigiArray([])) {
		WigiArray(path): {
			formula = addAutonameFormulaToEngine(engine, namespace, "__REQUEST_URL", namespace, args[0],
				[RegisterToEngine(true), LinkToWiki(true)]
			);

			uns = subscribe(formula.first, \url -> {
				httpRequest(wigiValue2String(url), false, [], [],
					\textData -> {
						 extracted = extractArrayFromWigi(json2WigiValue(parseJson(textData)), path);
						 nextDistinct(bv, pfRequestWrapValue(extracted))
					},
					\textError -> next(bv, pfRequestWrapValue([WigiError(textError)])),
					\__ -> {}
				);
			});

			\ -> { applyall(formula.second); uns() }
		}
		default: {
			next(bv, pfRequestWrapValue([WigiError("Invalid type of second argument. Only array of strings is valid")]));
			nop
		}
	}
}

extractFromWigiError = WigiError("unexpected structure");

extractArrayFromWigi(structure : WigiValue, path : [WigiValue]) -> [WigiValue] {
	switch(extractArrayFromWigi2(structure, path)) {
		WigiArray(values): if (length(values) == 0) [structure] else values;
		WigiError(text): [WigiError(text), structure];
		default: [structure]
	}
}

extractArrayFromWigi2(structure : WigiValue, path : [WigiValue]) -> WigiValue {
	if (length(path) == 0) structure
	else {
		switch(structure) {
			WigiRecord(pairs): {
				pathEntry = getWigiString(path[0]);
				switch(find(pairs, \p -> { p.first == pathEntry })) {
					Some(pair): extractArrayFromWigi2(pair.second, tail(path));
					None(): extractFromWigiError
				}
			}
			WigiArray(values): {
				resValues = map(values, \v -> extractArrayFromWigi2(v, path));
				if (length(resValues) > 0 && resValues[0] == extractFromWigiError) extractFromWigiError
				else WigiArray(resValues)
			}
			default: structure
		}
	}
}

pfRequestWrapValue(array : [WigiValue]) -> WigiArray {
	WigiArray([WigiArray(array)])
}

pfHistory(engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void {
	if (length(args) < 1 || length(args) > 3) {
		next(bv, WigiError("Wrong number of arguments. Expected 1-3, but got " + i2s(length(args))));
		nop
	} else {
		eitherFn(getVariableName(engine, namespace, args[0]),
			\cell ->
				switch(getValueFromEngine2(engine, cell.first, cell.second, false)) {
					None(): {
						next(bv, WigiError("Invalid first argument. Expected cell reference"));
						nop
					}
					Some(val): {
						timeout = if (length(args) >= 3) pfExtractDouble(engine, namespace, args[2]) else 0.0;
						limit = if (length(args) >= 2) pfExtractInt(engine, namespace, args[1]) else 0;
						lastAt = ref 0.0;
						cell_history = ref [];
						next(bv, WigiArray(^cell_history));
						subscribe(val, \v -> {
							now = timestamp();
							if (^lastAt + timeout < now) {
								lastAt := now;
								cell_history := concat(^cell_history, [WigiRecord([Pair("time", WigiInt(round(now / 1000.0))), Pair("value", v)])]);
							}
							if (limit != 0 && length(^cell_history) > limit) {
								cell_history := tail(^cell_history);
							}
							nextDistinct(bv, WigiArray(^cell_history));
						})
					}
				},
				\ -> {
					next(bv, WigiError("Invalid  argument. Variable not found"));
					nop
				})
	}
}

WigiPreprocessingFunction(
	name : string,
	fn : (engine : WigiEngine, namespace : WigiScope, args : [WigiExpr], bv : DynamicBehaviour<WigiValue>) -> () -> void
);

// Storage for preprocessing functions
WigiPreprocessingFunctions : ref Tree<string, WigiPreprocessingFunction> = ref fold(
	[
		WigiPreprocessingFunction("ON", pfOn),
		WigiPreprocessingFunction("GATE", pfGate),
		WigiPreprocessingFunction("COUNTING", pfCounting),
		WigiPreprocessingFunction("TIMER", pfTimer),
		WigiPreprocessingFunction("REPEAT", pfRepeat),
		WigiPreprocessingFunction("MERGE", pfMerge),
		WigiPreprocessingFunction("LASTOF", pfLastOf),
		WigiPreprocessingFunction("ALLON", pfAllOn),
		WigiPreprocessingFunction("CLICK", pfClick),
		WigiPreprocessingFunction("REQUEST", pfRequest),
		WigiPreprocessingFunction("HISTORY", pfHistory),
	],
	makeTree(),
	\acc, b -> setTree(acc, b.name, b)
);

callPreprocessingFunction(engine : WigiEngine, nsForSearch : WigiScope, name : string, e : WigiCall, uns : ref [() -> void]) -> Maybe<WigiExpr> {
	if (!containsKeyTree(^WigiPreprocessingFunctions, name) && !containsKeyTree(^(engine.externalPreprocessingFunctions), name)) None()
	else {
		v : DynamicBehaviour<WigiValue> = make(defaultPreprocessingValue);

		disposer1 = switch(lookupTree(^WigiPreprocessingFunctions, name)) {
			Some(val): val.fn(engine, nsForSearch, e.args, v);
			None(): {
				switch(lookupTree(^(engine.externalPreprocessingFunctions), name)) {
					Some(fn): {
						argValues = map(e.args, \arg -> {
							convertArg = \ -> const(evaluateEngineExpr(engine.env, ^(engine.externalFunctions), nsForSearch, "", arg));
							eitherFn(getVariableName(engine, nsForSearch, arg),
								\cell ->
									switch(getValueFromEngine2(engine, cell.first, cell.second, false)) {
										Some(value): value;
										None(): convertArg();
									},
								\ -> convertArg()
							)
						});
						fn(engine, nsForSearch, argValues, v)
					}
					None(): nop
				}
			}
		}

		x = generateUniqWigiName(^(engine.env), preprocessingScope(), "__" + name);
		disposer2 = addValueToEngineOnly(engine, preprocessingScope(), x, v, true);
		refArrayPush(uns, \-> {
			disposer1();
			disposer2();
		});
		expr : WigiExpr = WigiVarRef(x);
		Some(expr)
	}
}

calculateWigiValueFromFormula(formula : string, engine : WigiEngine, nsForSearch : WigiScope) -> WigiValue {
	if (startsWith(formula, "=")) {
		expr0 = parseWigiExpr(formula);
		calculateWigiValueFromExpr(expr0, engine, nsForSearch)
	} else {
		string2WigiValue(formula)
	}
}

calculateValueFromFormula(valueOrFormula : string, engine : WigiEngine, nsForSearch : WigiScope) -> string {
	if (startsWith(valueOrFormula, "=")) {
		wigiValue2String(calculateWigiValueFromFormula(valueOrFormula, engine, nsForSearch))
	} else valueOrFormula
}

calculateWigiValueFromExpr(expr : WigiExpr, engine : WigiEngine, nsForSearch : WigiScope) -> WigiValue {
	uns = ref [];
	expr1 = prepareExp(engine, nsForSearch, expr, uns);
	res = evaluateEngineExpr(engine.env, ^(engine.externalFunctions), nsForSearch, "", expr1);
	applyall(^uns);
	res
}

addTemporaryFormulaToEngine(expr : WigiExpr, engine : WigiEngine, nsForSearch : WigiScope) -> Pair<Behaviour<WigiValue>, [() -> void]> {
	addAutonameFormulaToEngine(engine, namespace2scope(["tmp_functions"]), "__tmp_function", nsForSearch, expr, []);
}
