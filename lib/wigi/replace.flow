import wigi/types;
import wigi/wigi_engine;
import wigi/selection;
import wigi/clearing_utils;

export {
	// Traverse a document, calling a replacement function on all WigiText
	wigiReplace(w : WigiElement, replacementFn : (w : WigiText) -> [WigiElement]) -> WigiElement;

	// replacing the formula text by the calculated value
	wigiFormula2value(element : WigiElement, path : [int], namespace : [string], selection : WigiSelection, engine : WigiEngine) -> WigiElement;

	// Applies some fn to WigiElement-s from the root.
	// It also extracts namespace for the spreadsheet cells (not full mapping, used for formulas extraction).
	applyFn2WigiElement(root: WigiElement, initPath: [int], namespace : [string], onlyLeaf : bool, fn: (path: [int], element: WigiElement, nsp : [string]) -> WigiElement) -> WigiElement;
}

wigiReplace(w : WigiElement, replacementFn : (w : WigiText) -> [WigiElement]) -> WigiElement {
	r = wigiReplaces([w], replacementFn);
	fold(r, WigiEmpty(), concatWigi);
}

wigiReplaces(ws : [WigiElement], replacementFn : (w : WigiText) -> [WigiElement]) -> [WigiElement] {
	fold(ws, [], \acc, w -> {
		switch (w : WigiElement) {
			WigiEmpty(): arrayPush(acc, w);
			WigiRecursive(elements, type, style): {
				ch = map(elements, \e -> {
					wigiReplace(e, replacementFn);
				});
				nr = if (ch != elements) WigiRecursive(ch, type, style) else w;
				arrayPush(acc, nr);
			}
			WigiText(t, s): {
				concat(acc, replacementFn(w));
			}
			WigiStory(ps, views, style): {
				iteri(^ps, \i, p -> {
					re = wigiReplace(p, replacementFn);
					if (re != p) {
						ps := replace(^ps, i, re);
						// Update all views
						iter(^views, \v : TropicArray<WigiElement> -> {
							replaceTropicArray(v, i, re)
						});
					}
				});
				// We reuse the same object
				arrayPush(acc, w);
			}
			WigiParagraph(elements, style): {
				ch = wigiReplaces(elements, replacementFn);
				np = if (ch != elements) WigiParagraph(ch, style) else w;
				arrayPush(acc, np);
			}
			WigiDocument(r, s): {
				r2 = wigiReplace(r, replacementFn);
				arrayPush(acc, if (r != r2) WigiDocument(r2, s) else w);
			}
			WigiBlock(t, s): arrayPush(acc, w);
		}
	})
}

// replacing the formula text by the calculated value
wigiFormula2value(element : WigiElement, path : [int], namespace : [string], selection : WigiSelection, engine : WigiEngine) -> WigiElement {
	switch (element) {
		//calculated_cell formula
		WigiBlock(type, style): {
			switch (type) {
				WigiExternalBlock(exType, content): {
					if (exType == "material_calculated_cell") {
						formula = lookupTreeDef(content, "formula", "=");
						value = calculateWigiValueFromFormula(formula, engine, namespace |> WigiScope) |> wigiValue2String;
						WigiBlock(WigiExternalBlock(exType, setTree(content, "formula", "=" + value)), style);
					} else element;
				}
				WigiFormula(text, style2): {
					value = calculateWigiValueFromFormula(text, engine, namespace |> WigiScope) |> wigiValue2String;
					WigiBlock(WigiFormula(value, style2), style);
				}
				default: element;
			}
		}

		// spreadsheet formula
		WigiText(text, style): {
			// calc the text formulas only in the spredsheet - it's another NS
			if (namespace != getDefaultStateScope(^(engine.env)).names && startsWith(text |> trim, "=")) {
				// spredsheet cell has a [0,0,0] at the end of path. They may be absent at the selection path
				path2 = if (length(path) > 3) take(path, length(path) - 3) else path;

				isParentOrTheSame = \parentP, elementP -> {
					if (length(parentP) > length(elementP)) false
					else foldi(parentP, true, \i, acc, p -> (acc && p == elementP[i]))
				};

				isSelPosEqual2 = \elementP, selectionP, pos -> {
					sel = tailFrom(selectionP, elementP |> length);
					(length(sel) == 0) || (length(sel) == 4 && sel[3] == pos);
				};

				// checking: does the selection cover whole formula text
				// otherwie skip the formula calc
				flag_TextStart = if (isParentOrTheSame(path2, selection.start)) isSelPosEqual2(path2, selection.start, 0) else true;
				flag_TextEnd = if (isParentOrTheSame(path2, selection.end)) isSelPosEqual2(path2, selection.end, strlen(text)) else true;

				if (flag_TextStart && flag_TextEnd) {
					value = calculateWigiValueFromFormula(text, engine, namespace2scope(namespace)) |> wigiValue2String;

					// keep the original formula text if we cann't to evaluate it
					// (may be it's not a formula but a text)
					if (startsWith(value |> toLowerCase, "error:")) element
					else WigiText(value, style);
				} else element;
			}
			else element;
		}
		default: element;
	}
}

applyFn2WigiElement(root: WigiElement, initPath: [int], namespace : [string], onlyLeaf : bool, fn: (path: [int], element: WigiElement, nsp : [string]) -> WigiElement) -> WigiElement {
	element2fn = \el, ns ->
		mapi(el, \i, e -> applyFn2WigiElement(e, arrayPush(initPath, i), ns, onlyLeaf, fn));

	parent2fn = \el -> if (onlyLeaf) el else fn(initPath, el, namespace);

	switch (root) {
		WigiDocument(doc, style): {
			WigiDocument(element2fn([doc], namespace)[0], style) |> parent2fn;
		}
		WigiStory(stories, views, style): {
			stories := element2fn(^stories, namespace);
			WigiStory(stories, views, style) |> parent2fn;
		}
		WigiParagraph(elements, style): {
			clearedStyles = filterWigiParagraphExternalStyle(style);
			WigiParagraph(element2fn(elements, namespace), clearedStyles) |> parent2fn;
		}
		WigiRecursive(elements, type, style): {
			ns = switch (type) {
				WigiTable(__, __, __, __): {
					[extractStruct(style, WigiName("")).name |> toUpperCase];
				}
				default: namespace;
			}

			WigiRecursive(element2fn(elements, ns), type, style) |> parent2fn;
		}
		default: fn(initPath, root, namespace);
	}
}