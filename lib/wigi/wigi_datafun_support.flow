import wigi/types;
import wigi/wigi_environment_types;
import wigi/wigi_expr2string;
import wigi/wigi_expr;

export {
	evaluateWigiDatafunList(mainExpr : WigiExpr, varsExprs : [WigiExpr], evaluate : (WigiExpr) -> WigiValue) -> WigiValue;
}

evaluateWigiDatafunList(mainExpr : WigiExpr, varsExprs : [WigiExpr], evaluate : (WigiExpr) -> WigiValue) -> WigiValue {
	inExprs = extractStructMany(varsExprs, WigiDatafunInExpr("", WigiDefaultValue()));
	filterExprs = subtractA(varsExprs, inExprs);

	filtersWithVarRefs = fold(filterExprs, [], \acc, e -> {
		varRefs = extractVarRefs(e);

		if (varRefs == []) {
			evalResult = evaluate(e);

			if (isSameStructType(evalResult, WigiBool(false)))
				arrayPush(acc, Pair(evalResult, []))
			else
				acc;
		} else
			arrayPush(acc, Pair(e, map(varRefs, \varRef -> varRef.x)));
	});

	// first group is applied before generating final combinations, second one contains filters, that can be applied only to the final result
	filterGroups : Pair<[Pair<WigiExpr, [string]>], [Pair<WigiExpr, [string]>]> = fold(
		filtersWithVarRefs,
		Pair([], []),
		\acc : Pair<[Pair<WigiExpr, [string]>], [Pair<WigiExpr, [string]>]>, filterElement : Pair<WigiExpr, [string]> -> {
			if (length(filterElement.second) == 0)
				Pair(acc.first, arrayPush(acc.second, filterElement))
			else
				Pair(arrayPush(acc.first, filterElement), acc.second);
		}
	);

	listVarsWithValues = map(inExprs, \inExpr -> {
		varId = inExpr.id;
		values = presentAsArray(evaluate(inExpr.valuesExpr));

		Pair(varId, values);
	});

	listVarNames = map(listVarsWithValues, firstOfPair);
	mainVarNames = map(extractVarRefs(mainExpr), \varRef -> varRef.x);
	namesIntersection = intersection(mainVarNames, listVarNames);
	conflictingVars = filter(listVarsWithValues, \pair -> contains(namesIntersection, pair.first) && pair.second == []);

	if (conflictingVars != []) { // some generated values were filtered, but in main expr there are refs on their vars
		println("Error! Some var refs could not be replaced by value in main list expression: " + wigiExpr2string(mainExpr));
		println("Next vars were completely filtered:");

		iter(conflictingVars, \pair -> println(pair.first));

		WigiError("Could not evaluate main expression");
	} else {
		externalVarNames = subtractA(mainVarNames, namesIntersection);
		externalVarsWithValues = map(externalVarNames, \varName -> Pair(
			varName,
			presentAsArray(evaluate(WigiVarRef(varName)))
		));

		filteredVars = fold(filterGroups.first, listVarsWithValues, \acc, filterPair -> {
			filterExpr = filterPair.first;
			filterVars = filterPair.second;

			usedVars = filter(acc, \pair -> contains(filterVars, pair.first));
			unusedVars = subtractA(acc, usedVars);

			combinations = generateCombinationsRec(usedVars);

			concat(
				unusedVars,
				foldCombinationsToVars(filter(
					combinations,
					\combination -> applyFilterExpr(filterExpr, evaluate, pairs2tree(combination))
				))
			)
		});

		filteredVarsReordered = mergeSort(filteredVars, \pair1, pair2 -> {
			pos1 = findiDef(mainVarNames, \id -> id == pair1.first, -1);
			pos2 = findiDef(mainVarNames, \id -> id == pair2.first, -1);

			genericCompareDesc(pos1, pos2);
		});

		combinations = generateCombinationsRec(concat(externalVarsWithValues, filteredVarsReordered));

		finalValues =
			if (combinations == []) //some constant wigi expr
				[evaluate(mainExpr)]
			else {
				map(combinations, \combination -> {
					preparedMainExpr = replaceVarRefsWithValues(mainExpr, pairs2tree(combination));
					evaluate(preparedMainExpr);
				});
			}

		filteredFinalValues = fold(filterGroups.second, finalValues, \acc, filterPair -> {
			if (applyFilterExpr(filterPair.first, evaluate, makeTree()))
				acc
			else
				[];
		});

		WigiArray(filteredFinalValues);
	}
}

extractVarRefs(expr : WigiExpr) -> [WigiVarRef] {
	foldWigiExpr(expr, [], \acc, e -> {
		switch (e) {
			WigiVarRef(__) : arrayPush(acc, e);
			default : acc;
		}
	})
}

replaceVarRefsWithValues(expr : WigiExpr, vars : Tree<string, WigiValue>) -> WigiExpr {
	mapWigiExpr(expr, \e -> {
		switch (e) {
			WigiVarRef(id) : {
				value : WigiExpr = lookupTreeDef(vars, id, WigiError("No such variable!"));
				value
			}
			default : e;
		}
	})
}

presentAsArray(value : WigiValue) -> [WigiValue] {
	switch (value) {
		WigiArray(a) : a;
		default : [value];
	}
}

generateCombinationsRec(initial : [Pair<string, [WigiValue]>]) -> [[Pair<string, WigiValue>]] {
	if (initial == [])
		[]
	else {
		fold(initial[0].second, [], \acc, value -> {
			if (length(initial) == 1)
				arrayPush(acc, [Pair(initial[0].first, value)])
			else
				concat(acc, map(generateCombinationsRec(tail(initial)), \arr -> arrayPush(arr, Pair(initial[0].first, value))));
		});
	}
}

applyFilterExpr(filterExpr : WigiExpr, evaluate : (WigiExpr) -> WigiValue, vars : Tree<string, WigiValue>) -> bool {
	preparedFilterExpr = replaceVarRefsWithValues(filterExpr, vars);
	result = evaluate(preparedFilterExpr);

	switch (result) {
		WigiBool(b) : b;
		default : {
			println("Filter expression \"" + wigiExpr2string(filterExpr) + "\" doesn't output WigiBool result!");
			false;
		}
	}

}

foldCombinationsToVars(combinations : [[Pair<string, WigiValue>]]) -> [Pair<string, [WigiValue]>] {
	varsTree = fold(combinations, makeTree(), \acc, combination -> {
		fold(combination, acc, \acc2, pair -> treePushToArrayUnique(acc2, pair.first, pair.second));
	});

	foldTree(varsTree, [], \k, v, acc -> arrayPush(acc, Pair(k, v)));
}
