import wigi/position;

export {
	isWigiRecursive(element : WigiElement, types : [WigiRecursiveType]) -> bool;
	wigiFindParentRecursive(root : WigiElement, types : [WigiRecursiveType], path : [int]) -> [int];
	// find the outermost recursive parent and return it; if there is no recursive parent, you get []
	wigiFindPathOfOutermostRecursive(root : WigiElement, path : [int]) -> [int];
	// Some helpers
	inSameComapNode(root : WigiElement, path1 : [int], path2 : [int]) -> bool;
	inSameTableCell(document : WigiElement, path1 : [int], path2 : [int]) -> bool;

	// Some comap function, could be put into separate "comap_utils.flow" later if this one grows too much
	WigiComapNode : (path : [int], element : WigiRecursive, node : WigiComap);
	getWigiComapNode(root : WigiElement, path : [int]) -> WigiComapNode;

	getComapChildren(node : WigiComapNode) -> [WigiComapNode];

	dummyWigiComap = WigiRecursive([], WigiComap(make(false)), []);
	dummyComapNode = WigiComapNode([], dummyWigiComap, WigiComap(make(false)));

	dummyWigiTableCell = WigiTableCell(make(zeroWH), []);
	dummyWigiSpreadsheetCell = WigiSpreadsheetCell(make(zeroWH), make(false), []);
	dummyWigiExternalRecursive = WigiExternalRecursive("", makeTree());
	dummyWigiRadioOption = WigiRadioOption("", 0);
	dummyWigiButton = WigiButton(0.0, []);
	dummyWigiHyperlink = WigiHyperlink("");
	dummyWigiTable = WigiTable(0, 0, [], []);
	dummyWigiVersions = WigiVersions([]);

	// For debugging
	wigiRecursiveToString(type : WigiRecursiveType) -> string;
}

wigiRecursiveToString(type : WigiRecursiveType) -> string {
	switch (type : WigiRecursiveType) {
		WigiBrackets(leftBracketType, rightBracketType): "Brackets: left: " + toString(leftBracketType) + ", right: " + toString(rightBracketType);
		WigiComap(collapsed): "Comap " + if (getValue(collapsed)) "collapsed" else "open";
		WigiDottedElement(left, right, top, bottom, leftSign, rightSign): "Dotted element";
		WigiFraction(): "Fraction";
		WigiProduct(): "Product";
		WigiEvaluatingIntegral(): "EvaluatingIntegral";
		WigiRoot(): "Root";
		WigiLongDivision(): "Long division";
		WigiIntegral(): "Integral";
		WigiIntegral2(signType): "Integral2";
		WigiTopModificator(t, s): "Top modificator";
		WigiSum(): "Sum";
		WigiSupscript(): "Superscript";
		WigiSubscript(): "Subscript";
		WigiSupSubscript() : "SuperAndSubscript";
		WigiOverscript(): "Overscript";
		WigiUnderscript(): "Underscript";
		WigiOverlay(): "Overlay";
		WigiAltText(): "Alt text";
		WigiTable(r, c, cs, s): "Table: rows: " + i2s(r) + " columns: " + i2s(c) + " " + toString(s);
		WigiInteractiveTable(f, r, s): "Interactive table with " + i2s(length(getValue(r))) + " rows: " + toString(s);
		WigiTableCell(wh, cs): "Table cell";
		WigiSpreadsheetCell(wh, em, cs): "Spreadsheet cell";
		WigiFrame(w, h, s): "Frame " + d2s(w) + "x" + d2s(h) + " " + toString(s);
		WigiCode(sc, sr): "Code";
		WigiTyped(typ): "Typed " + typ;
		WigiButton(w, s): "Button, width: " + d2s(w);
		WigiHyperlink(u): "Hyperlink: " + u;
		WigiRadioOption(i, v): "Radio option: " + i + " := " + i2s(v);
		WigiVisible(s): "Invisible " + toString(s);
		WigiVersions(versions): "Version(" + toString(versions) + ")";
		WigiExternalRecursive(exType, content): "WigiExternalRecursive(" + exType + ")";
	}
}

isWigiRecursive(element : WigiElement, types : [WigiRecursiveType]) -> bool {
	switch (element) {
		WigiRecursive(e, t, s): {
			if (types != []) {
				any(map(types, \type -> {
					isSameStructType(type, t) &&
					switch (type : WigiRecursiveType) {
						WigiExternalRecursive(exType, __): {
							if (exType == "") true
							else switch (t : WigiRecursiveType) {
								WigiExternalRecursive(exType1, __): exType == exType1;
								default: false;
							}
						}
						default: true;
					}
				}))
			} else true
		}
		default: false;
	}
}

wigiFindParentRecursive(root : WigiElement, types : [WigiRecursiveType], path : [int]) -> [int] {
	if (path == []) path
	else {
		element = getElementAtPositionDef(root, path, dummyWigiElement);
		if (isWigiRecursive(element, types)) {
			path;
		} else {
			// Pop
			wigiFindParentRecursive(root, types, wigiParentPath(path))
		}
	}
}

wigiFindPathOfOutermostRecursive(root : WigiElement, path : [int]) -> [int] {
	firstParentRecursive = wigiFindParentRecursive(root, [], path);
	pathToOutermostRecursive(root, firstParentRecursive)
}

// return parent path as long as it is recursive element
pathToOutermostRecursive(root : WigiElement, path : [int]) -> [int] {
	parentPath = wigiParentPath(path);
	el = getElementAtPosition(root, parentPath);
	if (isWigiRecursive(el, [])) pathToOutermostRecursive(root, parentPath)
	else path
}


inSameComapNode(root : WigiElement, path1 : [int], path2 : [int]) -> bool {
	node1 = getWigiComapNode(root, path1);
	node1 != dummyComapNode && node1 == getWigiComapNode(root, path2);
}

inSameTableCell(document : WigiElement, path1 : [int], path2 : [int]) -> bool {
	cell1 = wigiFindParentRecursive(document, [dummyWigiTableCell, dummyWigiSpreadsheetCell], path1);
	cell1 != [] && cell1 == wigiFindParentRecursive(document, [dummyWigiTableCell, dummyWigiSpreadsheetCell], path2);
}

// Searches for our parent comap node
getWigiComapNode(root : WigiElement, path : [int]) -> WigiComapNode {
	e = getElementAtPosition(root, path);
	switch (e : WigiElement) {
		WigiRecursive(el, ty, s): {
			switch (ty : WigiRecursiveType) {
				WigiComap(c): makeWigiComapNode(path, e);
				default: {
					if (path != []) {
						getWigiComapNode(root, wigiParentPath(path));
					} else {
						dummyComapNode
					}
				}
			}
		}
		default: {
			if (path != []) {
				getWigiComapNode(root, wigiParentPath(path));
			} else {
				dummyComapNode
			}
		}
	}
}

makeWigiComapNode(path : [int], e : WigiElement) -> WigiComapNode {
	switch (e : WigiElement) {
		WigiRecursive(elements, type, style): {
			switch (type : WigiRecursiveType) {
				WigiComap(c): WigiComapNode(path, e, type);
				default: dummyComapNode;
			}
		}
		default: dummyComapNode;
	}
}

getComapChildren(node : WigiComapNode) -> [WigiComapNode] {
	switch (node.element.type : WigiRecursiveType) {
		WigiComap(co): {
			mapi(tail(node.element.elements), \i, e -> {
				makeWigiComapNode(arrayPush(node.path, i + 1), e)
			});
		}
		default: {
			[];
		}
	}
}
