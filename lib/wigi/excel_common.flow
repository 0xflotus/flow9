import wigi/excel_if_expression;
import algorithms;

export {
	// Supports ints, doubles and arrays of ints or double
	wigiTemplateStatFunction(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue;
	// Supports ints, doubles, strings and arrays of ints, double or strings
	wigiTemplateStatFunction1(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue;
	// Supports arrays of ints or doubles
	wigiTemplateStatFunction2(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue;
	// Supports arrays of ints, doubles or strings that are doubles
	wigiTemplateStatFunction3(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue;
	wigiTemplateMatrixFunction(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue;
	wigiTemplateTextFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue;
	wigiTemplateLogicalFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue;
	wigiTemplateMathFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue;
	wigiTemplateIntFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue;
	wigiTemplateDateFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue;

	wigiTemplateFlattenArray(vs : [WigiValue]) -> [WigiValue];

	isRangeVariable(name : string) -> bool;
	isStringDouble(s : string) -> bool;
	isCircularReferenceExpr(e : WigiExpr, name : string) -> bool;

	getWigiText(l : WigiValue) -> string;

	getStep(arr : [double]) -> double;
	getPlotStrokes(minV : double, maxV : double, step : double, acc : [double]) -> [double];
	getLeftPlotStrokes(minV : double, maxV : double, step : double, acc : [double]) -> [double];
	getRangeElement(range : string) -> Pair<string, string>;

	// Extract an array of values
	getWigiRangeData(range : WigiValue) -> [[string]];
	valueListSynchronize(range : WigiValue, list : [[string]]) -> [[string]];
	valueListBoxplotSynchronize(range : WigiValue, list : [[string]]) -> [[string]];
	valueListScatterplotSynchronize(range : WigiValue, list : [[string]]) -> [[string]];
	valueListStackedBarSynchronize(range : WigiValue, list : [[string]]) -> [[string]];
	valueListHistogramClassesSynchronize(range : WigiValue, list : [[string]], minX : double, maxX : double, stepX : double) -> [[string]];

	getWigiRangeA1CellNames(left : string, right : string) -> [[string]];
	getWigiRangeA1CellNames2(range : string) -> [[string]];
	getDoubleTextClipped(text : string) -> string;
	getPrepareDotplotData(data : [[string]]) -> [[string]];
	getPrepareHistogramData(data : [[string]]) -> [[string]];
	getPrepareHistogramClassesData(data : [[string]], minX : double, maxX : double, stepX : double) -> [[string]];
	getPrepareBoxplotData(data : [[string]]) -> [[string]];
	getPrepareScatterplotData(data : [[string]]) -> [[string]];
	getPrepareStackedBarData(data : [[string]]) -> [[string]];
	wrongNumberOfArgumentsError(l : int, expectedLength : int) -> WigiError;
	wigiNotImplemented(componet : string) -> WigiError;
}

// [[1,2], [3,4]] -> [1,2,3,4]
wigiTemplateFlattenArray(vs : [WigiValue]) -> [WigiValue] {
	isRangeArrElement = \v -> {
		switch(v) {
			WigiArray(ar) : true;
			default : false
		}
	}

	if (forall(vs, isRangeArrElement)) {
		concatA(map(vs, \a -> {
			switch(a) {
				WigiArray(ar) : ar;
				default : [];
			}
		}))
	} else vs
}

wrongNumberOfArgumentsError(l : int, expectedLength : int) -> WigiError {
	WigiError("Wrong number of arguments. Expected " + i2s(expectedLength) + ", but got " + i2s(l))
}

// - Returns first argument if it's int or double
// - Calls 'fn' if first argument is array (of ints or doubles)
//
//		fn(flatten_items_of_the_first_argument, rest_of_the_arguments)
//
wigiTemplateStatFunction(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue {
	if (length(l) != args) wrongNumberOfArgumentsError(length(l), args)
	else {
		switch (l[0]) {
			WigiArray(vs): wigiTemplateStatFunctionForArray(vs, tail(l), fn, false);
			WigiDouble(d): l[0];
			WigiInt(v): l[0];
			default : WigiError("Invalid type of first argument. Expected: WigiArray, WigiDouble or WigiInt")
		}
	}
}

// - Returns first argument if it's int, double or string
// - Calls 'fn' if first argument is array (of ints, doubles or strings)
//
//		fn(flatten_items_of_the_first_argument, rest_of_the_arguments)
//
wigiTemplateStatFunction1(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue {
	if (length(l) != args) wrongNumberOfArgumentsError(length(l), args)
	else {
		switch (l[0]) {
			WigiArray(vs): wigiTemplateStatFunctionForArray(vs, tail(l), fn, true);
			WigiDouble(__): l[0];
			WigiInt(__): l[0];
			WigiString(__): l[0];
			default : WigiError("Invalid type of first argument. Expected: WigiArray, WigiDouble or WigiInt")
		}
	}
}

// - Calls 'fn' if first argument is array (of ints or doubles)
//
//		fn(flatten_items_of_the_first_argument, rest_of_the_arguments)
//
wigiTemplateStatFunction2(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue {
	if (length(l) != args) wrongNumberOfArgumentsError(length(l), args)
	else {
		switch (l[0]) {
			WigiArray(vs): wigiTemplateStatFunctionForArray(vs, tail(l), fn, false);
			default : WigiError("Invalid type of first argument. Expected: WigiArray")
		}
	}
}

wigiTemplateStatFunctionForArray(firstArgumentItems : [WigiValue], restOfArguments : [WigiValue], fn : ([WigiValue], [WigiValue]) -> WigiValue, supportStrings : bool) -> WigiValue {
	if (length(firstArgumentItems) == 0) WigiError("The first argument is empty.")
	else {
		firstArgumentItems2 = wigiTemplateFlattenArray(firstArgumentItems);

		isValidArrElement = \v -> {
			switch(v) {
				WigiInt(__) : true;
				WigiDouble(__) : true;
				WigiString(__): supportStrings;
				WigiRecord(__): true;
				default : false
			}
		}

		if (forall(firstArgumentItems2, isValidArrElement) && forall(restOfArguments, isValidArrElement)) fn(firstArgumentItems2, restOfArguments)
		else WigiError("Invalid type of arguments. [1]")
	}
}

// - Calls 'fn' for flatten array of arguments (of ints, doubles or strings that are doubls)
//
//		fn(flatten_items_of_the_all_arguments)
//
wigiTemplateStatFunction3(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue {
	if ((args != -1) && length(l) != args) wrongNumberOfArgumentsError(length(l), args)
	else {
		isValidArrElement = \v -> {
			switch (v) {
				WigiInt(__) : true;
				WigiDouble(__) : true;
				WigiString(s) : {
					r = s2d(s);
					s == d2s(r)
				}
				default : false
			}
		}

		arr = concatA(map(l, \v -> {
			switch (v) {
				WigiArray(ar) : wigiTemplateFlattenArray(ar);
				default : [v];
			}
		}));

		if (forall(arr, isValidArrElement)) fn(arr)
		else WigiError("Invalid type of arguments. [2]")
	}
}

wigiTemplateMatrixFunction(l : [WigiValue], args : int, fn : ([WigiValue], [WigiValue]) -> WigiValue) -> WigiValue {
	if (length(l) != args) wrongNumberOfArgumentsError(length(l), args)
	else {
		switch (l[0]) {
			WigiArray(vs): {
					colCount = length(vs);
					if (colCount == 0) WigiError("The first argument is empty.")
					else {
							isRangeArrElement = \v -> {
								switch(v) {
									WigiArray(ar) : true;
									default : false
								}
							}

							arr = if (forall(vs, isRangeArrElement)) {
										generate(0, colCount, \i -> map(vs, \a -> {
											switch(a) {
												WigiArray(ar) : ar[i];
												default : WigiError("Invalid range");
											}
										}))
								}
								else [];

							if (arr == []) WigiError("Invalid range")
							else {

								isValidArrElement = \v -> {
									switch(v) {
										WigiInt(rv) : true;
										WigiDouble(rd) : true;
										default : false
									}
								}
								arg = tail(l);

								if (forall(concatA(arr), isValidArrElement) && forall(arg, isValidArrElement))
									fn(map(arr, \a -> WigiArray(a)), arg)
								else
									WigiError("Invalid type of arguments. [3]");
							}
					}
				}
			default : WigiError("Invalid type of first argument. Expected: WigiArray")
		}
	}
}

wigiTemplateCommonFunction(
	l : [WigiValue],
	args : int,
	fn : ([WigiValue]) -> WigiValue,
	validArrElementFn : (WigiValue) -> bool
) -> WigiValue {

	if ((args != -1) && (length(l) != args)) {
		wrongNumberOfArgumentsError(length(l), args)
	} else if (forall(l, validArrElementFn)) {
		fn(l)
	} else WigiError("Invalid type of arguments. [4]")
}



wigiTemplateTextFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue {
	wigiTemplateCommonFunction(l, args, fn, \v -> switch(v) {
		WigiBool(__) : true;
		WigiDouble(__): true;
		WigiInt(__): true;
		WigiString(__): true;
		WigiArray(__): true;
		WigiRecord(__): true;
		default : false
	})
}


wigiTemplateLogicalFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue {
	wigiTemplateCommonFunction(l, args, fn, \v -> switch(v) {
		// These types are supported by getWigiBool
		WigiBool(__) : true;
		WigiDouble(__): true;
		WigiInt(__): true;
		WigiString(s): true;
		WigiArray(vs): true;
		WigiElementValue(e): true;
		WigiBuiltInName(n): true;
		WigiRecord(fs): true;

		WigiDefaultValue(): false; 
		WigiLambda(__, body): false; 
		WigiDate(y, m, d): false;
		WigiTime(h, m, s): false;
		WigiError(m): false;
	})
}

wigiTemplateMathFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue {
	wigiTemplateCommonFunction(l, args, fn, \v -> switch(v) {
		WigiInt(__) : true;
		WigiDouble(__) : true;
		default : false
	})
}

wigiTemplateDateFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue {
	wigiTemplateCommonFunction(l, args, fn, \v -> switch(v) {
		WigiString(__) : true;
		WigiDate(__, __, __) : true;
		WigiInt(__) : true;
		WigiDouble(__) : true;
		default : false
	})
}

wigiTemplateIntFunction(l : [WigiValue], args : int, fn : ([WigiValue]) -> WigiValue) -> WigiValue {
	wigiTemplateCommonFunction(l, args, fn, \v -> switch(v) {
		WigiInt(__) : true;
		WigiDouble(val) : i2d(trunc(val)) == val;
		default : false
	})
}

getWigiText(l : WigiValue) -> string {
	switch (l: WigiValue) {
		WigiBool(b): b2s(b);
		WigiDouble(v): d2s(v);
		WigiInt(v): i2s(v);
		WigiString(s): s;
		WigiRecord(fields): superglue(fields, \f : Pair<string, WigiValue> -> getWigiText(f.second), "\n");
		WigiArray(values): superglue(values, getWigiText, "\n");
		default : "";
	}
}

isRangeVariable(name : string) -> bool {
	if (strlen(name) < 2) false
	else if (strlen(name) == 2) isLetter(strLeft(toUpperCase(name), 1)) && isDigit(substring(name, 1, 1))
	else {
			isLetter(strLeft(toUpperCase(name), 1))
		&& (isLetter(substring(toUpperCase(name), 1, 1)) || isDigit(substring(name, 1, 1)))
		&& isDigits(strRight(name, 2))
	}
}

isStringDouble(s : string) -> bool {
	pointCnt = strCountOf(s, ".");
	minusCnt = strCountOf(s, "-");
	isStringDouble0(s, 0, strlen(s)) && (pointCnt == 0 || pointCnt == 1) && (minusCnt == 0 || minusCnt == 1)
}

isStringDouble0(s : string, index : int, len : int) -> bool {
	if (index < len) isDoubleChar(getCharAt(s, index)) && isStringDouble0(s, index+1, len) else len > 0
}

isCircularReferenceExpr(e : WigiExpr, name : string) -> bool {
	switch (e : WigiExpr) {
		WigiVarRef(x): name == x;
		WigiCellRefA1(x): name == x;
		WigiCall(fn, args): {
			fold(args, false, \a, b -> a || isCircularReferenceExpr(b, name));
		}
		WigiIf(condition, then, else_): {
			isCircularReferenceExpr(condition, name) ||
			isCircularReferenceExpr(then, name) ||
			isCircularReferenceExpr(else_, name);
		}
		WigiArray(exprs): {
			fold(exprs, false, \a, b -> a || isCircularReferenceExpr(b, name));
		}
		WigiSequence(exprs): {
			fold(exprs, false, \a, b -> a || isCircularReferenceExpr(b, name));
		}
		WigiLambda(args, body): {
			isCircularReferenceExpr(body, name);
		}
		WigiRangeA1(start, end): {
			l = start.x;
			r = end.x;
			contains(concatA(getWigiRangeA1CellNames(l, r)), name);
		}
		/*
		TODO: This is missing
		WigiRangeRC(start, end): {
			contains(concatA(getWigiRangeA1CellNames(l+":"+r)), name);
		}
		*/
		default: false;
	}
}

isDoubleChar(s : string) -> bool {
	isDigit(s) || (s == ".") || (s == "-")
}

getStep(arr : [double]) -> double {
	len = length(arr);
	if (len <= 1) 1.0
	else fold(mapi(arr, \i, v -> abs(if (i+1 >= len) arr[i-1] - v else v - arr[i+1])), doubleMax, min);
}

getPlotStrokes(minV : double, maxV : double, step : double, acc : [double]) -> [double] {
	newElem = minV + step;

	if (newElem > maxV) acc
	else getPlotStrokes(newElem, maxV, step, arrayPush(acc, newElem));
}

getLeftPlotStrokes(minV : double, maxV : double, step : double, acc : [double]) -> [double] {
	newElem = maxV - step;

	if (newElem < minV) sort(acc)
	else getLeftPlotStrokes(minV, newElem, step, arrayPush(acc, newElem));
}

getWigiRangeData(range : WigiValue) -> [[string]] {
	switch(range) {
		WigiArray(v) : {
			if (forall(v, \f -> switch(f) {
					WigiArray(wa) : true;
					default : false;
				})) {
				map(v, \m -> {
					switch(m) {
						WigiArray(wa) : map(wa, \w -> {
											switch(w) {
												WigiInt(wi) : i2s(wi);
												WigiDouble(wd) : d2s(wd);
												WigiString(ws) : ws;
												WigiError(we) : we;
												default : "";
											}
										});
						default : []
					}
				});
			}
			else [[]];
		}
		default : [[]];
	}
}

getWigiRangeA1CellNames(left : string, right : string) -> [[string]] {

	shift = 64;
	colCount = 26;

	getColIndex = \colrow : string -> {
		if(strlen(colrow)==2) s2a(strLeft(colrow, 1))[0]-shift
		else {
			if (isLetter(substring(colrow,1,1))) {
				v = s2a(strLeft(colrow, 2));
				(v[0]-shift)*colCount+(v[1]-shift)
			}
			else s2a(strLeft(colrow, 1))[0]-shift
		}
	}

	getRowIndex = \colrow : string -> {
		if (isLetter(substring(colrow,1,1))) s2i(strRight(colrow, 2))
		else s2i(strRight(colrow, 1))
	}

	getColumn = \colIndex : int -> {
		v = i2d(colIndex)/i2d(colCount);
		if (v<=1.0) fromCharCode(colIndex+shift)
		else {
			t = trunc(v);
			idx1 = if(v == i2d(t)) t-1 else t;
			idx2 = colIndex-idx1*colCount;
			fromCharCode(idx1+shift)+fromCharCode(idx2+shift)
		}
	}

	generate(getColIndex(left), getColIndex(right)+1, \cl -> {
		generate(getRowIndex(left), getRowIndex(right)+1, \rw -> getColumn(cl)+i2s(rw))
	})
}

getWigiRangeA1CellNames2(range : string) -> [[string]] {
	_range = strSplit(getRangeElement(range).second, ":");

	if (length(_range) != 2) [[]]
	else {
		left = toUpperCase(_range[0]);
		right = toUpperCase(_range[1]);

		if (isRangeVariable(left) && isRangeVariable(right)) getWigiRangeA1CellNames(left, right)
		else [[]]
	}
}

valueListBoxplotSynchronize(range : WigiValue, list : [[string]]) -> [[string]] {
	rangeList = getWigiRangeData(range);

	if (rangeList == [[]]) list
	else {
		newList = getPrepareBoxplotData(rangeList);
		if (newList == [[]]) list
		else newList;
	}
}

valueListScatterplotSynchronize(range : WigiValue, list : [[string]]) -> [[string]] {
	rangeList = getWigiRangeData(range);

	if (rangeList == [[]]) list
	else {
		newList = getPrepareScatterplotData(rangeList);
		if (newList == [[]]) list
		else newList;
	}
}

valueListHistogramClassesSynchronize(range : WigiValue, list : [[string]], minX : double, maxX : double, stepX : double) -> [[string]] {
	rangeList = getWigiRangeData(range);

	if (rangeList == [[]]) list
	else {

		newList = getPrepareHistogramClassesData(rangeList, minX, maxX, stepX);

		if (newList == [[]]) list
		else newList;
	}
}

getPrepareHistogramClassesData(data : [[string]], minX : double, maxX : double, stepX : double) -> [[string]] {
	if (forall(data[0], isStringDouble)) {
		u = map(sortUnique(map(data[0], s2d)), d2s);
		minV = minX;
		maxV = if (maxX == 0.0) s2d(u[length(u)-1]) else maxX;
		varX = getPlotStrokes(minV, maxV, stepX, [minV]);
		varX_ = subrange(varX, 0, length(varX)-1);
		varY = mapi(varX_, \index, m -> {
			i2s(fold(data[0], 0, \a, b -> if (m<s2d(b) && s2d(b)<=varX[index+1]) a+1 else a));
		});
		[map(varX, d2s), arrayPush(varY, varY[length(varY)-1])]
	}
	else [[]];
}

getPrepareHistogramData(data : [[string]]) -> [[string]] {
	if (forall(data[0], isStringDouble)) {
		u = map(sortUnique(map(data[0], s2d)), d2s);
		[u, map(u, \p -> i2s(countA(data[0], \a -> a == p)))];
	}
	else [[]];
}

getPrepareDotplotData(data : [[string]]) -> [[string]] {
	if (length(data) == 1) {
		if (forall(data[0], isStringDouble)) {
			u = map(sortUnique(map(data[0], s2d)), d2s);
			[u, map(u, \p -> i2s(countA(data[0], \a -> a == p)))]
		}
		else [[]]
	}
	else {
		if (forall(data[1], isStringDouble)) data
		else [[]];
	}
}

getPrepareBoxplotData(data : [[string]]) -> [[string]] {
	if (forall(concatA(data), isStringDouble)) {
		map(data, \m -> {
			dbl_arr = sort(map(m, s2d));
			map(dbl_arr, d2s);
		})
	}
	else [[]];
}

getPrepareScatterplotData(data : [[string]]) -> [[string]] {
	if (forall(concatA(data), isStringDouble)) {
		arr = sort(mapi(data[0], \idx, v -> Pair(s2d(v), s2d(data[1][idx]))));
		graph1 = Pair(map(arr, \v -> d2s(v.first)), map(arr, \v -> d2s(v.second)));
		if (length(data) == 2) [graph1.first, graph1.second]
		else {
			arr2 = sort(mapi(data[2], \idx, v -> Pair(s2d(v), s2d(data[3][idx]))));
			graph2 = Pair(map(arr2, \v -> d2s(v.first)), map(arr2, \v -> d2s(v.second)));
			if (length(data) == 4) [graph1.first, graph1.second, graph2.first, graph2.second]
			else {
				arr3 = sort(mapi(data[4], \idx, v -> Pair(s2d(v), s2d(data[5][idx]))));
				graph3 = Pair(map(arr3, \v -> d2s(v.first)), map(arr3, \v -> d2s(v.second)));
				[graph1.first, graph1.second, graph2.first, graph2.second, graph3.first, graph3.second]
			}
		}
	}
	else [[]];
}

getPrepareStackedBarData(data : [[string]]) -> [[string]] {
	if (forall(concatA(tail(data)), isStringDouble)) data
	else [[]];
}

getDoubleTextClipped(text : string) -> string {
	if (isStringDouble(text)) {
		str = strSplit(text, ".");
		if (length(str) == 1) text
		else {
			if (strlen((str[1])) > 3) str[0] + "." + strLeft(str[1], 3)
			else text
		}
	}
	else text
}

getRangeElement(range : string) -> Pair<string, string> {
	pos = strIndexOf(range, "!");
	if(pos == -1) Pair("", range)
	else Pair(strLeft(range, pos), strRight(range, pos+1))
}

valueListSynchronize(range : WigiValue, list : [[string]]) -> [[string]] {
	rangeList = getWigiRangeData(range);

	if (rangeList == [[]]) list
	else {

		varList = if (length(rangeList) == 1) {
			[sort(concatA(mapi(list[0], \i, l -> generate(0, s2i(list[1][i]), \inx -> l))))]
		} else list;

		if (length(rangeList) == 1) {

			l = mapi(varList[0], \row, cell -> {
						if (isStringDouble(cell) && isStringDouble(rangeList[0][row])) {
							if (s2d(cell) != s2d(rangeList[0][row])) rangeList[0][row]
							else cell
						}
						else cell;
					});

			u = map(sortUnique(map(l, s2d)), d2s);
	 		[u, map(u, \p -> i2s(countA(l, \a -> a == p)))]
		}
		else {
			l = mapi(varList[1], \row, cell -> {
				if (isStringDouble(cell) && isStringDouble(rangeList[1][row])) {
					if (s2d(cell) != s2d(rangeList[1][row])) rangeList[1][row]
					else cell
				}
				else cell;
			});
			[varList[0], l]
		}
	}
}

valueListStackedBarSynchronize(range : WigiValue, list : [[string]]) -> [[string]] {
	isValXString = !forall(list[0], isStringDouble);

	rangeList = getWigiRangeData(range);

	if (rangeList == [[]]) list
	else {
		newList = getPrepareStackedBarData(rangeList);
		if (newList == [[]]) list
		else if (isValXString) concat([list[0]], tail(newList))
		else newList;
	}
}

wigiNotImplemented(componet : string) -> WigiError {
	WigiError("Sorry, " + componet + " not implemented yet!");
}
