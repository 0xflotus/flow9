import wigi/clipboard;
import wigi/basic_controller;
import wigi/undo;
import wigi/table_selection;
import wigi/table_control;
import wigi/symbols;
import wigi/replace;
import wigi/paragraph_preparation;
import wigi/calculated_cell;
import wigi/testcaserecorder_api;
import formula_plumbing;

export {
	// Send this event to the element that owns the cursor
	wigiSendEvent(state : WigiEditorState, event : WigiEvent) -> bool;

	wigiMoveCursor(state : WigiEditorState, delta : int, selecting : bool) -> void;

	wigiMoveCursorByWord(state : WigiEditorState, toRight : bool, selecting : bool, wordStartPos : bool) -> void;

	wigiSetCursor(state : WigiEditorState, path : [int], selecting : bool) -> void;

	// Sometimes we know the display has changed, and we need to redraw the cursor
	wigiUpdateCursor(state : WigiEditorState) -> void;

	// Move the cursor up the hierarchy to a parent cell that wants it
	wigiCursorToCell(state : WigiEditorState) -> void;

	// Is the current cursor a cell cursor?
	isCellCursor(state : WigiEditorState) -> bool;

	// Figures out position so that it points to a valid element and doesn't cause troubles
	positionCursorInElement(root: WigiElement, position: [int]) -> [int];

	wigiInsertText(state : WigiEditorState, text : string) -> void;

	wigiDeleteCharacter(state : WigiEditorState) -> void;

	wigiNewParagraph(state: WigiEditorState, position: [int]) -> void;

	deleteSelection(state : WigiEditorState) -> bool;
	deleteSelection2(state : WigiEditorState, deleteEmptyRecursive : bool) -> bool;

	// Cursor positioning
	wigiSetCursor(state : WigiEditorState, pos : [int], selecting : bool) -> void {
		wigiSetCursor2(state, pos, selecting, true);
	}
	wigiSetCursor2(state : WigiEditorState, pos : [int], selecting : bool, cleanEmptyRecursives : bool) -> void {
		wigiSetCursor3(state, pos, selecting, cleanEmptyRecursives, true);
	}
	wigiSetCursor3(state : WigiEditorState, pos : [int], selecting : bool, cleanEmptyRecursives : bool, scrollView : bool) -> void;

	// Extracts the given range, as well as the path to that element
	extractWigiRange(root : WigiElement, start : [int], end : [int]) -> WigiElement;

	// Paste something into specified position
	pasteWigi(state: WigiEditorState, position: [int], content: WigiElement, moveCursor: bool) -> void;
	pasteWigiAndNormalize(state: WigiEditorState, position: [int], content: WigiElement, moveCursor: bool) -> void;

	getTextStyleFromToolbar(state: WigiEditorState) -> [WigiTextStyle];

	// Paste either what we get from the system clipboard, or our internal clipboard if the system is empty
	wigiPaste(state: WigiEditorState, systemClipboard : string, spacing : Maybe<ParagraphSpacing>) -> void;

	maybeGetParentWigiParagraph(root: WigiElement, position: [int]) -> Maybe<Pair<WigiParagraph, [int]>>;
	maybeGetNextElementFontSize(defStyle : [WigiStyles], root: WigiElement, path : [int]) -> Maybe<double>;
	maybeGetParentWigiStory(root: WigiElement, position: [int]) -> Maybe<Pair<WigiStory, [int]>>;

	joinParagraphs(p1: WigiElement, p2: WigiElement) -> WigiParagraph;
	incParagraphNumbered(style : [WigiParagraphStyle]) -> [WigiParagraphStyle];

	// Switch editor font
	switchEditorFontFamily(state : WigiEditorState, style: FontFamilyStyle) -> void;

	// Return name, for example "A1", from WigiName style of WigiSpreadsheetCell for all nested objects
	getSpreadSheetCellA1Name(doc: WigiElement, path: [int]) -> WigiCellRefA1;

	// Deletes `path` element from it's containing paragraph preserving cursor position
	deleteElementSafely(state: WigiEditorState, path: [int]) -> void;

	makeWigiRadioOptionContent(layout: WigiRadioOptionAlign, frameM: Maybe<WigiFrame>, button: [WigiElement], otherElements: [WigiElement], paragraphStyle : [WigiParagraphStyle]) -> WigiElement;
	maybeGetParentRadioOption(root: WigiElement, position: [int]) -> Maybe<Triple<WigiRecursive, WigiRadioOption, [int]>>;
	maybeGetWigiRadioOptionProperties(recursive: WigiRecursive) -> Maybe<WigiRadioOptionProperties>;

	wigiChangeTable(s : WigiEditorState, event : WigiTableEvent) -> bool;

	changeFirstLineIndent(state : WigiEditorState, shift : bool) -> void;
	changeGeneralIndent(state : WigiEditorState, shift : bool) -> void;
	changeWigiParagraphIndent(state : WigiEditorState, shift : bool) -> void;

	findParentParagraph(root: WigiElement, position: [int]) -> [int];

	setCursorInFirstWigiTextOfParagraph(state : WigiEditorState) -> void;

	showNaturalMathEditor(caption : string, formula : string, onOK : (string) -> void) -> void;

	useTransformMatrixPositioning = isUrlParameterTrue("tm");

	getWigiTextStyle(wigiStyle : [WigiStyle]) -> [WigiTextStyle];
}

doWigiSendEvent(state : WigiEditorState, event : WigiEvent) -> WigiSendEventResult {
	^maybeRecordWigiEvent(event);
	view = getValue(state.editorView);
	stateBeforeEvent = stateForUndoStack(state, event);
	sendResult = doSendEvent(view, state, getValue(state.cursor), event);

	afterAction = \handled : bool -> {
		addToUndoStack(state, stateBeforeEvent, event, handled);

		state.modified := canEventModifyState(event);
		updateLiveSerializedDocument(state, getValue(state.document));
	}

	switch (sendResult) {
		WigiSendEventResultWaitCompleted(handled, completed): {
			completed := \ -> afterAction(handled);
		}
		WigiSendEventResultDeferred(handled): deferred(\ -> afterAction(handled));
		WigiSendEventResultImmediate(handled): afterAction(handled);
	}

	sendResult
}

wigiSendEventInternal(state : WigiEditorState, event : WigiEvent) -> WigiSendEventResult {
	if (isEnabledEvent(state, event)){
		eitherFn(getValue(state.formulaEditor),
			\fe -> WigiSendEventResultImmediate(fe.handleEvent(event)),
			\ -> doWigiSendEvent(state, event))
	} else {
		WigiSendEventResultImmediate(true);
	}
}

wigiSendEvent(state : WigiEditorState, event : WigiEvent) -> bool {
	handled = if (isEventAllowed(state, event)) wigiSendEventInternal(state, event).handled else false;
	if (handled) deferUntilRender(\ -> wigiUpdateCursor(state));
	handled
}

doSendEvent(view : WigiView, state: WigiEditorState, path : [int], event : WigiEvent) -> WigiSendEventResult {
	cursorView = view.getWigiView(path, view);
	if (cursorView.handleEvent(event)) {
		// println(toString(event) + " handled at " + toString(path));
		WigiSendEventResultImmediate(true);
	} else {
		if (path != []) {
			// Try to send to our parent
			doSendEvent(view, state, wigiParentPath(path), event);
		} else {
			commonEventHandler(state, event);
		}
	}
}

isRecursiveWithMathPlaceholder(element : WigiElement) -> bool {
	switch (element : WigiElement) {
		WigiRecursive(__, type, __): {
			switch (type : WigiRecursiveType) {
				WigiFraction(): true;
				WigiRoot(): true;
				WigiLongDivision(): true;
				WigiSupscript(): true;
				WigiSubscript(): true;
				WigiSupSubscript(): true;
				WigiOverscript(): true;
				WigiUnderscript(): true;
				WigiOverlay(): true;
				WigiBrackets(__, __): true;
				WigiDottedElement(__, __, __, __, __, __): true;
				WigiProduct(): true;
				WigiSum(): true;
				WigiIntegral(): true;
				WigiIntegral2(__): true;
				WigiTopModificator(__, __): true;
				WigiExternalRecursive(exType, __): exType == "material_math_element";
				WigiComap(__): false;
				WigiEvaluatingIntegral(): false;
				WigiTable(__, __, __, __): false;
				WigiInteractiveTable(__, __, __): false;
				WigiTableCell(__, __): false;
				WigiSpreadsheetCell(__, __, __): false;
				WigiFrame(__, __, __): false;
				WigiCode(__, __): false;
				WigiTyped(__): false;
				WigiButton(__, __): false;
				WigiHyperlink(__): false;
				WigiAltText(): false;
				WigiRadioOption(__, __): false;
				WigiVisible(__): false;
				WigiVersions(__): false;
			}
		}
		default: {
			false;
		}
	}
}

getParentRecursiveWithMathPlaceholder(root : WigiElement, path : [int]) -> [int] {
	if (isRecursiveWithMathPlaceholder(getElementAtPosition(root, path)) || path == []) path
	else getParentRecursiveWithMathPlaceholder(root, wigiParentPath(path));
}

removeMathPlaceholder(state: WigiEditorState) -> void {
	document = getValue(state.document);
	cursor = getValue(state.cursor);
	nextPosition = doPositionDelta(document, cursor, 1);

	if (isWigiBlock(getElementAtPosition(document, nextPosition), [WigiExternalBlock("material_placeholder", makeTree())])) {
		if (isWigiEmptyText(getElementAtPosition(document, cursor))) {
			wigiSetCursor(state, nextPosition, false);
		}

		wigiSendEvent(state, WigiRightWord(true));
		ignore(deleteSelection2(state, true));
	}
}

// paste system clipboard's string first, if it is empty - paste from local clipboard
wigiPaste(state: WigiEditorState, systemClipboard : string, spacing : Maybe<ParagraphSpacing>) -> void {
	pasteElement = \element : WigiElement -> {
		selection = getValue(state.selection);
		// First, delete selection
		deleteSelection(state);	// TODO: This might delete the whole element and make us paste later into some other place

		// If we had multi cell selection, will insert text to each cell
		root = getValue(state.document);

		isCoachTextEditor = contains(^(state.toolbarStyle), CoachMenuStyle());

		applyToSelection(root, getValue(state.cursor), selection, \path -> {
			nelement = applyallWigiElement(element, getSpreadSheetCellA1Name(root, path), \currentCell : WigiCellRefA1, el : WigiElement -> {
				switch(el) {
					WigiText(text, style): {
						styleFilter = {
							if (isCoachTextEditor) \s0 -> removeAllStructs(removeAllStructs(s0, FontFamily("Book")), dwfs)
							else idfn
						};
						textWithReplacedRefs =
							if (wigiFindParentRecursive(root, [dummyWigiSpreadsheetCell], path) == []) {
								text
							} else {
								convertRefToA1(text, currentCell)
							}
						WigiText(textWithReplacedRefs, styleFilter(style));
					};
					WigiParagraph(elements, style): {
						WigiParagraph(
							elements,
							if (isCoachTextEditor) {
								[]
							} else {
								if (getParentRecursiveWithMathPlaceholder(root, path) != []) {
									subtractA(style, alignStyles);
								} else {
									style
								}
							}
						)
					};
					WigiBlock(type, style): {
						switch (type) {
							WigiExternalBlock(extType, content) : {
								eitherMap(
									getExternalBlockAPI(extType),
									\api -> {
										contentCorrector = extractStruct(
											api.style,
											CustomOnPastingContentCorrector(\oldContent, engine -> oldContent)
										).fn;
										WigiBlock(
											WigiExternalBlock(extType, contentCorrector(content, state.engine)),
											style
										)
									},
									el
								)
							};
							default : el
						}
					}
					default: el;
				}
			});
			// Because element in clipboard can have some refs in it, we would like to insert a clear copy of it!
			pasteWigiAndNormalize(state, path, wigiForStorage(nelement, false), true);
		})
	}

	maybeGetWigiElementFromSystem = \-> maybeMap(
		maybeGetWigiElement(systemClipboard),
		\p -> {
			if (p.second != []) warningBox(strGlue(p.second, "\n"));
			// rename all formulas elements inside the current element
			applyFn2WigiElement(p.first, [], getDefaultStateScope(^(state.engine.env)).names, false,
				\__, el, ns -> renameDuplicateElement(state, checkLocksInWigiElement(state.lock.status, el))
			);
		}
	);

	tryPasteAsWigi = \eM -> {
		eitherFn(eM, pasteElement,
			\-> eitherFn(
				maybeGetWigiElementFromSystem(),
				pasteElement,
				\-> {
					paragraphs = strSplit(systemClipboard, "\n");
					count = length(paragraphs);

					iteri(paragraphs, \i, p -> {
						wigiInsertText(state, p);
						if (i < count - 1) wigiNewParagraph(state, getValue(state.cursor));
					});

					maybeApply(spacing, \s -> {
						// actually, this is artificially event so we don't want it to be recorded or the tests will be useless
						testCaseRecorderSuspend();
						nextDistinct(state.paragraphSpacing, s.d);
						wigiSendEventInternal(state, WigiSetStoryStyle([], [ParagraphSpacing(s.d)]));
						testCaseRecorderResume();
					})
				}
			)
		)
	};

	clipboard = getValue(state.clipboard);
	handleAndPasteElement = extractStruct(
		state.wigiEditorStyle,
		WigiEditorCustomPaste(\__, __, __ -> {
			if(systemClipboard == "")
				maybeApply(clipboard, pasteElement)
			else
				tryPasteAsWigi(None())
		})
	).customPasteFn;

	removeMathPlaceholder(state);

	handleAndPasteElement(
		if (isSome(clipboard)) clipboard else maybeGetWigiElementFromSystem(),
		systemClipboard,
		tryPasteAsWigi
	);
}

// Where to place selection and where to set cursor after inserting recursive
getRecursivePlaces(type : WigiRecursiveType) -> Pair<int, int> {
	switch(type) {
		WigiBrackets(__, __): Pair(0, 0);
		WigiComap(__): Pair(0, 0);
		WigiDottedElement(__, __, __, __, __, __): Pair(0, 0);
		WigiFraction(): Pair(0, 1);
		WigiProduct(): Pair(2, 0);
		WigiEvaluatingIntegral(): Pair(0, 0);
		WigiRoot(): Pair(1, 0);
		WigiLongDivision(): Pair(0, 0);
		WigiIntegral(): Pair(2, 0);
		WigiIntegral2(__): Pair(1, 0);
		WigiTopModificator(__, __): Pair(0, 0);
		WigiSum(): Pair(2, 0);
		WigiSupscript(): Pair(0, 1);
		WigiSubscript(): Pair(0, 1);
		WigiSupSubscript() : Pair(0, 1);
		WigiOverscript(): Pair(0, 1);
		WigiUnderscript(): Pair(0, 1);
		WigiOverlay(): Pair(1, 0);
		WigiAltText(): Pair(0, 0);
		WigiTable(__, __, __, __): Pair(0, 0);
		WigiInteractiveTable(__, __, __): Pair(0, 0);
		WigiTableCell(__, __): Pair(0, 0);
		WigiSpreadsheetCell(__, __, __): Pair(0, 0);
		WigiFrame(__, __, __): Pair(0, 0);
		WigiCode(sc, sr): Pair(0, 0);
		WigiTyped(typ): Pair(0, 0);
		WigiButton(__, __): Pair(0, 0);
		WigiHyperlink(__): Pair(0, 0);
		WigiRadioOption(__, __): Pair(0, 0);
		WigiVisible(__): Pair(0, 0);
		WigiVersions(__): Pair(0, 0);
		WigiExternalRecursive(__, __): Pair(0, 0);
	}
}

// Common event handler that handles things regardless of view
commonEventHandler(state: WigiEditorState, event: WigiEvent) -> WigiSendEventResult {

	executeLongTextChange : (() -> void, bool) -> WigiSendEventResult  = \change, updCursor -> {
		action = \ -> executeWigiEditorChange(
			state,
			change,
			if (updCursor) {
				// if the paragraph is changed, the physical coordinates of the cursor could be
				// determined only after render is completed because of optimizations in renderParagraph
				// so we have to force update of cursor coordinates here (it is deffered call)
				\ -> wigiUpdateCursor(state)
			} else {
				nop
			},
			!isTestCaseRecorderPlaybackMode()
		);

		if (js) {
			deferred(action);
			WigiSendEventResultDeferred(true);
		} else {
			action();
			WigiSendEventResultImmediate(true);
		}
	}

	sendResult : WigiSendEventResult = switch (event: WigiEvent) {
		WigiInsertText(text): {
			// To prevent view height changes caused by text inserting we need to put
			// wigiInsertText calls inside executeWigiEditorChange.
			// Otherwise these height changes lead to unexpected behaviour of scrolls.
			if (js) {
				// in js if we inserted immediately, content of paragraph with dynamic elements would jump around
				// typing the text by hand in editor looks like symbol-by-symbol process and it leads to great overhead and time lag
				// so in js we buffer input and handle it in deferred manner at once
				if (^(state.insertTextBuffer) == "") {
					state.insertTextBuffer := ^(state.insertTextBuffer) + text;

					deferred(\ -> {
						buffer = ^(state.insertTextBuffer);
						state.insertTextBuffer := "";
						next(state.cursorWantThisX, -1.0);
						executeWigiEditorChange(
							state,
							\ -> wigiInsertText(state, buffer),
							nop,
							false
						);
					});
				} else {
					state.insertTextBuffer := ^(state.insertTextBuffer) + text;
				}
				WigiSendEventResultDeferred(true);
			} else {
				next(state.cursorWantThisX, -1.0);
				executeWigiEditorChange(
					state,
					\ -> wigiInsertText(state, text),
					nop,
					false
				);
				WigiSendEventResultImmediate(true);
			}
		}
		WigiInsertElement(el): {
			insertWigiElement(state, cloneWigiElement(el));
			WigiSendEventResultImmediate(true);
		}
		WigiSelectAll(): {
			document = getValue(state.document);
			if (isLockEditAllowed(state) || isUnlockedWigiElement(document)){
				wigiSetCursor(state, getStartPositionOfDocument(document), false);
				wigiSetCursor(state, getEndPositionOfDocument(document, false), true);
			}
			WigiSendEventResultImmediate(true);
		}

		WigiSelectWord(): {
			makeWholeWordSelection(state);
			WigiSendEventResultImmediate(true);
		}

		WigiSelectSentence(): {
			makeSentenceSelection(state);
			WigiSendEventResultImmediate(true);
		}

		WigiCopy(formatting): {
			document = getValue(state.document);
			cursor = getValue(state.cursor);
 			selection = getValue(state.selection);
 			isCell = isCellCursor(state);

			applyConvertRefToRC = \range : WigiElement, sel_start : [int] -> {
				if (wigiFindParentRecursive(document, [dummyWigiSpreadsheetCell], sel_start) != []) {
					applyallWigiElement(range, getSpreadSheetCellA1Name(document, sel_start), \currentCell, element -> {
	 					switch(element) {
	 						// Update all cell references to be relative to our current cell
	 						WigiText(text, style): WigiText(convertRefToRC(text, currentCell), style);
	 						default: element;
	 					}
					})
				} else {
					range;
				}
			}

			copyContent = \start, end -> {
				rangeRC = normalizeWigiDocument(applyConvertRefToRC(extractWigiRange(document, start, end), start));
				mode = if (formatting) {
					if (isCell) PreserveFormatting()
					else TryToSimplifyToPlainText()
				} else PlainText();
				copyToClipboards(state, Some(rangeRC), mode);
			}

			if (!isEmptySelection(selection)) copyContent(selection.start, selection.end)
			else if (isCell) copyContent(
				concat(cursor, getStartPositionOfDocument(getElementAtPosition(document, cursor))),
				concat(cursor, getEndPositionOfDocument(getElementAtPosition(document, cursor), true))
			);
			WigiSendEventResultImmediate(true);
		}

		// actually, it's not used
		WigiCopySpecial(formatting): {
			document = getValue(state.document);
			cursor = getValue(state.cursor);
 			selection = getValue(state.selection);
 			isCell = isCellCursor(state);

			copyContent = \start, end -> {
				copy = applyFn2WigiElement(wigiForStorage(document, false), [], getDefaultStateScope(^(state.engine.env)).names, true,
					\path, element, ns -> wigiFormula2value(element, path, ns, WigiSelection(start, end), state.engine)
				);
				rangeRC = extractWigiRange(copy, start, end);
				mode = if (formatting) {
					if (isCell) PreserveFormatting()
					else TryToSimplifyToPlainText()
				} else PlainText();
				copyToClipboards(state, Some(rangeRC), mode);
			};

			if (!isEmptySelection(selection)) copyContent(selection.start, selection.end)
			else if (isCell) copyContent(
				concat(cursor, getStartPositionOfDocument(getElementAtPosition(document, cursor))),
				concat(cursor, getEndPositionOfDocument(getElementAtPosition(document, cursor), true))
			);
			WigiSendEventResultImmediate(true);
		}

		WigiCut(): {
			selection = getValue(state.selection);
			if (!isEmptySelection(selection)) {
				range = normalizeWigiDocument(extractWigiRange(getValue(state.document), selection.start, selection.end));
				copyToClipboards(state, Some(range), TryToSimplifyToPlainText());
				deleteSelection2(state, false) |> ignore;
			}
			WigiSendEventResultImmediate(true);
		}

		WigiPaste(): {
			pasteFromClipboards(state, \text, spacing -> {
				executeWigiEditorChange(state, \ -> wigiPaste(state, text, spacing), nop, false);
			});
		}

		WigiDelete(): {
			executeLongTextChange(\ -> {
				next(state.cursorWantThisX, -1.0);
				// First, try to delete any selection
				if (!deleteSelection2(state, false)) {
					wigiDeleteCharacter(state);
				}
			}, true);
		}

		WigiDeleteElement(path): {
			deleteElementSafely(state, path);
			WigiSendEventResultImmediate(true);
		}

		WigiDeleteWord(): {
			makeWordSelection(state, true);
			wigiSendEventInternal(state, WigiDelete());
			WigiSendEventResultImmediate(true);
		}

		WigiBackspace(): {
			executeLongTextChange(\ -> {
				next(state.cursorWantThisX, -1.0);
				// First, try to delete any selection
				if (!deleteSelection2(state, false)) {
					initialCursor = getValue(state.cursor);
					root = getValue(state.document);
					initialElement = getElementAtPosition(root, initialCursor);

					// At the start of a document, this does nothing
					if (getStartPositionOfDocument(root) != initialCursor) {
						wigiMoveCursor(state, -1, false);
						afterMoveCursor = getValue(state.cursor);
						afterMoveElement = getElementAtPosition(root, afterMoveCursor);

						// Fix for page breaks and text to block border
						if (isWigiPageBreak(afterMoveElement)
							|| (isWigiBlock(initialElement, []) && !isWigiPageBreak(initialElement) // PageBreak is a special case, we should not move this case
									&& !isPositionStartOfParagraph(root, initialCursor) // if we at the beginning of paragraph we don't want to skip enything
									&& isWigiEmptyText(afterMoveElement) // if new element is empty text and this text and it is part of non-empty WigiText
									&& lastElement(afterMoveCursor, 0) != 0) // then we should move one more time
						) {
							wigiMoveCursor(state, -1, false);
						}

						cursor = getValue(state.cursor);
						curElement = getElementAtPosition(root, cursor);

						// If we are at the block, we need to move one more time to the left
						atBlock = switch (curElement: WigiElement) {
							WigiBlock(__, __): true;
							default: false;
						}
						lengthCursor = length(cursor);
						lengthInitialCursor = length(initialCursor);
						atRecursive = lengthCursor - lengthInitialCursor >= 3;

						// If we significantly changed cursor parents, it means we don't want to delete anything
						lengthCp = length(commonPath(initialCursor, cursor));
						// The check might not be super-reliable, but should work in most cases
						// (we assume Recursive -> Story -> Paragraph -> Text/Block/Recursive hierarchy)
						onlyMoveLeft = lengthCursor - lengthCp >= 4 || lengthInitialCursor - lengthCp >= 4;

						if (!onlyMoveLeft) {
							if (isWigiRadioButton(curElement)) {
								deleteWigiRadioButton(state)
							} else if (atBlock) {
								// Because of case 38697
								if (findParentParagraph(root, cursor) == findParentParagraph(root, initialCursor) && !isPositionStartOfParagraph(root, cursor)) {
									wigiMoveCursor(state, -1, false);
								}
								setWigiEditorSelection(state, WigiSelection(getValue(state.cursor), initialCursor), true);
								deleteRegularSelection(state, false) |> ignore;
							} else {
								wigiDeleteCharacter(state);
							}
						} else if (atRecursive) {
							// Let's select this Recursive as MS Word does
							startOfOuterRecursive = wigiFindPathOfOutermostRecursive(root, cursor);

							// set cursor to the start of the first tabel cell
							firstInnerPositionAtRecursive = concat(startOfOuterRecursive, generate(0, 5, \__ -> 0));
							selectionStart = doPositionDelta(root, firstInnerPositionAtRecursive, -1);

							wigiSetCursor(state, selectionStart, false);
							setWigiEditorSelection(state, WigiSelection(selectionStart, initialCursor), false);
						}
					}
				}
			}, true);
		}

		WigiBackspaceWord(): {
			makeWordSelection(state, false);
			wigiSendEventInternal(state, WigiBackspace());
		}

		WigiEnter(shift): {
			executeLongTextChange(\ -> {
				next(state.cursorWantThisX, -1.0);
				if (shift) {
					wigiInsertText(state, "\n");
				} else {
					deleteSelection(state);
					wigiNewParagraph(state, getValue(state.cursor));
				}
			}, true);
		}

		WigiSetColor(color): {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}

		WigiSetBackgroundColor(color): {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}

		WigiSetFontSize(fontSize): {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}

		WigiModifyFontSize(baseSize, baseShift): {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}

		WigiSetFontFamily(fontFamily): {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}
		WigiSetLetterSpacing(spacing) : {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}
		WigiSetAnnotation(id) : {
			executeLongTextChange(\ -> changeSelectionStyle(state, event), false);
		}

		WigiSwitchFontFamily(fontFamilyStyle, turnOn): {
			switch(fontFamilyStyle) {
				SBold(): changeSelectionStyle(state, WigiSwitchFontFamily(fontFamilyStyle, !isSelectionBold(state)));
				SItalic(): changeSelectionStyle(state, WigiSwitchFontFamily(fontFamilyStyle, !isSelectionItalic(state)));
			}
			WigiSendEventResultImmediate(true);
		}

		WigiSetUnderline(__): {
			executeLongTextChange(
				\ -> {
					selection = getValue(state.selection);
					if (isEmptySelection(selection)) {
						next(state.underlining, !getValue(state.underlining));
						if (getValue(state.underlining)) {
							next(state.doubleUnderlining, false);
						}
					} else {
						setUnderline = !isSelectionUnderlined(state);
						changeSelectionStyle(state, WigiSetUnderline(setUnderline));
					}
				},
				false
			);
		}

		WigiSetDoubleUnderline(__): {
			executeLongTextChange(
				\ -> {
					selection = getValue(state.selection);
					if (isEmptySelection(selection)) {
						next(state.doubleUnderlining, !getValue(state.doubleUnderlining));
						if (getValue(state.doubleUnderlining)) {
							next(state.underlining, false);
						}
					} else {
						setUnderline = !isSelectionDoubleUnderlined(state);
						changeSelectionStyle(state, WigiSetDoubleUnderline(setUnderline));
					}
				},
				false
			)
		}

		WigiClearTextFormatting(): {
			clearTextFormatting(state);
			WigiSendEventResultImmediate(true);
		}

		WigiSetBaselineShift(shift): {
			executeLongTextChange(
				\ -> {
					selection = getValue(state.selection);
					if (isEmptySelection(selection)){
						newShift = if (getValue(state.baselineShift) == shift) 0.0 else shift;
						nextDistinct(state.baselineShift, newShift);
					} else {
						newShift = if (isSelectionShifted(state, shift)) 0.0 else shift;
						changeSelectionStyle(state, WigiSetBaselineShift(newShift));
					}
				},
				false
			)
		}

		WigiSetName(__): {
			changeSelectionStyle(state, event);
			WigiSendEventResultImmediate(true);
		}

		WigiSetLanguage(__): {
			changeSelectionStyle(state, event);
			WigiSendEventResultImmediate(true);
		}

		WigiSetParagraphStyle(__, __): {
			executeWigiEditorChange(state, \ -> changeSelectionStyle(state, event), nop, false);
			WigiSendEventResultImmediate(true);
		}

		WigiClearParagraphFormatting(): {
			clearParagraphFormatting(state);
			WigiSendEventResultImmediate(true);
		}

		WigiModifyParagraphStyle(__): {
			executeWigiEditorChange(state, \ -> changeSelectionStyle(state, event), nop, false);
			WigiSendEventResultImmediate(true);
		}

		WigiReplaceParagraphStyle(styleToReplace): {
			executeWigiEditorChange(state, \ -> changeSelectionStyle(state, event), nop, false);
			switch (styleToReplace) {
				WigiStylesName(__): nextDistinct(state.wpsName, styleToReplace);
				default: {}
			}
			WigiSendEventResultImmediate(true);
		}

		WigiSetStoryStyle(__, toAdd): {
			root = getValue(state.document);
			cursor = getValue(state.cursor);
			maybeApply(maybeGetParentWigiStory(root, cursor), \p -> {
				story = p.first;
				path = p.second;
				if (path == []) {
					// we have to change the main story, i.e root
					switch(root) {
						WigiStory(paragraphs, views, style): {
							nextDistinct(state.document, WigiStory(paragraphs, views, toAdd))
						}
						default: {}
					}
				} else {
					// we have to change some element in the tree (p.first)
					replaceElementInDocument(state, path, WigiStory(story.paragraphs, story.views, toAdd))
				}
			});
			WigiSendEventResultImmediate(true);
		}

		WigiModifyStoryStyle(updater): {
			root = getValue(state.document);
			cursor = getValue(state.cursor);
			maybeApply(maybeGetParentWigiStory(root, cursor), \p -> {
				story = p.first;
				path = p.second;
				if (path == []) {
					// we have to change the main story, i.e root
					switch(root) {
						WigiStory(paragraphs, views, style): {
							next(state.document, WigiStory(paragraphs, views, updater(style)))
						}
						default: {}
					}
				} else {
					// we have to change some element in the tree (p.first)
					replaceElementInDocument(state, path, WigiStory(story.paragraphs, story.views, updater(story.style)))
				}
			});
			WigiSendEventResultImmediate(true);
		}

		WigiUndo(): {
			executeLongTextChange(\ -> wigiUndo(state), false);
		}

		WigiRedo(): {
			executeLongTextChange(\ -> wigiRedo(state), false);
		}

		WigiTab(shift): {
			changeWigiParagraphIndent(state, shift);
			WigiSendEventResultImmediate(true);
		}

		WigiInsertFormula(name): {
			showCalculatedCellDialog(state, "=", \formula -> {
				insertWigiElement(state, WigiBlock(WigiFormula(formula, []), [WigiName(name)]));
			});
			WigiSendEventResultImmediate(true);
		}

		WigiZoomIn(): {
			maxZoom = 5.0;
			zoom = getValue(state.zoom) * 1.1 |> roundZoom;
			nextDistinct(state.zoom, if (zoom > maxZoom ) maxZoom else zoom);
			WigiSendEventResultImmediate(true);
		}

		WigiZoomOut(): {
			minZoom = 0.1;
			zoom = getValue(state.zoom) * 0.9 |> roundZoom;
			nextDistinct(state.zoom, if (zoom < minZoom) minZoom else zoom);
			WigiSendEventResultImmediate(true);
		}

		WigiResetZoom(): {
			nextDistinct(state.zoom, 1.0);
			WigiSendEventResultImmediate(true);
		}

		WigiSetCellCursor(): {
			WigiSendEventResultImmediate(false);
		}

		WigiSetColumnWidth(__): {
			WigiSendEventResultImmediate(false);
		}

		WigiSetRowHeight(__): {
			WigiSendEventResultImmediate(false);
		}

		WigiInsertPageBreak(): {
			doInsertPageBreak(state);
			WigiSendEventResultImmediate(true);
		}

		WigiSetTableCellStyle(__): {
			WigiSendEventResultImmediate(false);
		}

		WigiChangeBlock(newBlock): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			block = if (isEmptySelection(selection)) getElementAtPosition(document, getValue(state.cursor))
			else extractWigiRange(document, selection.start, selection.end);

			switch(block) {
				WigiBlock(__, __): {
					if (block != newBlock) {
						cursor = getValue(state.cursor);
						// Special case for WigiPageBreak, just take a parent
						path = if (isWigiPageBreak(block)) {
							if (cursor == []) cursor else subrange(cursor, 0, length(cursor) - 1)
						} else if (isEmptySelection(selection)) cursor else findWigiElement(document, block);
						replaceElementInDocument(state, path, newBlock);
						WigiSendEventResultImmediate(true);
					} else WigiSendEventResultImmediate(false);
				}
				default: WigiSendEventResultImmediate(false);
			}
		}

		WigiChangeRecursive(newRecursive): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			recursivePath = wigiFindParentRecursive(document, [newRecursive.type], elementPath);
			if (recursivePath != []) {
				recursive = getElementAtPosition(document, recursivePath);
				switch(recursive) {
					WigiRecursive(__, __, __): {
						if (recursive != newRecursive) {
							replaceElementInDocument(state, findWigiElement(document, recursive), newRecursive);
							WigiSendEventResultImmediate(true);
						} else WigiSendEventResultImmediate(false);
					}
					default: WigiSendEventResultImmediate(false);
				}
			} else WigiSendEventResultImmediate(false);
		}

		WigiCursorUp(selecting): {
			WigiSendEventResultImmediate(moveCursorUpDownInRecursive(state, selecting, true));
		}

		WigiCursorDown(selecting): {
			WigiSendEventResultImmediate(moveCursorUpDownInRecursive(state, selecting, false));
		}

		WigiInsertNaturalMath(): {
			showNaturalMathEditor("Enter natural math", "",
				\text -> {
					insertWigiElement(state, WigiBlock(WigiNaturalMath(text), getTextStyleFromToolbar(state)));
					wigiSendEventInternal(state, WigiEnd(false)) |> ignore;
				}
			);
			WigiSendEventResultImmediate(true);
		}

		WigiInsertNativeWiki(wiki): {
			// try to convert this content to wigi and insert as wigi
			wigi = wiki2wigi(wiki, None());
			insertWigiElement(state, if (length(wigi.second) == 0) wigi.first else WigiBlock(WigiNativeWiki(wiki), []));
			wigiSendEventInternal(state, WigiCursorRight(false));
		}

		WigiSetCursor(newCursor, sel): {	// Comes when user just clicks on the document at a speicifed position, no selection, no nothing
			oldCursor = getValue(state.cursor);
			doc = getValue(state.document);

			// Let's see if our current cursor position is inside a text "=..." inside a spreadsheet cell
			curElementPath = wigiParentPath(oldCursor);
			curElement = getElementAtPosition(doc, curElementPath);

			curFormula = ref "";
			startRangePos = ref -1;
			endRangePos = ref -1;

			isInsideFormula = switch (curElement: WigiElement) {
				WigiText(text, s): {
					curFormula := text;
					startsWith(text, "=") && [] != wigiFindParentRecursive(doc, [dummyWigiSpreadsheetCell], oldCursor)
				}
				default: false;
			}

			changeRangeInFormula = \newRange -> {
				if (^startRangePos < 0 || ^startRangePos >= strlen(^curFormula)) {
					startRangePos := lastElement(oldCursor, strlen(^curFormula));
					endRangePos := ^startRangePos;
				}

				leftPart = strLeft(^curFormula, ^startRangePos);
				predicate = ["(",":"," ",",","+","-","*","/","=","<>","!=","<=",">=",">","<","&","[","and","or","not"];

				if((newRange == "") || exists(predicate, \v -> strRight(leftPart, strlen(leftPart)-strlen(v)) == v)) {
					newFormula = leftPart + newRange + strRight(^curFormula, ^endRangePos);
					endRangePos := ^startRangePos + strlen(newRange);

					// Replace the current element with the new formula
					newFormulaElement = WigiText(newFormula, cast(curElement: WigiElement -> WigiText).style);
					replaceElementInDocument(state, curElementPath, newFormulaElement);

					curFormula := newFormula;

					// And set the cursor at the end of new formula
					next(state.cursor, arrayPush(curElementPath, ^endRangePos));
					true;
				}
				else false;
			}

			isClickInTable = wigiFindParentRecursive(doc, [dummyWigiTable], newCursor) != [];

			endModeCleanup = ref nop;

			endSelectionMode = \ -> {
				^endModeCleanup();
				endModeCleanup := nop;

				next(state.formulaEditor, None());
				setWigiEditorSelection(state, wigiClearSelection(doc), false);
				next(state.selectionAnchor, None());

				next(state.editMode, true);
			}

			handleFormulaEditorEvent = \ev: WigiEvent -> {
				endSelectionModeAndHandle = \ -> {
					endSelectionMode();
					doWigiSendEvent(state, ev).handled
				}

				handleCursorMove = \ -> {
					// We have a selection start, end and an anchor
					// The end of a selection that is not an anchor is the one that should be moved
					selection = getValue(state.selection);
					anchor = either(getValue(state.selectionAnchor), []);

					cellToMove = if (anchor == selection.start) selection.end else selection.start;

					// We also need to make sure we set cursor to the cell level
					cellPosition = wigiFindParentRecursive(doc, [dummyWigiSpreadsheetCell], cellToMove);

					// Now we just set the cursor and let it move according to the event
					next(state.cursor, if (cellPosition != []) cellPosition else cellToMove);
					doWigiSendEvent(state, ev).handled;
				}

				// Here we will receive events instead of usual handlers in selection mode
				switch (ev: WigiEvent) {
					WigiInsertText(__): endSelectionModeAndHandle();
					WigiBackspace(): endSelectionModeAndHandle();
					WigiDelete(): endSelectionModeAndHandle();

					WigiEnter(shift): {
						// Make it apply the whole thing, so return to usual cursor, and then simulate another Enter to move to the next cell
						// curElementPath is a WigiText, so we need to go to Paragraph above, and then story above
						finalPath = wigiParentPath(wigiParentPath(curElementPath));

						endSelectionMode();
						wigiSetCursor(state, finalPath, shift);

						// Simulate another Enter basically
						doWigiSendEvent(state, ev).handled
					}

					WigiSetCellCursor(): {	// This is basically escape
						// We need to rollback changes, so erase current formula, and exit selection mode
						changeRangeInFormula("");
						endSelectionMode();
						true
					}

					WigiSetCursor(pos, sel2): {	// Click
						// If we click in the cell where we have the formula itself, we need to exit seleciton mode
						if (isPositionParentGeneral(wigiParentPath(pos), oldCursor)) {
							endSelectionMode();
						}

						// We can just let the general mechanism take care of that
						doWigiSendEvent(state, ev).handled;
					}

					WigiCursorLeft(selecting): handleCursorMove();
					WigiCursorRight(selecting): handleCursorMove();
					WigiCursorUp(selecting): handleCursorMove();
					WigiCursorDown(selecting): handleCursorMove();

					default: {
						println("Formula editor was unable to handle event " + ev.structname);
						false
					}
				}
			}

			startSelectionMode = \ -> {
				curSelection = getValue(state.selection);
				if (isPositionParent(curElementPath, curSelection.start) && isPositionParent(curElementPath, curSelection.end)) {
					// Setup proper place for the range to go to
					startRangePos := lastElement(curSelection.start, -1);
					endRangePos := lastElement(curSelection.end, -1);
				}

				setWigiEditorSelection(state, wigiClearSelection(doc), false);
				next(state.selectionAnchor, None());

				next(state.editMode, false);

				endModeCleanup := subscribe2(state.selection, \selection -> {
					if(!isPositionParentGeneral(selection.start, oldCursor)) {
						rectSelection = getRectangularSelection(selection, doc, true);
						switch (rectSelection) {
							Some(rectSelect): {
								// Change current range at cursor
								isChanged = changeRangeInFormula(rectSelect.rangeStr);
								if(!isChanged) {
									endSelectionMode();
									wigiSetCursor(state, newCursor, false);
								}
							}

							None(): {
								// We don't have any selection any more, so let's end selection mode?
								endSelectionMode();
							}
						}
					}
					else endSelectionMode();
				});

				next(state.formulaEditor, Some(FormulaEditor(curElementPath, handleFormulaEditorEvent)));
			}

			if (!getValue(state.editMode)) {
				// We are in selection mode
				if (isClickInTable) {
					if (false /* shift pressed */) {
						// We are in selection mode already
					} else {
						// No shift, let's select this one cell
						setWigiEditorSelection(state, WigiSelection(newCursor, newCursor), false);
						next(state.selectionAnchor, Some(newCursor));
					}
				} else {
					// Click is outside table, end selection?
					endSelectionMode();
				}
			} else {
				// We are in usual mode
				clickInTheSameCell = isPositionParentGeneral(wigiParentPath(newCursor), oldCursor) ||
					isPositionParentGeneral(oldCursor, wigiParentPath(newCursor));

				if (isInsideFormula && isClickInTable && !clickInTheSameCell) {
					startSelectionMode();

					// Select this cell right away
					setWigiEditorSelection(state, WigiSelection(newCursor, newCursor), false);
				} else {
					// Usual case, outside of formula
					isClickInSpreadsheet = length(wigiFindParentRecursive(doc, [WigiSpreadsheetCell(makeWH(), make(false), [])], newCursor)) > 0;
					nc = if (isClickInSpreadsheet && !clickInTheSameCell) subrange(newCursor, 0, length(newCursor)-4) else newCursor;
					wigiSetCursor(state, nc, sel);
				}
			}
			WigiSendEventResultImmediate(true);
		}
		WigiInsertHTML(html):{
			// HTML block is inserted in a separate paragraph
			name = getProperName("html", getValue(state.document));
			paragraph = WigiParagraph([WigiBlock(html, [WigiName(name)])], []);
			root = getValue(state.document);
			if (!isPositionStartOfParagraph(root, getValue(state.cursor)))
				wigiNewParagraph(state, getValue(state.cursor));
			pasteWigiAndNormalize(state, getValue(state.cursor), paragraph, true);
			wigiNewParagraph(state, getValue(state.cursor));
			WigiSendEventResultImmediate(true);
		}
		WigiSetLock(type):{
			changeSelectionStyle(state, event);
			WigiSendEventResultImmediate(true);
		}

		WigiRenameRadioGroup(name): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			parentRadioOptionM = maybeGetParentRadioOption(document, elementPath);
			maybeApply(parentRadioOptionM, \parentRadioOption -> {
				untriple(parentRadioOption, \__, radioOption, __ -> {
					foldWigiElement(getValue(state.document), [], 0, \__, element, path -> {
						switch (element) {
							WigiRecursive(children, type, style): {
								switch (type) {
									WigiRadioOption(group_id, value): {
										if (group_id == radioOption.id) {
											replaceElementInDocument(state, path, WigiRecursive(children, WigiRadioOption(name, value), style))
										}
									}
									default: {}
								}
							}
							WigiBlock(type, style): {
								switch (type) {
									WigiRadioButton(__, __): {
										wigiName: WigiName = extractStruct(style, WigiName(""));
										nameParts = strSplit(wigiName.name, "_");
										if (length(nameParts) == 2) {
											if (nameParts[0] == radioOption.id) {
												replaceElementInDocument(state, path, WigiBlock(type, replaceStruct(style, WigiName(name + "_" + nameParts[1]))))
											}
										}
									}
									default: {}
								}
							}
							default: {}
						};
						0
					});
					{}
				})
			});
			WigiSendEventResultImmediate(true);
		}

		WigiDeleteRadioGroup(): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			parentRadioOptionM = maybeGetParentRadioOption(document, elementPath);
			maybeApply(parentRadioOptionM, \parentRadioOption -> {
				untriple(parentRadioOption, \__, radioOption, __ -> {
					foldWigiElement(getValue(state.document), [], 0, \__, element, __ -> {
						switch (element) {
							WigiRecursive(children, type, style): {
								switch (type) {
									WigiRadioOption(group_id, value): {
										if (group_id == radioOption.id) {
											deleteElementSafely(state, findWigiElement(getValue(state.document), element))
										}
									}
									default: {}
								}
							}
							default: {}
						}
						0;
					});
					{}
				})
			});
			WigiSendEventResultImmediate(true);
		}

		WigiChangeRadioOptionValue(newValue): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			parentRadioOptionM = maybeGetParentRadioOption(document, elementPath);
			maybeApply(parentRadioOptionM, \parentRadioOption -> {
				untriple(parentRadioOption, \recursive, radioOption, recursivePath -> {
					foldWigiElement(recursive, recursivePath, 0, \__, element, path -> {
						switch (element) {
							WigiRecursive(children, type, style): {
								switch (type) {
									WigiRadioOption(group_id, value): {
										if ((group_id == radioOption.id) && (value == radioOption.value)) {
											replaceElementInDocument(state, path, WigiRecursive(children, WigiRadioOption(group_id, newValue), style))
										}
									}
									default: {}
								}
							}
							WigiBlock(type, style): {
								switch (type) {
									WigiRadioButton(__, __): {
										wigiName: WigiName = extractStruct(style, WigiName(""));
										nameParts = strSplit(wigiName.name, "_");
										if (length(nameParts) == 2) {
											if (nameParts[0] == radioOption.id) {
												replaceElementInDocument(state, path, WigiBlock(type, replaceStruct(style, WigiName(nameParts[0] + "_" + i2s(newValue)))))
											}
										}
									}
									default: {}
								}
							}
							default: {}
						}
						0;
					});
					{}
				})
			});
			WigiSendEventResultImmediate(true)
		}

		WigiDeleteRadioOption(): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			parentRadioOptionM = maybeGetParentRadioOption(document, elementPath);
			maybeApply(parentRadioOptionM, \parentRadioOption -> {
				untriple(parentRadioOption, \__, __, recursivePath -> {
					deleteElementSafely(state, recursivePath)
				})
			});
			WigiSendEventResultImmediate(true)
		}
		WigiSetRadioGroupLayout(layout): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			parentRadioOptionM = maybeGetParentRadioOption(document, elementPath);
			maybeApply(parentRadioOptionM, \parentRadioOption -> {
				untriple(parentRadioOption, \recursive, radioOption, recursivePath -> {
					foldWigiElement(getValue(state.document), [], 0, \__, element, __ -> {
						switch (element) {
							WigiRecursive(children, type, style): {
								switch (type) {
									WigiRadioOption(group_id, value): {
										if (group_id == radioOption.id) {
											// recognize what is the current layout and modify it
											maybeApply(maybeGetWigiRadioOptionProperties(element), \layoutProperties -> {
												content = makeWigiRadioOptionContent(layout, layoutProperties.frame, layoutProperties.buttonElements, layoutProperties.otherElements, layoutProperties.paragraphStyle);
												replaceElementInDocument(state, findWigiElement(getValue(state.document), element), WigiRecursive([content], radioOption, []))
											})
										}
									}
									default: {}
								}
							}
							default: {}
						}
						0
					});
					{}
				})
			});
			WigiSendEventResultImmediate(true)
		}
		WigiSetRadioGroupWidth(widthM): {
			document = getValue(state.document);
			selection = getValue(state.selection);
			cursor = getValue(state.cursor);
			elementPath = if (isEmptySelection(selection)) cursor else selection.start;
			parentRadioOptionM = maybeGetParentRadioOption(document, elementPath);
			maybeApply(parentRadioOptionM, \parentRadioOption -> {
				untriple(parentRadioOption, \recursive, radioOption, recursivePath -> {
					// Let's try to preserve cursor position
					cursorTag = WigiBlock(WigiPositionTag(1), []);
					pasteWigi(state, elementPath, cursorTag, false);
					foldWigiElement(getValue(state.document), [], 0, \__, element, __ -> {
						switch (element) {
							WigiRecursive(children, type, style): {
								switch (type) {
									WigiRadioOption(group_id, value): {
										if (group_id == radioOption.id) {
											maybeApply(maybeGetWigiRadioOptionProperties(element), \layoutProperties -> {
												content = eitherFn(
													widthM,
													\width -> {
														// set specified width
														makeWigiRadioOptionContent(layoutProperties.align, Some(WigiFrame(width, 1000.0, [TightHeight()])), layoutProperties.buttonElements, layoutProperties.otherElements, layoutProperties.paragraphStyle);
													},
													\-> {
														// remove width
														makeWigiRadioOptionContent(layoutProperties.align, None(), layoutProperties.buttonElements, layoutProperties.otherElements, layoutProperties.paragraphStyle);
													}
												);
												replaceElementInDocument(state, findWigiElement(getValue(state.document), element), WigiRecursive([content], radioOption, []))
											})
										}
									}
									default: {}
								}
							}
							default: {}
						}
						0;
					});
					setCursorWhereTagIs(state, recursivePath, cursorTag, true)
				})
			});
			WigiSendEventResultImmediate(true)
		}

		WigiSwapParagraph(up) : {
			cursor = getValue(state.cursor);
			switch (getValue(state.document) : WigiElement) {
				WigiStory(paragraphs, views, style): {
					cursorToChange = if (up) cursor[0] - 1 else cursor[0] + 1;
					borderCondition = if (up)  cursor[0] != 0  else cursorToChange != length(^paragraphs);
					if (borderCondition) {
						currentParagraph = ^paragraphs[cursor[0]];
						replaceElementInDocument(state, [cursor[0]], ^paragraphs[cursorToChange]);
						replaceElementInDocument(state, [cursorToChange], currentParagraph);
						wigiSetCursor(state, replace(cursor, 0, cursorToChange), false);
					}
				}
				default: {}
			}
			WigiSendEventResultImmediate(true)
		}

		WigiCleanUpParagrapshIndents(pitch) : {
			cleanDocument = cleanDocumentIndentations(getValue(state.document), state.defaultStyles, pitch);
			nextDistinct(state.document, cleanDocument);
			WigiSendEventResultImmediate(true);
		}

		default: {
			// println("Common event handler couldn't handle " + toString(event));
			WigiSendEventResultImmediate(false)
		}
	}
	if (useTransformMatrixPositioning && sendResult.handled) deferUntilNextFrameRendered(\ -> wigiUpdateCursor(state));
	sendResult
}

cleanParagraphIndentations(cleanIndents : [int], dirtyIndents : [int], topIndent : int) -> [int] {
	shifts = mapi(dirtyIndents, \i, v -> v - elementAt(dirtyIndents, i - 1, topIndent) - 1);
	eitherMap(findi(shifts, \e -> e > 0), \indexBroken -> {
		indexBrokenEnd = either(findiex(dirtyIndents, \indent -> indent < dirtyIndents[indexBroken], indexBroken + 1), length(dirtyIndents));
		patchedPart = map(subrange(dirtyIndents, indexBroken, indexBrokenEnd - indexBroken), \e -> e - shifts[indexBroken]);
		cleanParagraphIndentations(
			concat(cleanIndents, take(dirtyIndents, indexBroken)),
			concat(patchedPart, tailFrom(dirtyIndents, indexBrokenEnd)),
			firstElement(patchedPart, topIndent + 1) - 1
		);
	}, concat(cleanIndents, dirtyIndents));
}

cleanDocumentIndentations(wigi : WigiElement, defaultStyles : [WigiStyles], pitch: double) -> WigiElement {
	story = wigiElement2wigiStory(wigi);
	levelWigiStyles = extractWpsFromWigiStyles(defaultStyles);
	cleanLevelWigiStyles = filter(levelWigiStyles, \s -> !startsWith(s.type, "WPS-Default"));

	//paragraph levels extraction: 0 - document root (compared with first paragraph), 1-n - paragraphs
	lastValue = ref 0;
	dirtyIndents = map(^(story.paragraphs), \p -> {
		curValue = switch(p) {
			WigiParagraph(elements, paragraphStyle): eitherMap(tryExtractStruct(paragraphStyle, GeneralIndent(0.0)), \generalIndent -> round(generalIndent.indent / pitch) + 1, 1);
			default: ^lastValue;
		};

		lastValue := curValue;
		curValue;
	});

	indents = cleanParagraphIndentations([], dirtyIndents, 0);

	WigiStory(
		ref mapi(^(story.paragraphs), \i, p -> {
			switch(p) {
				WigiParagraph(elements, paragraphStyle): {
					curStyle = elementAt(cleanLevelWigiStyles, indents[i] - 1, WigiStyles("", [], []));
					stylesWithoutAspect = removeAllStructs(curStyle.paragraphStyle, dummyWigiAspect);
					stylesWithWigiStylesName = arrayPush(stylesWithoutAspect, WigiStylesName(curStyle.type));
					newStyle = replaceStructMany(paragraphStyle, stylesWithWigiStylesName);
					applyParagraphStyles(elements, newStyle, true, defaultStyles)
				}
				default: p;
			}
		}),
		ref [],
		story.style
	);
}

moveCursorUpDownInRecursive(state : WigiEditorState, selecting : bool, up : bool) -> bool {
	document = getValue(state.document);
	selection = getValue(state.selection);
	elementPath = if (isEmptySelection(selection)) getValue(state.cursor) else selection.start;

	move = ref \ep -> false;

	move := \ep -> {
		recursivePath = wigiFindParentRecursive(document, [], ep);
		if (recursivePath != []) {
			recursive = getElementAtPosition(document, recursivePath);
			last = length(recursivePath) - 1;

			switch (recursive) {
				WigiRecursive(elements, type, __): {
					switch (type) {
						WigiFrame(__, __, __): ^move(subrange(recursivePath, 0, last));
						default: {
							if (length(elementPath) > last + 1) {
								newInd = if (up) elementPath[last + 1] - 1 else elementPath[last + 1] + 1;
								isOutOfRange = newInd < 0 || newInd >= length(elements);
								newPosElementPath = if (isOutOfRange) doPositionDelta(document, recursivePath, if (up) -1 else 1) else arrayPush(recursivePath, newInd);
								newPosElement = getElementAtPosition(document, newPosElementPath);

								tailOfNewPosElement = if (isOutOfRange && !up) getStartPositionOfDocument(newPosElement) else getEndPositionOfDocument(newPosElement, true);
								newPosLast = length(tailOfNewPosElement) - 1;
								newPos = concat(newPosElementPath,
									if (isOutOfRange) tailOfNewPosElement
									else replace(tailOfNewPosElement, newPosLast, min(lastElement(elementPath, 0), tailOfNewPosElement[newPosLast]))
								);
								wigiSetCursor(state, newPos, selecting);
								true;
							} else  {
								false
							}
						}
					}
				}
				default: false;
			}
		} else false;
	};

	^move(elementPath);
}

roundZoom(z) dround(z * 100.0) / 100.0; // make zoom a multiple of 0.01 not to get too long zoom value in proof mode

isSelectionStyled(state: WigiEditorState, checkStyle: ([WigiStyle]) -> bool) -> bool {
	selection = getValue(state.selection);
	doc = getValue(state.document);

	checkStyleInRange = \start, end -> {
		all(mapWigiStylesFromRange(state.defaultStyles, doc, start, end, \e, path, style -> {
			if (isEmptyElement(e)) {
				true
			} else {
				switch (e) {
					WigiDocument(__, __): true;
					WigiStory(__, __, __): true;
					WigiParagraph(__, __): true;
					WigiText(__, __): checkStyle(style);
					WigiRecursive(__, __, __): checkStyle(style);
					WigiBlock(__, __): checkStyle(style);
					WigiEmpty(): true;
				}
			}
		}))
	}

	// We need to distinguish between regular and rectangular selection
	switch (getRectangularSelection(selection, doc, false): Maybe<RectangularSelection>) {
		None(): {		// Usual selection
			checkStyleInRange(selection.start, selection.end)
		}

		Some(rectSelection): {			// Rectangular selection
			// We know it is a WigiTable
			table = cast(getElementAtPosition(doc, rectSelection.path): WigiElement -> WigiRecursive);

			// Go through all the cells and check style of those selected
			foldi(table.elements, true, \i, acc, cell -> {
				if (acc && rectSelection.isInside(i)) {
					// Check this cell style
					cellPath = arrayPush(rectSelection.path, i);

					start = concat(cellPath, getStartPositionOfDocument(cell));
					end = concat(cellPath, getEndPositionOfDocument(cell, false));

					checkStyleInRange(start, end)
				} else {
					acc
				}
			});
		}
	}
}

isSelectionUnderlined(state : WigiEditorState) -> bool {
	isSelectionStyled(state, \style -> contains(style, Underline()))
}

isSelectionDoubleUnderlined(state : WigiEditorState) -> bool {
	isSelectionStyled(state, \style -> contains(style, DoubleUnderline()))
}

isSelectionBold(state : WigiEditorState) -> bool {
	boldFamilies = ["Medium", "MediumItalic"];
	isSelectionStyled(state, \style -> {
		fontFamily = extractStruct(style, FontFamily("")).name;
		family = getReverseMappedFontFamily(fontFamily);
		contains(boldFamilies, family)
	});
}

isSelectionItalic(state : WigiEditorState) -> bool {
	italicFamilies = ["Italic", "MediumItalic", "DejaVuSansOblique", "MinionItalics"];
	isSelectionStyled(state, \style -> {
		fontFamily = extractStruct(style, FontFamily("")).name;
		family = getReverseMappedFontFamily(fontFamily);
		contains(italicFamilies, family)
	});
}

isSelectionShifted(state : WigiEditorState, baselineShift : double) -> bool {
	isSelectionStyled(state, \style -> {
		fold(style, false, \acc, s -> {
			switch (s) {
				BaselineShift(sh) : sh == baselineShift;
				default : acc;
			}
		})
	})
}

wigiMoveCursor(state : WigiEditorState, delta : int, selecting : bool) -> void {
	np = doPositionDelta(getValue(state.document), getValue(state.cursor), delta);
	next(state.cursorWantThisX, -1.0);
	wigiSetCursor(state, np, selecting);
}

isSymbol(char : string) -> bool {
	isLetter(char) || isDigit(char);
}

// everything which is not a letter, digit or a space is a delimiter
isDelimiter(char : string) -> bool {
	!isSymbol(char) && char != " ";
}

isWordStart(text : string, pos : int) -> bool {
	isWordStart2 (text, strlen(text), pos);
}

isWordStart2(text : string, textLength : int, pos : int) -> bool {
	if (text != ""){
		if (pos == 0) {
			getCharAt(text, pos) != " "
		} else if (pos > 0  && pos < textLength) {
			ch0 = getCharAt(text, pos - 1);
			ch1 = getCharAt(text, pos);
			(ch0 == " " && ch1 != " ") || (isDelimiter(ch0) && isSymbol(ch1))
			|| (isSymbol(ch0) && isDelimiter(ch1));
		} else {
			false;
		}
	} else false;
}

isWordEnd(text : string, pos : int) -> bool {
	isWordEnd2(text, strlen(text), pos);
}

isWordEnd2(text : string, textLength : int, pos : int) -> bool {
	if (text != "") {
		if (pos == textLength) {
			getCharAt(text, pos) != " ";
		} else if (pos > 0  && pos < textLength) {
			ch0 = getCharAt(text, pos - 1);
			ch1 = getCharAt(text, pos);
			(isDelimiter(ch0) && !isDelimiter (ch1)) || (isSymbol(ch0) && !isSymbol(ch1))
		} else {
			false;
		}
	} else false;
}

// search for a border (start/end) of a word (sequence of letters/digits or delimeters)
// next to the given position.
// searchToRight defines direction of search ( true = toward the end of the string)
// wordStartPos defines either we are searching for word start (true) or word end
// if no word met return 0 (max) position
// return -1 if it tries to search left from the string beginning or right from its end.
findWordBorder(text : string, pos : int, wordStartPos : bool, searchToRight : bool) -> int {
	textLength = strlen(text);

	isStart = \str, len, i -> {
		isWordStart2(str, len, i) || (i == 0 && getCharAt(str, i) == " ") || (i == len);
	}

	isEnd = \str, len, i -> isWordEnd2(str, len, i) || (i == len);

	if ( textLength != 0 && pos >=0 && pos <= textLength) {
		if (searchToRight && pos < textLength) {
			countUntil(pos + 1, textLength, \i -> if (wordStartPos) isStart(text, textLength, i) else isEnd(text, textLength, i));
		} else if (!searchToRight && pos > 0) {
			countUntilDown(pos - 1, 0, \i -> if (wordStartPos) isStart(text, textLength, i) else isEnd(text, textLength, i));
		} else -1;
	} else -1;
}

// in WigiText it moves cursor to the start of the previous/next word.
// For other elements and empty WigiText it just makes a simple move.
wigiMoveCursorByWord(state : WigiEditorState, toRight : bool, selecting : bool,  wordStartPos : bool) -> void {
	defaultDelta = if (toRight) 1 else -1;
	delta = ref defaultDelta;
	path = getValue(state.cursor);
	pathLength = length(path);
	if (pathLength > 1) {
		parent = getElementAtPosition(getValue(state.document), wigiParentPath(path));
		switch (parent) {
			WigiText(text, style) :{
				if (text != "") {
					curPos = lastElement(path, -1);
					if (curPos == -1) {
						println("Move cursor by word - we should not be here");
						delta := 0;
					} else {
						start = findWordBorder(text, curPos, wordStartPos, toRight);
						if (start != -1) {
							delta := start - curPos;
						}
					}
				}
			}
			default: {}
		}
	}
	wigiMoveCursor(state, ^delta, selecting);
}

getWordSelectionEnd(text : string, curPos : int, toRight : bool) -> int {
	wordStartPos = (toRight && isWordStart(text, curPos)) || (!toRight && !isWordEnd(text, curPos));
	findWordBorder(text, curPos, wordStartPos, toRight);
}

getTextBorders(root : WigiElement, prevBorders : Pair<[int], [int]>) -> Pair<[int], [int]> {
	getBorder = \right : bool -> {
		path = if (right) prevBorders.second else prevBorders.first;
		if (path != []) {
		 	parentPath = wigiParentPath(path);
			switch (getElementAtPosition(root, parentPath)) {
				WigiText(text, __): {
					curPos = lastElement(path, -1);
					if (curPos == -1) {
						devtrace("Make word selection - we should not be here");
						path;
					} else {
						border =
							if (right && isWordEnd(text, curPos) || !right && isWordStart(text, curPos)) path
							else concat(parentPath, [findWordBorder(text, curPos, !right, right)]);

						nextPath =
							if (right && border == concat(parentPath, [strlen(text)])) doPositionDelta(root, border, 1)
							else if (!right && border == concat(parentPath, [0])) doPositionDelta(root, border, -1)
							else border;

						if (findParentParagraph(root, nextPath) == findParentParagraph(root, border)) nextPath else border;
					}
				}
				default: path;
			}
		} else {
			path;
		}
	}

	newBorders = Pair(getBorder(false), getBorder(true));
	if (newBorders != prevBorders) getTextBorders(root, newBorders) else newBorders;
}

// It's basic  function for next makeWordSelection, makeWordSelection2, makeSentenceSelection
applyFnToCursorPosition(state : WigiEditorState, ignoreSelection : bool, applyFn : (text : string, curPos : int, parentPath : [int]) -> void) -> void {
	if (isEmptySelection(getValue(state.selection)) || ignoreSelection){
		path = getValue(state.cursor);
		pathLength = length (path);
		if ( pathLength > 1) {
			parentPath = wigiParentPath(path);
			parent = getElementAtPosition(getValue(state.document), parentPath);
			switch (parent) {
				WigiText(text, style) :{
					if (text != "" ) {
						curPos = lastElement(path, -1);
						if (curPos == -1) {
							println ("Make word selection - we should not be here");
						} else {
							applyFn(text, curPos, parentPath)
						}
					}
				}
				default : {};
			}
		}
	}
}

// It makes a new selection within WigiText from current position
// to start/end of the prevoius/next word (getWordSelectionEnd contains logic of choice).
// For non-text elements no selection is made.
// if there is another selection already, it does not make any new selection
makeWordSelection(state : WigiEditorState, toRight : bool) -> void {
	applyFnToCursorPosition(state, false, \text, curPos, parentPath -> {
		end = getWordSelectionEnd(text, curPos, toRight);
		if (end != -1) {
			setWigiEditorSelection(state, makeSelection(getValue(state.document), concat(parentPath, [curPos]), concat(parentPath, [end])), false);
		}
	})
}

// It makes a new selection within WigiText from start of the word to start of the next word
makeWholeWordSelection(state : WigiEditorState) -> void {
	applyFnToCursorPosition(state, true, \text, curPos, parentPath -> {
		wordStart = findWordBorder(text, curPos, true, false);
		wordEnd = findWordBorder(text, curPos, false, true);
		range = if (isWordStart(text, curPos)) {
			Pair(curPos, wordEnd)
		} else if (isWordEnd(text, curPos))  {
			Pair(wordStart, curPos)
		} else {
			Pair(wordStart, wordEnd)
		}
		start = range.first;
		end = range.second;
		if ((end != -1)&&(start != -1)) {
			setWigiEditorSelection(state, makeSelection(getValue(state.document), concat(parentPath, [start]), concat(parentPath, [end])), false);
		}
	})
}

makeSentenceSelection(state : WigiEditorState) -> void {
	applyFnToCursorPosition(state, true, \text, curPos, parentPath -> {
		sentenceDividers = [".", "!", "?"];
		findLastPos = \str -> {
			a = map(sentenceDividers, \divider -> strLastIndexOf(str, divider));
			pos = either(maxA(a), -1);
			if (pos == -1) 0 else {
				if (getCharAt(str, pos+1) == "\"") pos+2 else pos+1
			}

		};
		findFirstPos = \str -> {
			a = map(sentenceDividers, \divider -> strIndexOf(str, divider));
			pos = either(minA(filter(a, \_a -> _a != -1)), -1);
			if (pos == -1) strlen(str) else {
				if (getCharAt(str, pos+1) == "\"") pos+2 else pos+1
			}
		};
		start = findLastPos(strLeft(text, curPos));
		end = curPos + findFirstPos(strRight(text, curPos));
		setWigiEditorSelection(state, makeSelection(getValue(state.document), concat(parentPath, [start]), concat(parentPath, [end])), false);
	})
}

wigiSetCursorUns = ref nop;

wigiSetCursor3(state : WigiEditorState, pos : [int], selecting : bool, cleanEmptyRecursives : bool, scrollView : bool) -> void {
	if (scrollView) {
		(\ -> {
			point = getValue(state.editorView).getGlobalCoordinate(pos);
			// First, ensure that the bottom of the cursor is visible
			ensurePointVisible(state, Point(point.x, point.y + getValue(state.cursorHeight)));
			// After this, then make sure the top of the cursor is visible
			ensurePointVisible(state, point);
		})
		|> (\fn ->
			if (contains(state.wigiEditorStyle, WigiEditorSetCursorDeffered())) {
				// Dispose ensurePointVisible functions that were executed less than 1 ms ago
				if (^wigiSetCursorUns != nop) {
					^wigiSetCursorUns();
					wigiSetCursorUns := nop;
				}

				wigiSetCursorUns := interruptibleTimer(1, fn);
			} else {
				fn();
			}
		)
	}

	// Mark that we do not know how high the cursor is
	next(state.cursorHeight, -1.0);

	manchor = getValue(state.selectionAnchor);
	if (!selecting || isNone(manchor)) {
		next(state.selectionAnchor, Some(pos));
		if (!selecting) {
			emptySelection = if (getValue(state.editMode)) {
				wigiClearSelection(getValue(state.document))
			} else {
				WigiSelection(pos, pos)
			}

			setWigiEditorSelection(state, emptySelection, !selecting);
		}
	} else {
		anchor = either(manchor, []);
		setWigiEditorSelection(state, makeSelection(getValue(state.document), anchor, pos), false);
	}

	setEditMode = \cursor, em -> {
		cellPath = wigiFindParentRecursive(getValue(state.document), [dummyWigiSpreadsheetCell], cursor);
		if (cellPath != [] && cellPath != cursor) {
			cell = getElementAtPosition(getValue(state.document), cellPath);
			setWigiCellEditMode(cell, em);
		}
	};

	if (getValue(state.editMode)) {
		oldPos = getValue(state.cursor);
		next(state.cursor, pos);

		setEditMode(oldPos, false);
		setEditMode(pos, true);

		if (cleanEmptyRecursives && pos != oldPos) {    // Try to delete empty recursives that we're leaving now, if applicable
			deleteEmptyRecursiveAtPosition(state, oldPos, false);
		}
	}
}

deleteEmptyRecursiveAtPosition(state : WigiEditorState, pos : [int], keepEmptySingleChild : bool) -> void {
	recursiveToDeleteMaybe = findElementContainingPosition(state, isEmptyDeletableRecursive, pos);
	maybeApply(recursiveToDeleteMaybe, \recursiveToDelete -> {
		if (!keepEmptySingleChild || length(getWigiElementChildren(getElementAtPosition(getValue(state.document), recursiveToDelete), false)) > 1) {
			deleteElementSafely(state, recursiveToDelete);
		}
	});
}

wigiUpdateCursor(state : WigiEditorState) -> void {
	p = getValue(state.cursor);
	next(state.cursorHeight, -1.0);
	next(state.cursor, []);
	next(state.cursor, p);
}

wigiCursorToCell(state : WigiEditorState) -> void {
	d = getValue(state.document);
	c = getValue(state.cursor);
	p = wigiFindParentCell(d, c);
	wigiSetCursor(state, p, false);
}

isCellCursor(state : WigiEditorState) -> bool {
	el = getElementAtPosition(getValue(state.document), getValue(state.cursor));
	if (isWigiRecursive(el, [dummyWigiSpreadsheetCell])) true
	else getValue(state.cursorHeight) == -1.0;
}

getTextStyleFromToolbar(state: WigiEditorState) -> [WigiTextStyle] {
	// We shouldn't really remove what's already in the default style
	bgColor = getValue(state.backgroundColor);
	toolbarStyle = ref [
		FontSize(getValue(state.fontSize)),
		Fill(getValue(state.fontColor)),
		FontFamily(getValue(state.fontFamily)),
		FillOpacity(getValue(state.fillOpacity)),
		BackgroundFill(getRGB(bgColor)),
		BackgroundFillOpacity(getOpacity(bgColor)),
		BaselineShift(getValue(state.baselineShift)),
		Language(getValue(state.language)),
		LetterSpacing(getValue(state.letterSpacing)),
	];

	if (getValue(state.underlining)) refArrayPush(toolbarStyle, Underline());
	if (getValue(state.doubleUnderlining)) refArrayPush(toolbarStyle, DoubleUnderline());

	// add lock if necessary
	if (isLockEditAllowed(state)) {
		lock = getLockAtPosition(getValue(state.document), getValue(state.cursor));
		if (lock != WigiNoLock()) refArrayPush(toolbarStyle, WigiLock(lock))
	}

	root = getValue(state.document);
	path = getValue(state.cursor);

	// default text style under cursor
	currentDefaultTextStyle = getWigiTextStyleFull(state.defaultStyles, root, path, []);

	defTextStyle = concatWigiTextStyles(globalSystemDefaultTextStyle, currentDefaultTextStyle);

	toolbarStyle := filter(^toolbarStyle, \style -> !contains(defTextStyle, style));

	// adjust toolbar style to default styles of the document
	getWigiTextStyleShort(state.defaultStyles, root, path, getWigiTextStyleFull(state.defaultStyles, root, path, ^toolbarStyle))
}

wigiInsertText(state : WigiEditorState, text : string) -> void {
	// First, delete whatever is selected
	deleteSelection2(state, true);

	// The only problem is text style, let's get style from the toolbar (state)
	pasteWigiAndNormalize(state, getValue(state.cursor), WigiText(text, getTextStyleFromToolbar(state)), true);
}

countListedParagraphs(state : WigiEditorState, start : [int], end : [int]) -> int {
	listedParagraph = \st -> extractStruct(st, dummyListed) != dummyListed;

	doc = getValue(state.document);
	arr = mapWigiStylesFromRange(state.defaultStyles, doc, start, end, \e, path, style -> {
		switch(e){
			WigiParagraph(__, __): b2i(listedParagraph(style));
			default: 0;
	}});
	top = commonPath(start, end);
	root = getElementAtPosition(doc, top);
	firstRootPos = concat(top, getStartPositionOfDocument(root));
	lastRootPos = concat(top, getEndPositionOfDocument(root, false));
	// if we are going to delete the whole element and it is the only in a paragraph - check the paragraph as well
	extra = if (start == firstRootPos && lastRootPos == end){
		parentPath = wigiParentPath(top);
		switch (getElementAtPosition(doc, parentPath)){
			WigiParagraph(elements, style):{
				fullStyle = getWigiParagraphStyleFull(state.defaultStyles, doc, parentPath, style);
				b2i(length(elements)==1&&listedParagraph(fullStyle));
			}
			default : 0;
		}
	} else 0;
	extra + sum(arr)
}

wigiDeleteCharacter(state : WigiEditorState) -> void {
	root = getValue(state.document);
	startDelete = getValue(state.cursor);
	endDelete = doPositionDelta(root, startDelete, 1);

	if (isWigiRadioButton(getElementAtPosition(root, startDelete))) {
		// WigiParagraph([WigiText("", []), WigiRecursive([WigiStory(ref [WigiParagraph([WigiBlock(WigiRadioButton(DynamicBehaviour(ref true, DList(DEnd(), DEnd())), []), [WigiName("radiogroup1_1")]), WigiText("Option 1", [])], [TightWidth()])], ref [], [])], WigiRadioOption("radiogroup1", 1), []), WigiText("", [])], [])
		// [0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1]
		deleteWigiRadioButton(state)
	} else {
		// LSTSBU-429, special case in order to delete WigiRadioOption
		// WigiParagraph([WigiText("", []), WigiRecursive([WigiStory(ref [WigiParagraph([WigiBlock(WigiRadioButton(DynamicBehaviour(ref true, DList(DEnd(), DEnd())), []), [WigiName("radiogroup1_1")]), WigiText("Option 1", [])], [TightWidth()])], ref [], [])], WigiRadioOption("radiogroup1", 1), []), WigiText("", [])], [])
		//                ^ [0, 0, 0]
		parentRadioOptionMend = maybeGetParentRadioOption(root, endDelete);
		if (isWigiEmptyText(getElementAtPosition(root, startDelete)) && isSome(parentRadioOptionMend)) {
			maybeApply(parentRadioOptionMend, \parentRadioOption -> {
				untriple(parentRadioOption, \__, __, recursivePath -> {
					deleteElementSafely(state, recursivePath)
				})
			})
		} else {
			// WigiParagraph([WigiText("", []), WigiRecursive([WigiStory(ref [WigiParagraph([WigiBlock(WigiRadioButton(DynamicBehaviour(ref true, DList(DEnd(), DEnd())), []), [WigiName("radiogroup1_1")]), WigiText("Option 1", [])], [TightWidth()])], ref [], [])], WigiRadioOption("radiogroup1", 1), []), WigiText("", [])], [])
			//                                                 ^ [0, 1, 0]
			parentRadioOptionMstart = maybeGetParentRadioOption(root, startDelete);
			if (isWigiStory(getElementAtPosition(root, startDelete)) && isSome(parentRadioOptionMstart)) {
				maybeApply(parentRadioOptionMstart, \parentRadioOption -> {
					untriple(parentRadioOption, \__, __, recursivePath -> {
						deleteElementSafely(state, recursivePath)
					})
				})
			} else if (endDelete != startDelete) {
				listedToDelete = countListedParagraphs(state, startDelete, endDelete);

				atRecursive = length(endDelete) - length(startDelete) >= 3;

				if (atRecursive) {
					cursor = endDelete;
					// Let's select this Recursive as MS Word does
					startOfOuterRecursive = wigiFindPathOfOutermostRecursive(root, cursor);

					afterRecursive = arrayPush(arrayPush(
						take(startOfOuterRecursive, length(startOfOuterRecursive) - 1),
						lastElement(startOfOuterRecursive, 0) + 1
					), 0);

					wigiSetCursor(state, afterRecursive, false);
					setWigiEditorSelection(state, WigiSelection(startDelete, afterRecursive), false);
				} else {
					// We can simply delete it as a regular selection
					setWigiEditorSelection(state, WigiSelection(startDelete, endDelete), true);
					deleteRegularSelection(state, true);	// Always preserve paragraph?

					// The cursor after this operation can be however deep in the hierarchy of the next element
					// So we need to be smart about where to normalize from
					commonParent = commonPath(startDelete, endDelete);

					normalizeContent(state, wigiParentPath(commonParent));
					if (listedToDelete > 0) {
						next(state.document, getValue(state.document));
					}
				}
			}
		}
	}
}

deleteSelection(state: WigiEditorState) -> bool {
	deleteSelection2(state, false);
}

deleteSelection2(state: WigiEditorState, keepEmptySingleChild : bool) -> bool {
	testCaseRecorderSuspend();

	deleteSelectionResult = eitherFn(getRectangularSelection(getValue(state.selection), getValue(state.document), false),
		\rectSelection -> deleteRectangularSelection(state, rectSelection),
		\ -> deleteRegularSelection(state, false)
	);

	if (deleteSelectionResult) {
		deleteEmptyRecursiveAtPosition(state, getValue(state.cursor), keepEmptySingleChild);
	}

	testCaseRecorderResume();
	deleteSelectionResult
}

// Clears selected cells in a table
deleteRectangularSelection(state: WigiEditorState, rectSelection: RectangularSelection) {
	// We know it is a WigiTable
	table = cast(getElementAtPosition(getValue(state.document), rectSelection.path): WigiElement -> WigiRecursive);

	// Save cursor position to return it after deletion
	formerCursorPos = ref getValue(state.cursor);

	// Go through all the cells and clear selected ones individually
	iteri(table.elements, \i, cell -> {
		if (rectSelection.isInside(i)) {
			// Clear this table cell
			cellPath = arrayPush(rectSelection.path, i);
			cellStartPath = getStartPositionOfDocument(cell);
			doDeleteRange(state, cellPath, cellStartPath, getEndPositionOfDocument(cell, false), false);
			cursorPos = concat(cellPath, cellStartPath);

			// Correct cursor to the beginning of the cell
			if (isPositionParentGeneral(cellPath, ^formerCursorPos))
				formerCursorPos := cursorPos;

			// Setting cursor to the current position after each deletion to redraw changes
			wigiSetCursor(state, cursorPos, false);
		}
	});

	// Return cursor to the intial position
	wigiSetCursor(state, ^formerCursorPos, false);
	// Clear the selection
	nextDistinct(state.selection, wigiClearSelection(getValue(state.document)));
	true
}


deleteRegularSelection(state : WigiEditorState, preserveParagraph: bool) -> bool {
	selection = getValue(state.selection);
	normalizationPath = wigiParentPath(commonPath(selection.start, selection.end));

	if (isEmptySelection(selection)) false
	else {
		listedToDelete = countListedParagraphs(state, selection.start, selection.end);

		// Turn off paragraph redrawing, because we'are to change current WigiParagraph
		// many times below (by adding and removing WigiPositionTag-s)
		next(state.updateTropicArray, false);

		// Let's try to preserve cursor position
		cursorTag = WigiBlock(WigiPositionTag(1), []);

		pasteWigi(state, selection.end, cursorTag, false);

		doDeleteRange(state, [], selection.start, selection.end, false);

		setCursorWhereTagIs(state, normalizationPath, cursorTag, preserveParagraph);
		normalizeContent(state, normalizationPath);

		// Turn on paragraph redrawing and update "dirty" FormArray-s explicitly only one time here
		next(state.updateTropicArray, true);

		if (listedToDelete > 0)
			next(state.document, getValue(state.document));

		true
	}
}

// Figures out position so that it points to a valid element and doesn't cause troubles
positionCursorInElement(root: WigiElement, position: [int]) -> [int] {
	if (position == []) {
		[]
	} else {
		first = position[0];
		rest = tail(position);

		children = getWigiElementChildren(root, false);
		if (first >= 0 && first < length(children)) {
			// We are OK, no correction required
			concat([first], positionCursorInElement(children[first], rest))
		} else {
			// Special case for text, basically, when it happens that getWigiChildCount != length(getWigiElementChildren)
			if (first < 0) {
				getStartPositionOfDocument(root)
			} else if (first >= getWigiChildCount(root, false)) {
				getEndPositionOfDocument(root, false)
			} else {
				// That means we're in the middle of the text, basically, which is totally fine
				[first]
			}
		}
	}
}


// A small helper to join two paragrpahs
joinParagraphs(p1: WigiElement, p2: WigiElement) -> WigiParagraph {
	p1Elements = getWigiElementChildren(p1, false);
	p2Elements = getWigiElementChildren(p2, false);

	// Basically, we should try to join last text of p1 with the first text of p2, if possible
	lastp1 = lastElement(p1Elements, WigiEmpty());
	firstp2 = if (p2Elements != []) p2Elements[0] else WigiEmpty();

	// In case no joining is happening, we'll filter out WigiEmpty() and potentially WigiText("")
	noJoining = filter([lastp1, firstp2], \block -> getWigiChildCount(block, false) > 0);

	jointText = switch (lastp1: WigiElement) {
		WigiText(t1, s1): {
			switch (firstp2: WigiElement) {
				WigiText(t2, s2): {
					if (stylesEqual(s1, s2) || t1 == "" || t2 == "") {
						[WigiText(t1 + t2, s1)]	// Here the real joining happens
					} else {
						noJoining
					}
				}

				default: noJoining;
			}
		}

		default: noJoining;
	}

	newParagraphElements = concatA([subrange(p1Elements, 0, length(p1Elements) - 1), jointText, tail(p2Elements)]);

	newParagraphStyle = switch (p1: WigiElement) {
		WigiParagraph(e, s): s;
		default: [];
	}

	WigiParagraph(normalizeWigiElements(newParagraphElements), newParagraphStyle)
}

incParagraphNumbered(style : [WigiParagraphStyle]) -> [WigiParagraphStyle] {
	map(style, \st -> switch (st : WigiParagraphStyle) {
		Listed(type, s): Listed(
			switch (type : ListIndexType) {
				Numbered(n, t): Numbered(if (n > -1) n+1 else n, t);
				default: type;
			},
			s
		);
		default: st;
	});
}

maybeGetParagraphIndent(state: WigiEditorState, indent : WigiParagraphIndent) -> Maybe<double> {
	root = getValue(state.document);
	path = getValue(state.cursor);
	maybeParagraph = maybeGetParentWigiParagraph(root, path);
	switch (maybeParagraph) {
		None(): {
			None();
		}
		Some(pair): {
			paragraph = pair.first;
			fullStyle = getWigiParagraphStyleFull(state.defaultStyles, root, path, paragraph.style);
			Some(extractStruct(fullStyle, indent).indent);
		}
	}
}

maybeGetParentWigiParagraph(root: WigiElement, position: [int]) -> Maybe<Pair<WigiParagraph, [int]>> {
	parPath = findParentParagraph(root, position);
	if (parPath != []) {
		el = getElementAtPosition(root, parPath);
		switch (el) {
			WigiParagraph(__, __): Some(Pair(el, parPath));
			default: None();
		}
	} else {
		None()
	}
}

maybeGetParentWigiStory(root: WigiElement, position: [int]) -> Maybe<Pair<WigiStory, [int]>> {
	storyPath = findParentStory(root, position);
	el = if (storyPath != []) getElementAtPosition(root, storyPath) else root;
	switch (el) {
		WigiStory(__, __, __): Some(Pair(el, storyPath));
		default: None();
	}
}

// A little helper. Returns path to WigiElement which satisfies to checkFn or [] if not found
findParentObject(root: WigiElement, position: [int], checkFn: (WigiElement) -> bool) -> [int] {
	if (position == []) {
		[]
	} else {
		parent = wigiParentPath(position);
		parentElement = getElementAtPosition(root, parent);

		if (checkFn(parentElement)) parent else findParentObject(root, parent, checkFn)
	}
}

// A little helper. Returns path to WigiStory or [] if not found
findParentStory(root: WigiElement, position: [int]) -> [int] {
	findParentObject(root, position, \element -> {
		isSameStructType(element, WigiStory(ref [], ref [], []))
	})
}

// A little helper. Returns path to WigiParagraph or [] if not found
findParentParagraph(root: WigiElement, position: [int]) -> [int] {
	findParentObject(root, position, \element -> {
		isSameStructType(element, WigiParagraph([], []))
	})
}

isPositionStartOfParagraph(root: WigiElement, position: [int]) {
	parentParagraphPath = findParentParagraph(root, position);
	parentParagraph = getElementAtPosition(root, parentParagraphPath);

	switch (parentParagraph: WigiElement) {
		WigiParagraph(e, s): {
			paragraphStartPosition = concat(parentParagraphPath, getStartPositionOfDocument(parentParagraph));

			// Check here if paragraphStartPosition is a beginning of position
			subrange(position, 0, length(paragraphStartPosition)) == paragraphStartPosition
		}

		default: false
	}
}

isPositionEndOfParagraph(root: WigiElement, position: [int]) {
	parentParagraphPath = findParentParagraph(root, position);
	parentParagraph = getElementAtPosition(root, parentParagraphPath);

	switch (parentParagraph: WigiElement) {
		WigiParagraph(e, s): {
			paragraphEndPosition = concat(parentParagraphPath, getEndPositionOfDocument(parentParagraph, false));

			// Check here if paragraphEndPosition is a beginning of position
			subrange(position, 0, length(paragraphEndPosition)) == paragraphEndPosition
		}

		default: false
	}
}

doDeleteRange(state : WigiEditorState, wigiRootPath : [int], start : [int], end : [int], mergeElements : bool) -> void {
	if (start != end) {
		//    [0, 0, 0, 2]
		// -> [4, 0, 0]
		top = commonPath(start, end);
		if (isPositionParent(top, start) && isPositionParent(top, end)) {
			cursorTag = WigiBlock(WigiPositionTag(0), []);
			if (mergeElements) {
				pasteWigi(state, concat(wigiRootPath, end), cursorTag, false);
			}

			// calculate cursor position if we would need to fix it later
			newPosition = doPositionDelta(getValue(state.document), getValue(state.cursor), -1);

			// The same parent - we can do this
			n = length(top);
			si = start[n];
			ei = end[n];
			topPath = concat(wigiRootPath, top);
			deleteRangeInElement(state, topPath, si, ei, false);

			if (mergeElements) {
				setCursorWhereTagIs(state, wigiRootPath, cursorTag, false);
			}
		} else {
			root = getElementAtPosition(getValue(state.document), wigiRootPath);

			// Do three deletes: (1-2-3)
			// We should not join if start is at the start of the paragraph OR end is at the end of paragraph
			tryToJoinParagraphs = ref true;
			if (isPositionStartOfParagraph(root, start) || isWigiPageBreak(getElementAtPosition(root, start))) { //case LSTSBU-3
				tryToJoinParagraphs := false;
			} else if (isPositionEndOfParagraph(root, end)) {
				tryToJoinParagraphs := false;
			}

			tryToRemoveEmptyParagraph = ref true;

			// The start of the last element to the end (3)
			if (top != end) {
				lastTop = arrayPush(top, end[length(top)]);
				lastTopElement = getElementAtPosition(root, lastTop);
				lastTopElementEnd = getEndPositionOfDocument(lastTopElement, false);

				if (lastTopElementEnd == getStartPositionOfDocument(lastTopElement)) {
					// Special case here of deleting empty paragraph
					// We should delete this empty thing
					topIndex = lastElement(lastTop, -1);
					deleteRangeInElement(state, concat(wigiRootPath, top), topIndex, topIndex + 1, false);
					wigiSetCursor(state, start, false);

					tryToRemoveEmptyParagraph := false;
				} else {
					startLast = concat(lastTop, getStartPositionOfDocument(lastTopElement));
					doDeleteRange(state, wigiRootPath, startLast, end, false);
				}
			}

			// The next element from the first child to the previous elements of the last element (2)
			tl = length(top);
			if (length(start) > tl && length(end) > tl) {
				deleteFrom = start[tl] + 1;
				deleteTo = end[tl];
				topElement2 = getElementAtPosition(getValue(state.document), concat(wigiRootPath, top));	// We can't use topElement here, because it might have old value

				// We shouldn't be joining paragraphs if we're not in the story
				if (^tryToJoinParagraphs) {
					switch (topElement2: WigiElement) {
						WigiStory(__, __, __): {}
						default: tryToJoinParagraphs := false;
					}
				}

				if (deleteTo > deleteFrom) {
					deleteRangeInElement(state, concat(wigiRootPath, top), deleteFrom, deleteTo, false);
					{}
				}
			}

			// The part in the first child to the end of that child (1)
			if (top != start) {
				startTop = arrayPush(top, start[length(top)]);
				startTopElement = getElementAtPosition(getValue(state.document), concat(wigiRootPath, startTop));
				startTopElementEnd = getEndPositionOfDocument(startTopElement, false);

				endStart = concat(startTop, startTopElementEnd);
				if (^tryToRemoveEmptyParagraph && getStartPositionOfDocument(startTopElement) == startTopElementEnd) {
					// Special case here of deleting empty paragraph
					// We should delete this empty thing
					topIndex = lastElement(startTop, -1);
					deleteRangeInElement(state, concat(wigiRootPath, top), topIndex, topIndex + 1, true);
					wigiSetCursor(state, start, false);
				} else {
					doDeleteRange(state, wigiRootPath, start, endStart, mergeElements); // Maybe recursive flag for true at the end?
					// [-Explain-] workaround for tailscalls optimization in js
					nop();
				}
			}

			// Try to join paragraphs afterwards
			if (^tryToJoinParagraphs) {
				// Let's find the two paragraphs we should join
				// "start" is now between paragraphs we should join

				// Let's try to find our paragraph
				position = wigiParentPath(start);

				// Element at position should be the last element of our wanted paragraph
				firstParagraphPath = wigiParentPath(concat(wigiRootPath, position));
				firstParagraph = getElementAtPosition(getValue(state.document), firstParagraphPath);

				firstParagraphIndex = lastElement(firstParagraphPath, 0);

				parentStoryPath = wigiParentPath(concat(wigiRootPath, firstParagraphPath));
				parentStory = getElementAtPosition(getValue(state.document), parentStoryPath);

				switch (parentStory: WigiElement) {
					WigiStory(paragraphs, views, style): {
						if (firstParagraphIndex < length(^paragraphs) - 1) {	// Second paragraph exists
							secondParagraph = ^paragraphs[firstParagraphIndex + 1];

							newParagraph = joinParagraphs(firstParagraph, secondParagraph);
							newParagraphs = concatA([subrange(^paragraphs, 0, firstParagraphIndex), [newParagraph], tailFrom(^paragraphs, firstParagraphIndex + 2)]);

							newStory = makeWigiStory(newParagraphs, style);
							replaceElementInDocument(state, parentStoryPath, newStory);
						}
					}

					default: {}
				}
			}
		}

		// Clear the selection
		nextDistinct(state.selection, wigiClearSelection(getValue(state.document)));
	}
}

canElementBeEmpty(element: WigiElement) {
	switch (element) {
		WigiText(t, s): true;
		default: false;
	}
}

// Check if all elements can be deleted - it means that all elements
// in the range are unlocked
canDeleteInRange(e : WigiElement, start : int, end : int) -> bool {
	isAllUnlocked = \elems, k, m -> {
		!exists(subrange(elems, k, m), \el -> !isUnlockedWigiElement(el))
	}

	switch (e : WigiElement) {
		WigiParagraph(elements, style): isAllUnlocked(elements, start, end);
		WigiText(t, style): isUnlockedWigiElement(e);
		WigiDocument(r, s): false;
		WigiEmpty(): true;
		WigiStory(paragraphs, views, style): isAllUnlocked(^paragraphs, start, end);
		WigiRecursive(elements, type, style): isAllUnlocked(elements, start, end);
		WigiBlock(type, style): isUnlockedWigiElement(e);
	}
}

// Deletes elements from `start` to `end` including `start`, but not `end`
// Returns true if deletion was performed. False means that we need to handle it below in the document hierarchy
// Sometimes after deleting range in an element, the calling code wants other elements stay in their places, that is no merging
deleteRangeInElement(state : WigiEditorState, top : [int], start : int, end : int, doMerge: bool) -> bool {
	e = getElementAtPosition(getValue(state.document), top);

	numChildren = getWigiChildCount(e, false);
	if (end > numChildren) {
		println("Incorrect call to deleteRangeInElement!");
	}

	// If some of elements in the range [start, end) are locked, then we cannot delete.
	if (!isLockEditAllowed(state) && !canDeleteInRange(e, start, end)) {
		false;
	} else if (numChildren <= end - start) {	// Element will become empty
		if (top != []) {
			// `e` element becomes empty, so we might want to delete from document completely
			topwigiParentPath = wigiParentPath(top);
			parent = getElementAtPosition(getValue(state.document), topwigiParentPath);
			eIndex = lastElement(top, -1);

			if (!hasFixedChildCount(parent) && !isWigiComap(parent)) {
				if (!deleteRangeInElement(state, topwigiParentPath, eIndex, eIndex + 1, doMerge)) {
					if (canElementBeEmpty(e)) {
						ne = doDeleteRangeInElement(e, start, end, doMerge);
						if (ne != e) {
							replaceElementInDocument(state, top, ne);
						}
						true
					} else {
						// Element cannot be empty, so we don't delete it
						false
					}
				} else {
					true
				}
			} else {	// We shouldn't delete child, just replace it (usually with WigiText(""))
				if (canElementBeEmpty(e)) {
					ne = doDeleteRangeInElement(e, start, end, doMerge);
					if (ne != e) {
						replaceElementInDocument(state, top, ne);
					}
					true
				} else {
					// Cannot replace here, level down
					false
				}
			}
		} else {
			// Whole document deleted, create a new document with saved styles
			ss = findAllStylesInsideStory(e); // triple of styles (txtStyle, parStyle, storyStyle)
			replaceElementInDocument(state, top, getEmptyStoryWithDefinedStyles(ss));
			// And make sure to set cursor properly
			next(state.cursor, [0, 0, 0]);
			true
		}
	} else {
		if (!hasFixedChildCount(e)) {	// We can actually delete
			ne = doDeleteRangeInElement(e, start, end, doMerge);

			if (ne != e) {
				// Simply replace the element
				replaceElementInDocument(state, top, ne);
			}

			true
		} else {
			// We can't delete the whole element from something that has fixed number of children.
			// But we replace this element with empty wigi content
			switch(e : WigiElement) {
				WigiRecursive(elements, rtype, rstyle): {
					clearingRange = subrange(elements, start, end - start);
					iteri(clearingRange, \i, el -> {
						replaceElementInDocument(state, concat(top, [start + i]), getClearedRecursiveChild(el));
					});
					true
				}
				default: false;
			}
		}
	}
}


// according to the type of rChild return empty story, empty recursive or unchanged rChild with saved styles
getClearedRecursiveChild(rChild : WigiElement) -> WigiElement {
	switch (rChild : WigiElement) {
		WigiRecursive(elements, rtype, rstyle): {
			emptyStory = getEmptyStoryWithDefinedStyles(findAllStylesInsideStory(elementAt(elements, 0, WigiEmpty())));
			WigiRecursive([emptyStory], rtype, rstyle)
		}
		WigiStory(__, __, __): getEmptyStoryWithDefinedStyles(findAllStylesInsideStory(rChild));
		default: rChild
	}
}

doDeleteRangeInElement(e : WigiElement, start : int, end : int, doMerge: bool) -> WigiElement {
	switch (e : WigiElement) {
		WigiDocument(__, __): {
			println("Not supported");
			e;
		}
		WigiStory(paragraphs, views, __): {
			elements = ^paragraphs;
			paragraphs := concat(subrange(elements, 0, start), subrange(elements, end, length(elements) - end));
			// Iterate over the views and get rid of the corresponding elements there
			iter(^views, \v : TropicArray<WigiElement> -> {
				fori(1, end - start, \i -> {
					// Notice we remove from the last so the indexes do not change under our feet
					removeTropicArray(v, end - i);
				});
			});
			e;
		}
		WigiParagraph(elements, style): {
			remainedElements = concat(subrange(elements, 0, start), subrange(elements, end, length(elements) - end));
			preparedElements = if (length(remainedElements) == 1) {
				switch (remainedElements[0] : WigiElement) {
					WigiBlock(type, __): {
						switch (type : WigiBlockType) {
							// After deleting whole content of paragraph (for user it is like line) we stay on current line.
							WigiPositionTag(__): {
								firstTextStyle : DynamicBehaviour<[WigiTextStyle]> = make([]);
								deletedElements = subrange(elements, start, end - start);

								// Save style of first WigiText element, that appears among deletedElements
								iteriUntil(deletedElements, \i, delElement -> {
									switch (delElement : WigiElement) {
										WigiText(__, st): {
											nextDistinct(firstTextStyle, st);
											true
										}
										default: false;
									}
								});

								emptyTextWithSavedStyle = WigiText("", getValue(firstTextStyle));
								concat([emptyTextWithSavedStyle], remainedElements);
							}
							default : remainedElements;
						}
					}
					default: remainedElements;
				}
			} else remainedElements;
			mergedElements = if (doMerge) mergeParagraphElements(preparedElements) else preparedElements;
			WigiParagraph(mergedElements, style);
		}
		WigiRecursive(elements, type, style): {
			WigiRecursive(concat(subrange(elements, 0, start), subrange(elements, end, length(elements) - end)), type, style);
		}
		WigiBlock(__, __): {
			if (start < end) WigiEmpty() else e;
		}
		WigiText(t, style): WigiText(strLeft(t, start) + strRight(t, end), style);
		WigiEmpty(): e;
	}
}

wigiNewParagraph(state : WigiEditorState, position: [int]) -> void {
	makeObjectEndHandler = \elements -> {
		\doc, path -> {
			objectPath = wigiFindParentRecursive(doc, elements, path);
			if (objectPath != []){
				object = getElementAtPosition(doc, objectPath);
				objectEndPos = concat(objectPath, getEndPositionOfDocument(object, false));
				path == objectEndPos;
			} else {
				false;
			}
		}
	}

	isRecursiveElementEnd = makeObjectEndHandler([
		dummyWigiTableCell,
		dummyWigiSpreadsheetCell,
		dummyWigiExternalRecursive,
	]);
	isWigiRadioOptionEnd = makeObjectEndHandler([dummyWigiRadioOption]);

	getNewParagraphTextStyle = \ -> {
		elementAtCursor = getElementAtPosition(getValue(state.document), getValue(state.cursor));

		switch (elementAtCursor: WigiElement) {
			WigiText(tt, ts): ts;
			default: [];
		}
	}

	positionIndex = lastElement(position, 0);

	currentPath = wigiParentPath(position);
	currentElement = getElementAtPosition(getValue(state.document), currentPath);

	parentElementPath = wigiParentPath(currentPath);
	parentElement = getElementAtPosition(getValue(state.document), parentElementPath);

	indexInParent = lastElement(currentPath, -1);

	cursorTag = WigiBlock(WigiPositionTag(0), []);

	commonNewParagraphAction = \ -> {
		nextPosition = if (isWigiRadioOptionEnd(getValue(state.document), position)) {
			// specific case for Enter at the end of WigiRadioOption #38761
			doPositionDelta(getValue(state.document), currentPath, 2)
		} else {
			arrayPush(wigiParentPath(currentPath), lastElement(currentPath, -1) + 1)
		}
		wigiNewParagraph(state, nextPosition);
	}

	switch (currentElement: WigiElement) {
		WigiText(text, style): {
			// Need to split the text unless position is before start or after the end
			// Let's handle extreme cases first, though
			if (positionIndex == 0) {
				wigiNewParagraph(state, currentPath);
			} else if (positionIndex == strlen(text)) {
				commonNewParagraphAction();
			} else {	// Common case, split the text
				leftPart = WigiText(strLeft(text, positionIndex), style);
				rightPart = WigiText(substring(text, positionIndex, strlen(text) - positionIndex), style);

				// Let's replace our text with leftPart and rightPart
				brothers = getWigiElementChildren(parentElement, false);
				newBrothers = concatA([
					subrange(brothers, 0, indexInParent), // Whatever was before break
					[leftPart, rightPart],
					tailFrom(brothers, indexInParent + 1)	// And the rest of other texts
				]);

				// The parent here should be a paragraph
				newParent = switch (parentElement: WigiElement) {
					WigiParagraph(e, s): {
						WigiParagraph(newBrothers, s);
					}
					default: {
						WigiText("Shouldn't happen, text is contained inside " + parentElement.structname, [Fill(red)])
					}
				}

				replaceElementInDocument(state, parentElementPath, newParent);

				// And now we can split
				wigiNewParagraph(state, arrayPush(parentElementPath, indexInParent + 1));
			}
		}

		WigiParagraph(elements, style): {
			leftPart = subrange(elements, 0, positionIndex);
			rightPart = ref tailFrom(elements, positionIndex);

			// We need to find out what text style to use in a new paragraph, see case http://process.area9.dk/cases/default.asp?30625
			newTextStyle = getNewParagraphTextStyle();
			newEmptyText = WigiText("", newTextStyle);

			leftParagraphStyle = if (elements == [newEmptyText]) {
				removeAllStructs(style, dummyListed)
			} else {
				style
			}

			if (^rightPart == []) {	// We will create a new paragraph, so let's add an empty text there
				rightPart := [newEmptyText];
			}

			leftParagraph = WigiParagraph(
				if (leftPart != []) leftPart else [newEmptyText],
				leftParagraphStyle
			);

			nextParagraphStyle = filter(leftParagraphStyle, \s -> {
				switch (s) {
					WigiAspect(exType, __) : eitherMap(
						getExternalBlockAPI(exType),
						\api -> !containsStruct(api.style, RemoveElementWhenCopy()),
						true
					);
					default: true;
				}
			});

			brothers = getWigiElementChildren(parentElement, false);
			newBrothers = concatA([
				subrange(brothers, 0, indexInParent), // Whatever was before break
				[leftParagraph], 	// Left part of the broken paragraph
				[WigiParagraph(
					concat([cursorTag], ^rightPart), // Cursor and the rest of the current paragraph
					incParagraphNumbered(nextParagraphStyle)
				)], // Cursor and the rest of the current paragraphs
				tailFrom(brothers, indexInParent + 1)	// And the rest of other paragraphs
			]);

			// The parent here can be a story or WigiRecursive or who knows what
			newParent = switch (parentElement: WigiElement) {
				WigiStory(paragraphs, views, s): {
					makeWigiStory(newBrothers, s)
				}
				default: {
					WigiText("TODO: Insert new paragraph into " + parentElement.structname, [Fill(red)])
				}
			}

			// Replace currentElement with leftPart
			replaceElementInDocument(state, parentElementPath, newParent);

			// Finally, set the cursor
			setCursorWhereTagIs(state, parentElementPath, cursorTag, false);

			// Normalize content, because we might have cut the paragraph right after/before recursive
			normalizeContent(state, parentElementPath) |> ignore;
		}

		WigiBlock(type, style): {
			// Let's deal with the page break right away
			switch (type: WigiBlockType) {
				WigiPageBreak(__, __): {
					// We should be directly inside a top-most story
					afterBreakPosition = arrayPush(wigiParentPath(currentPath), lastElement(currentPath, -1) + 1);
					wigiNewParagraph(state, afterBreakPosition);
				}
				default: {
					// Normal block in a paragraph
					// That's pretty easy, just go one level up, but it depends on whether we are behind this block or after it
					if (positionIndex > 0) commonNewParagraphAction()
					else wigiNewParagraph(state, currentPath);
				}
			}
		}

		WigiStory(paragraphs, views, style): {
			// Let's see if we are trying to insert new paragraph at the last element of the story which is at the same time a page break
			// See unit test: new_line_after_last_page_break.test
			if (lastElement(position, -1) == length(^paragraphs) && isWigiPageBreak(lastElement(^paragraphs, WigiEmpty()))) {
				// Just add a new paragraph to the story
				newParagraph = WigiParagraph([WigiText("", getNewParagraphTextStyle())], [TightWidth()]);
				newParagraphs = arrayPush(^paragraphs, newParagraph);
				newStory = makeWigiStory(newParagraphs, style);
				replaceElementInDocument(state, currentPath, newStory);

				wigiSetCursor(state, concat(position, getEndPositionOfDocument(newParagraph, false)), false);
			} else {
				// We should be able to get away with letting paragraph do our job
				positionElement = getElementAtPosition(getValue(state.document), position);
				newPosition = concat(position, getStartPositionOfDocument(positionElement));

				wigiNewParagraph(state, newPosition);
				wigiMoveCursor(state, -1, false);
			}
		}

		default: {
			println("New paragraph is not implemented inside: " + currentElement.structname);
		}
	}

	// apply current styles for new paragraph, except WigiParagraphExternalStyle, where cleared == true
	changeSelectionStyle(state, WigiModifyParagraphStyle(filterWigiParagraphExternalStyle));
	setCursorInFirstWigiTextOfParagraph(state);
}

extractRangeFromElement(e: WigiElement, start: int, end: int) -> WigiElement {
	switch (e : WigiElement) {
    	WigiParagraph(elements, style): {
    		WigiParagraph(subrange(elements, start, end), style);
		}
		WigiText(t, style): WigiText(substring(t, start, end - start), style);
		WigiDocument(r, s): {
			println("Not supported");
			e;
		}
		WigiEmpty(): e;
		WigiStory(paragraphs, views, style): {
			elements = ^paragraphs;
			newElements = subrange(elements, start, end - start);

			makeWigiStory(newElements, style)
		}
		WigiRecursive(elements, type, style): {
    		WigiRecursive(subrange(elements, start, end), type, style);
		}
		WigiBlock(type, style): e;
	}
}

extractWigiRange(root : WigiElement, start : [int], end : [int]) -> WigiElement {
	if (start == end) {
		makeWigiDocument("");
	} else {
		rectSelectionMaybe = getRectangularSelection(WigiSelection(start, end), root, false);
		switch (rectSelectionMaybe: Maybe<RectangularSelection>) {
			Some(rectSelection): {
				extractRectangularWigiRange(root, rectSelection);
			}
			None(): {
				extractRegularWigiRange(root, start, end);
			}
		}
	}
}

// See case http://process.area9.dk/cases/default.asp?34399
// Basically we need to return a table that has only selected cells in it
// We know it is rectangular, so it should be possible to handle merged cells properly
extractRectangularWigiRange(root : WigiElement, rectSelection: RectangularSelection) -> WigiElement {
	// We know it's a table
	table = cast(getElementAtPosition(root, rectSelection.path): WigiElement -> WigiRecursive);
	tableType = cast(table.type: WigiRecursiveType -> WigiTable);

	// We basically need to filter on elements and cell spans that are selected
	selectedCells = concatA(mapi(table.elements, \i, el -> if (rectSelection.isInside(i)) [el] else []));
	selectedCellSpans = concatA(mapi(tableType.cellSpans, \i, cs -> if (rectSelection.isInside(i)) [cs] else []));

	WigiRecursive(
		selectedCells,
		WigiTable(rectSelection.maxRow - rectSelection.minRow + 1, rectSelection.maxCol - rectSelection.minCol + 1, selectedCellSpans, tableType.style),
		table.style
	)
}

// Makes a copy, and then deletes everything before and after selection
extractRegularWigiRange(root : WigiElement, start : [int], end : [int]) -> WigiElement {
	commonRootPath = commonPath(start, end);
	commonRootElement = getElementAtPosition(root, commonRootPath);

	// Let's handle particular case when we select part of the text
	switch (commonRootElement: WigiElement) {
		WigiText(text, style): {
			s = lastElement(start, 0);
			e = lastElement(end, 0);
			WigiText(substring(text, s, e - s), style)
		}
		// TODO: add special case for recursive extraction
		// (now we cannot extract only some recursive's children, because recursive type is selected also)
		default: {	// General case. Create copy of the commonRootElement and then delete everything, but selection from it
			n = length(commonRootPath);

			startTail = tailFrom(start, n);
			endTail = tailFrom(end, n);

			copy = wigiForStorage(commonRootElement, false);
			// TODO: figure out style dictionary?!

			// TODO: avoid local state creation
			state = makeWigiEditorState(copy, None(), [SetLockStatus(Some(true))]);

			copyStart = getStartPositionOfDocument(copy);
			copyEnd = getEndPositionOfDocument(copy, false);

			doDeleteRange(state, [], endTail, copyEnd, false);
			doDeleteRange(state, [], copyStart, startTail, false);

			// We can have some empty recursives in our copy, let's delete them by moving cursor around a bit
			wigiMoveCursor(state, 1, false);
			wigiMoveCursor(state, -1, false);

			getValue(state.document)
		}
	} |> simplifyElement
}

// Nice helper that lets us find tag position. It can just find the tag or also remove it and return position that corresponds to it after removal
// If preserveParagraph is not set, then we'll delete the paragraph that contains our tag block (if there was nothing else in the paragraph)
findTagPosition(state: WigiEditorState, wigiRootPath: [int], tag: WigiElement, removeTag: bool, preserveParagraph: bool) -> [int] {
	// Let's find our tag
	rootElement = getElementAtPosition(getValue(state.document), wigiRootPath);
	tagPath = findWigiElement(rootElement, tag);

	if (tagPath != []) {
		foundTag = concat(wigiRootPath, tagPath);
		tagPosition = lastElement(foundTag, -1);

		positionParent = wigiParentPath(foundTag);
		positionParentElement = getElementAtPosition(getValue(state.document), positionParent);
		position = lastElement(tagPath, -1);

		// If out position tag is the only thing in the paragraph, it means we want to preserve the paragraph
		tryReplaceWithEmptyText = ref false;

		// Now we need to find out position
		finalPosition = ref {
			if (position == getWigiChildCount(positionParentElement, true) - 1) {
				// Position is at the end of parent

				// We can be at the beginning of the parent as well
				if (position == 0) {
					if (preserveParagraph) {	// We will just replace this block with empty text
						tryReplaceWithEmptyText := true;
						arrayPush(foundTag, 0)
					} else {
						// We still need to delete the tag (and parent paragraph)
						// So, correct position will be the start of the next element
						nextElementPath = ref doPositionDelta(rootElement, tagPath, 1);
						nextElement = ref getElementAtPosition(rootElement, ^nextElementPath);

						if (^nextElement == tag) {
							// Need to make one more step forward, meh :(
							nextElementPath := doPositionDelta(rootElement, ^nextElementPath, 1);
							nextElement := getElementAtPosition(rootElement, ^nextElementPath);
						}

						// We need to patch our path once again, because we're going to delete parent paragraph
						if (lastElement(^nextElementPath, 0) != 0)
							nextElementPath := arrayPush(subrange(^nextElementPath, 0, length(^nextElementPath) - 1), lastElement(^nextElementPath, 1) - 1);

						concat(wigiRootPath, concat(^nextElementPath, getStartPositionOfDocument(^nextElement)))
					}
				} else {
					prevElementPath = doPositionDelta(rootElement, tagPath, -1);
					prevElement = getElementAtPosition(rootElement, prevElementPath);

					concatA([wigiRootPath, prevElementPath, getEndPositionOfDocument(prevElement, true)])
				}
			} else {
				// Let's place it at the beginning of the next (after the tag) element
				// This way it will be safe to delete the tag itself
				nextElementPath = doPositionDelta(rootElement, tagPath, 1);
				nextElement = getElementAtPosition(rootElement, nextElementPath);

				// We can be at the end of the document
				if (nextElement == tag) {
					tryReplaceWithEmptyText := true;
					arrayPush(foundTag, 0)	// 0 will be the index inside empty text that our tag will be replaced with
				} else {
					concat(foundTag, getStartPositionOfDocument(nextElement))
				}
			}
		}

		// Delete the tag
		if (removeTag) {
			// Join texts if tag was between two texts with identical styles
			oldElements = getWigiElementChildren(positionParentElement, false);

			// All, but position
			elements = concat(subrange(oldElements, 0, position), tailFrom(oldElements, position + 1));

			// Try to join elements[position - 1] && elements[position]
			jointElement = ref WigiEmpty();

			if (position >= 1 && position < length(elements)) {
				switch (elements[position - 1]: WigiElement) {
					WigiText(t1, s1): {
						switch (elements[position]: WigiElement) {
							WigiText(t2, s2): {
								if (stylesEqual(s1, s2) || isEmptySelection(getValue(state.selection))){
									if (stylesEqual(s1, s2)) {
										jointElement := WigiText(t1 + t2, s1);
									}
									// We need to adjust final position, it will be inside the text
									finalPosition := concat(positionParent, [position - 1, strlen(t1)]);
								}
							}
							WigiRecursive(els, type, style): {
								finalPosition := concat(positionParent, [position - 1, strlen(t1)]);
							}
							default: {}
						}
					}
					default: {}
				}
			}

			if (^jointElement != WigiEmpty()) {
				// Here we need to replace elements[position - 1], elements[position] with ^jointElement and re-calculate finalPosition a little bit
				switch (positionParentElement: WigiElement) {
					WigiParagraph(els, style): {
						newEls = concatA([
							subrange(elements, 0, position - 1),
							[^jointElement],
							tailFrom(elements, position + 1)
						]);

						newParagraph = WigiParagraph(newEls, style);
						replaceElementInDocument(state, positionParent, newParagraph);
					}
					default: {
						println("Expected to always have WigiParagraph here, got:");
						println(positionParentElement);
					}
				}
			} else {
				// No joining, we can simply remove element at `position`. Remember, we still didn't do that!
				// But there is a special case if our block is the only thing in our paragraph, then it should be replaced by empty text

				// With "false" here it deletes an empty paragraph when changing its style. So the test "change_style_in_empty_paragraph" fails.
				// One more special case to when to replace with empty text is the beginning of the paragraph when next element is a recursive (to preserve our beloved invariant)
				brothers = getWigiElementChildren(positionParentElement, false);
				n = length(brothers);
				forceReplaceWithEmptyText = n >= 2 && (brothers[0] == tag && isWigiRecursive(brothers[1], [])
					|| brothers[n-1] == tag && isWigiRecursive(brothers[n-2], []));

				replaceByEmptyText = forceReplaceWithEmptyText || (^tryReplaceWithEmptyText && (brothers == [tag]));

				replaceTagWithEmptyText = \ -> {
					// Hmm, we didn't delete the block, actually.
					// That could happen because we have only this block left here, but an element cannot be deleted and cannot be empty.
					// In this special case let's replace with WigiText("")
					// We cannot record test on style change in this case, because of delay in updating styles in the state
					replaceElementInDocument(state, concat(wigiRootPath, tagPath), WigiText("", getTextStyleFromToolbar(state)));
					finalPosition := arrayPush(concat(wigiRootPath, tagPath), 0);
				}

				if (preserveParagraph && replaceByEmptyText) {
					replaceTagWithEmptyText();
				} else {
					deletionRangeResult = deleteRangeInElement(state, positionParent, position, position + 1, true);

					positionDelta = switch (positionParentElement : WigiElement) {
						WigiParagraph(els, style): length(mergeParagraphElements(subrange(els, 0, position))) - position;
						default: 0;
					}

					if (!deletionRangeResult) {
						replaceTagWithEmptyText();
					} else if (positionDelta != 0) {
						newPrevPos = concat(positionParent, [(position - 1) + positionDelta]);
						finalPosition := concat(newPrevPos, getEndPositionOfDocument(getElementAtPosition(getValue(state.document), newPrevPos), false));
					}
				}
			}
		}

		// Now, we are ready
		^finalPosition
	} else {
		// We couldn't find a tag, no problem, let's search upper in the hierarchy
		if (wigiRootPath != []) {
			findTagPosition(state, wigiParentPath(wigiRootPath), tag, removeTag, preserveParagraph);
		} else {	// We finally failed to find tag, give up
			println("We couldn't find tag and set cursor");
			[]
		}
	}
}

// A small helper to set cursor where tag points, search starts from wigiRootPath
setCursorWhereTagIs(state: WigiEditorState, wigiRootPath: [int], tag: WigiElement, preserveParagraph: bool) {
	cursor = findTagPosition(state, wigiRootPath, tag, true, preserveParagraph);

	if (cursor != []) {
		wigiSetCursor2(state, positionCursorInElement(getValue(state.document), cursor), false, false);
	}
}

pasteWigiAndNormalize(state: WigiEditorState, position: [int], content: WigiElement, moveCursor: bool) -> void {
	pasteWigi(state, position, content, moveCursor);

	// We need to get some position upper in hierarchy than `position`, but not always the root of the document
	// Let's try to go 3 levels up... What a hack!
	normalizeContent(state, wigiParentPath(wigiParentPath(wigiParentPath(position)))) |> ignore;
}

pasteWigi(state: WigiEditorState, position: [int], content: WigiElement, moveCursor: bool) -> void {
	document = getValue(state.document);

	// We are very often inserting inside some text here, in fact
	// Let's find the element we're inserting into
	curElementPath = wigiParentPath(position);
	curElement = getElementAtPosition(document, curElementPath);
	posInCurElement = lastElement(position, - 1);

	cursorTag = WigiBlock(WigiPositionTag(2), []);

	pasteInParent = \ -> {
		if (posInCurElement == 0) {
			pasteWigi(state, curElementPath, content, moveCursor)
		} else {
			pastePath = arrayPush(wigiParentPath(curElementPath), lastElement(curElementPath, -1) + 1);
			pasteWigi(state, pastePath, content, moveCursor);
		}
	}

	// Let's see where we insert our content into
	switch (curElement: WigiElement) {
		WigiEmpty(): {	// We can't really be here
			println("Inserting into empty element, how can that happen?");
		}

		WigiText(text, style): {	// We're inserting something in the middle of the text. That's the most common case
			// Assume, content is simplified already. Then it's either Text itself (1) or something bigger (2).
			// Let's handle case (1) first

			if (isWigiComap(content)) {
				// WigiComap must be inserted in story.
				pasteInParent();
			} else {
				switch (content: WigiElement) {
					WigiText(contentText, contentStyle): {
						if (stylesEqual(contentStyle, style)) {
							// We can simple join strings
							newText = strLeft(text, posInCurElement) + contentText + substring(text, posInCurElement, strlen(text) - posInCurElement);
							newElement = WigiText(newText, style);
							replaceElementInDocument(state, curElementPath, newElement);

							if (moveCursor) {
								// Let's set cursor
								cursor = arrayPush(curElementPath, posInCurElement + strlen(contentText));
								wigiSetCursor(state, cursor, false);
							}
						} else {
							// We have text with different style here, let's make a paragraph out of it and call ourselves recursively
							newContent = WigiParagraph([content], []);
							pasteWigi(state, position, newContent, moveCursor);
						}
					}

					WigiEmpty(): {
						// Nothing to do
					}

					default: {
						// Let's split our text into two parts

						len = strlen(text);
						indexInParent = lastElement(curElementPath, -1);

						leftPart = if (posInCurElement > 0) {
							WigiText(strLeft(text, posInCurElement), style)
						} else WigiEmpty();

						rightPart = if (0 <= posInCurElement && posInCurElement < len) {
							WigiText(substring(text, posInCurElement, len - posInCurElement), style)
						} else WigiEmpty();

						// Now we need to replace curElement in our parent with (leftPart, content, rightPart)
						parentElementPath = wigiParentPath(curElementPath);
						parentElement = getElementAtPosition(document, parentElementPath);


						// Here we need to replace original element with new ones
						// At first, let's delete original element, but if it was the only element in parent, we shouldn't delete parent

						newParentElement = doDeleteRangeInElement(parentElement, indexInParent, indexInParent + 1, false);
						if (newParentElement != parentElement) {
							replaceElementInDocument(state, parentElementPath, newParentElement);
						}

						insertPosition = arrayPush(parentElementPath, indexInParent);

						if (rightPart != WigiEmpty()) {
							pasteWigi(state, insertPosition, rightPart, false);
						}

						if (moveCursor) {
							switch(content) {
								WigiBlock(__, __): { }
								default: {
									// Insert marker for future cursor position
									pasteWigi(state, insertPosition, cursorTag, false);
								}
							}

						}

						pasteWigi(state, insertPosition, content, false);

						if (leftPart != WigiEmpty()) {
							pasteWigi(state, insertPosition, leftPart, false);
						}

						if (moveCursor) {
							switch(content) {
								WigiBlock(__, __): {
									nextPos = doPositionDelta(getValue(state.document), position, 1);
									wigiSetCursor(state, nextPos, false)
								}
								default: {
									// Remember, we inserted marker a few lines above? Let's use it now
									setCursorWhereTagIs(state, parentElementPath, cursorTag, false);
								}
							}

						}
					}
				}
			}
		}

		WigiParagraph(elements, style): {
			if (false && isWigiComap(content)) {
				// Update: This does not work well, since we have assumptions elsewhere which break with this
				// WigiComap must be inserted in story.
				pasteInParent();
			} else {
				switch (content: WigiElement) {
					WigiEmpty(): {
						// Nothing to do
					}

					default: {
						// When we have a paragraph, we insert its children, but also respect its styles.
						paragraphStyles = ref [];
						elementsToInsert = switch (content: WigiElement) {
							WigiEmpty(): [];
							WigiParagraph(e, s): {
								paragraphStyles := s;
								e
							}
							WigiStory(paragraphs, views, contentStyle): {
								// Here we need to do some clever paste, not just insert the whole story as a single element
								// We have more than 1 paragraph. We need to split our host paragraph into two parts - hostHead, hostTail
								// Then we generally have 3 parts to be inserted:
								// *firstContentPart* The first paragraph - its children should be just added at the end of hostHead
								// *middleContentPart* Paragraphs in the middle - those should be added to a story between
								// *lastContentPart* The last paragraph - its children should be added at the beginning of hostTail

								// The overall scheme of things is:
								/*
									LEGEND: <story>, {paragraph}, [text]

									BEFORE:
									<                       parent story                      >
									{parentStoryHead} {[hostHead] [hostTail]} {parentStoryTail}
									                  {    hostParagraph    }

									AFTER:
									<                                                  parent story                                                  >
									{parentStoryHead} {hostHead [firstContentPart]} {middleContentPart} {[lastContentPart] hostTail} {parentStoryTail}
									                  {        newHostHead        }                     {       newHostTail        }
								*/

								parentElementPath = wigiParentPath(curElementPath);
								parentElement = getElementAtPosition(document, parentElementPath);	// This is our parent story

								parentStoryStyle = switch (parentElement: WigiElement) {
									WigiStory(p, v, s): s;
									default: [];
								}

								indexInParentElement = lastElement(curElementPath, -1);
								parentElementChildren = getWigiElementChildren(parentElement, false);

								// Now, find out what our components are
								parentStoryHead = subrange(parentElementChildren, 0, indexInParentElement);
								parentStoryTail = tailFrom(parentElementChildren, indexInParentElement + 1);

								getPart = \part -> Pair(
									getWigiElementChildren(part, false),
									switch (part : WigiElement) {
										WigiParagraph(__, s): s;
										default: [];
									}
								);
								parNum = length(^paragraphs);
								firstPart = getPart(^paragraphs[0]);
								lastPart = getPart(^paragraphs[parNum - 1]);

								middleContentPart = if (parNum > 2) subrange(^paragraphs, 1, parNum - 2) else [];

								hostHead = subrange(elements, 0, posInCurElement);
								hostTail = tailFrom(elements, posInCurElement);

								// Let's construct new host head and tail
								newHostHead = WigiParagraph(
									concat(hostHead, firstPart.first),
									mergeWigiParagraphStyles(style, firstPart.second)
								);
								newHostTail = WigiParagraph(
									concatA([
										if (length(^paragraphs) == 1) hostHead else [],
										lastPart.first,
										(if (moveCursor) [cursorTag] else []),
										hostTail
									]),
									mergeWigiParagraphStyles(style, lastPart.second)
								);

								// Now that we have all components in place, let's construct a new story, and then replace our parentElement with it
								newStoryElements = concatA([
									parentStoryHead,
									if (parNum == 1) [] else [newHostHead],
									middleContentPart,
									[newHostTail],
									parentStoryTail
								]);

								newStory = makeWigiStory(newStoryElements, parentStoryStyle);

								// Finally, do the replace and hope for the best
								replaceElementInDocument(state, parentElementPath, newStory);

								// Now, deal with cursor
								if (moveCursor) {
									setCursorWhereTagIs(state, parentElementPath, cursorTag, false);
								};

								[]
							}
							default: [content];
						}

						if (elementsToInsert != []) {
							newElements = concat3(subrange(elements, 0, posInCurElement), elementsToInsert, subrange(elements, posInCurElement, length(elements)));
							newStyles = mergeWigiParagraphStyles(style, ^paragraphStyles);
							newElement = WigiParagraph(newElements, newStyles);
							replaceElementInDocument(state, curElementPath, newElement);

							lastInsertedElement = lastElement(elementsToInsert, WigiEmpty());

							// Cursor should be at the end of elementsToInsert
							if (moveCursor) {
								cursor = concatA([curElementPath, [posInCurElement + length(elementsToInsert) - 1], getEndPositionOfDocument(lastInsertedElement, true)]);
								wigiSetCursor(state, cursor, false);
							}
						}
					}
				}
			}
		}

		WigiStory(paragraphs, views, style): {
			if (isWigiComap(content)) {
				parentElement = getElementAtPosition(document, wigiParentPath(curElementPath));
				switch(parentElement) {
					WigiRecursive(__, __, __): pasteInParent();
					default: {
						newElement = WigiStory(ref insertArray(^paragraphs, posInCurElement, content), views, style);
						replaceElementInDocument(state, curElementPath, newElement);
					}
				}
			} else {
				switch (content: WigiElement) {
					WigiEmpty(): {}

					default: {
						println("TODO: Paste into story!");
					}
				}
			}
		}

		WigiRecursive(elements, type, style): {
			if (posInCurElement == 0) {
				pasteWigi(state, curElementPath, content, moveCursor);
			} else {
				pasteWigi(state, arrayPush(wigiParentPath(curElementPath), posInCurElement), content, moveCursor);
			}
		}

		WigiDocument(root, style): {
			println("Paste into document, shouldn't happen");
		}

		WigiBlock(type, style): {
			// We need to go one level up and insert into paragraph,
			// but we need to wisely decide position at where to do that

			// However, if it's a nasty page break, then it's contained directly inside a wigi story, and we need can paste
			// right before/after it
			if (isWigiPageBreak(curElement)) {
				// Let's paste after the page break
				// We pretty much know that we are in the top-most story
				newPosition = doPositionDelta(getValue(state.document), position, 1);
				if (newPosition != position) {
					pasteWigi(state, newPosition, content, moveCursor);
				} else {
					// We seem to be on the page break that ends the document
					wigiNewParagraph(state, position);
					pasteWigi(state, getValue(state.cursor), content, moveCursor);
				}
			} else {
				pasteInParent();
			}
		}
	}
}

// Merges adjacent texts if they have same style
mergeParagraphElements(elements: [WigiElement]) -> [WigiElement] {
	res: ref [WigiElement] = ref [];
	currentText: ref Maybe<WigiText> = ref None();

	flushText = \ -> {
		maybeApply(^currentText, \text -> {
			refArrayPush(res, text);
			currentText := None();
		});
	}

	appendText = \t: WigiText -> {
		currentText := eitherMap(^currentText, \curText -> {
			Some(WigiText(curText.text + t.text, curText.style))
		}, Some(t));
	}

	iter(elements, \e -> {
		switch (e: WigiElement) {
			WigiText(et, es): {
				switch (^currentText) {
					Some(curText): {
						if (stylesEqual(curText.style, es)) {
							appendText(e);
						} else {	// We cannot merge, just flush and start over
							flushText();
							currentText := Some(e);
						}
					}

					None(): {
						flushText();
						currentText := Some(e);
					}
				}
			}

			WigiRecursive(es, type, style): {
				flushText();
				refArrayPush(res, e);
			}

			default: {
				flushText();
				refArrayPush(res, e);
			}
		}
	});

	flushText();

	if (elements != [] && ^res == []) {	// Empty paragraph should in fact contain an empty text in it
		// We should figure out which style we should use
		elementStyle = fold(elements, [], \acc, el -> {
			switch (el: WigiElement) {
				WigiText(text, style): style;
				default: acc;
			}
		});

		res := [WigiText("", elementStyle)]
	}

	^res
}

// join arrays without their intesection
// for [1,2,2,3] and [3,4] it returns [1,2,2,4]
symmetricDifferenceA(a: [?], b: [?]) -> [?]{
	concat(subtractA(a, b), subtractA(b, a))
}

// Returns a pair of style updater and resolveWps flag which indicates that we should also resolve WigiStylesName
// to apply corresponding WPS styles
getParagraphStyleUpdater(event: WigiSetStyle) -> Maybe<Pair<([WigiParagraphStyle]) -> [WigiParagraphStyle], bool>> {
	switch (event: WigiSetStyle) {
		WigiSetParagraphStyle(toRemove, toAdd): {
			// it's indirect sign that it comes from clear paragraph formatting
			resolveWps = toRemove != [] && toAdd == [];

			Some(Pair(\fullStyle -> {
				strippedStyle = filter(fullStyle, \s -> !contains(toRemove, s))
					// if we remove Listed, we also remove any FirstLineIndent
					|>  (\ss -> if (extractStruct(toRemove, dummyListed) != dummyListed
									&& extractStruct(toAdd, dummyListed) == dummyListed)
								filter(ss, \s : WigiParagraphStyle -> !isSameStructType(s, FirstLineIndent(0.0)))
							else ss
						);
				concat(strippedStyle, toAdd);
			}, resolveWps));
		}
		WigiModifyParagraphStyle(updater) : Some(Pair(updater, false));
		WigiReplaceParagraphStyle(toReplace) : {
			resolveWps = isSameStructType(toReplace, WigiStylesName(""));
			Some(Pair(\fullStyle -> replaceStruct(fullStyle, toReplace), resolveWps))
		}
		default: None();
	}
}

applyParagraphStyles(elements : [WigiElement], styles : [WigiParagraphStyle], resolveWPS : bool, defaultStyles : [WigiStyles]) -> WigiParagraph {
	wpsName = extractStruct(styles, defaultWigiStylesName).name;
	resolveWps = resolveWPS && containsStruct(styles, defaultWigiStylesName);

	fullStyles = concat(
		styles,
		if (resolveWps) getWigiParagraphStyleFromParagraph(styles, defaultStyles, wpsName) else []
	);
	normalizedParagraphStyles = normalizeWigiParagraphStyle(fullStyles);
	elementsWithAspects = resolveWigiAspectStyles(elements, normalizedParagraphStyles);

	normalizedElements = normalizeWigiElements(elementsWithAspects);
	newElements = if (resolveWps) {
		map(normalizedElements, \e -> switch (e : WigiElement) {
			WigiText(__, __): setWigiTextStyleFromParagraph(e, defaultStyles, wpsName);
			default: e;
		})
	} else normalizedElements;

	WigiParagraph(newElements, normalizedParagraphStyles)
}

changeStyleInElement(state: WigiEditorState, root: [int], start: int, end: int, event: WigiSetStyle) -> void {
	// Let's check if our event demands changes in paragraph style
	// Then we might go a few levels up and do that. Otherwise we apply style to elements
	paragraphLevelStyle = getParagraphStyleUpdater(event);
	doc = getValue(state.document);
	curElement = getElementAtPosition(doc, root);
	styleDict = state.defaultStyles;

	switch (paragraphLevelStyle: Maybe<Pair<([WigiParagraphStyle]) -> [WigiParagraphStyle], bool>>) {
		Some(stylesUpdater): {
			handleChildren = \ -> {
				// Call change style for each child, we don't care about (start, end) because we'll be changing whole elements
				if (start == -1 && end == -1) {
					fori(0, getWigiChildCount(curElement, false) - 1, \i -> changeStyleInElement(state, arrayPush(root, i), -1, -1, event));
				} if (start == 0 && end == 0) {
					fori(0, getWigiChildCount(curElement, false) - 1, \i -> changeStyleInElement(state, arrayPush(root, i), -1, -1, event));
				} else {
					fori(start, end - 1, \i -> changeStyleInElement(state, arrayPush(root, i), -1, -1, event));
				}
			}

			switch (curElement: WigiElement) {
				WigiParagraph(elements, style): {
					fullStyle = getWigiParagraphStyleFull(styleDict, doc, root, style);
					newFullStyle = stylesUpdater.first(fullStyle);
					newParagraph = applyParagraphStyles(elements, newFullStyle, stylesUpdater.second, styleDict);
					newStyle = getWigiParagraphStyleShort(styleDict, doc, root, newParagraph.style);
					replaceElementInDocument(state, root, WigiParagraph(newParagraph.elements, newStyle));
				}

				WigiStory(paragraphs, views, style): {	// Change style in these paragraphs
					handleChildren();
				}

				WigiRecursive(elements, type, style): {
					handleChildren();
					updateWigiCell(curElement)
				}

				WigiEmpty(): {}

				default: {	// We're not a paragraph or paragraph container, i.e. not high enough in the hierarchy, let's go upper (if there is something)
					if (root != []) {
						parent = wigiParentPath(root);
						indexInParent = lastElement(root, 0);
						changeStyleInElement(state, parent, indexInParent, indexInParent + 1, event);
					}
				}
			}
		}
		None(): {	// This is not a paragraph-level change, apply it to elements then
			applyStyle = \style: [WigiStyle] -> {
				styleToAdd = switch (event: WigiSetStyle) {
					WigiSetColor(color): [Fill(color)];
					WigiSetBackgroundColor(color): if (color != 0) [
						BackgroundFill(getRGB(color)),
						BackgroundFillOpacity(getOpacity(color))
					] else [];
					WigiSetFontSize(fontSize): [FontSize(fontSize)];
					WigiModifyFontSize(baseSize, baseShift): {
						fontSize : FontSize = extractStruct(style, FontSize(11.0));
						delta = if (baseSize > 0.0) {
							(fontSize.size / baseSize) * baseShift;
						} else {
							0.0
						};
						[FontSize(fontSize.size + delta)];
					}
					WigiSetFontFamily(fontFamily): [FontFamily(fontFamily)];
					WigiSwitchFontFamily(fontFamilyStyle, turnOn): {
						currentFontFamily = extractStruct(style, FontFamily("Book")).name;
						newFont = switchWigiMappedFont(currentFontFamily, fontFamilyStyle, Some(turnOn));
						[FontFamily(newFont)]
					}
					WigiSetUnderline(hasUnderline): if (hasUnderline) [Underline()] else [];
					WigiSetDoubleUnderline(hasUnderline): if (hasUnderline) [DoubleUnderline()] else [];
					WigiClearTextFormatting(): [];
					WigiSetBaselineShift(shift): [BaselineShift(shift)];
					WigiSetName(name): [WigiName(name)];
					WigiSetLanguage(name): [Language(name)];
					WigiSetLetterSpacing(spacing) : [LetterSpacing(spacing)];
					WigiSetParagraphStyle(__, __): {
						println("WigiSetParagraphStyle should be handled at a paragraph level");
						[Fill(red)]
					}
					WigiModifyParagraphStyle(__): {
						println("WigiModifyParagraphStyle should be handled at a paragraph level");
						[Fill(red)]
					}
					WigiReplaceParagraphStyle(__): {
						println("WigiReplaceParagraphStyle should be handled at a paragraph level");
						[Fill(red)]
					}
					WigiClearParagraphFormatting(): {
						println("WigiClearParagraphFormatting should be handled at a paragraph level");
						[Fill(red)]
					}
					WigiSetLock(lock): {
						if (isLockedWigi(lock)) [WigiLock(lock)]
						else []
					}
					WigiSetAnnotation(id) : if (id < 0) [] else [WigiAnnotation(id)];
				}

				styleFilter = \s -> {
					notSameStruct = \textStyle -> !isSameStructType(s, textStyle);
					switch (event: WigiSetStyle) {
						WigiSetBackgroundColor(color) : !containsStruct([BackgroundFillOpacity(0.), BackgroundFill(0)], s);
						WigiSetColor(color) : notSameStruct(Fill(0));
						WigiSetFontSize(fontSize) : notSameStruct(FontSize(0.0));
						WigiModifyFontSize(baseSize, baseShift) : notSameStruct(FontSize(0.0));
						WigiSetFontFamily(fontFamily) : notSameStruct(FontFamily(""));
						WigiSwitchFontFamily(fontFamilyStyle, turnOn) : notSameStruct(FontFamily(""));
						WigiSetUnderline(hasUnderline) : notSameStruct(Underline());
						WigiSetDoubleUnderline(hasUnderline) : notSameStruct(DoubleUnderline());
						WigiSetBaselineShift(shift) : notSameStruct(BaselineShift(0.0));
						WigiSetName(name) : notSameStruct(WigiName(""));
						WigiSetLanguage(name) : notSameStruct(Language(""));
						WigiSetLetterSpacing(__) : notSameStruct( LetterSpacing(0.0));
						WigiSetLock(type) : notSameStruct(WigiLock(WigiNoLock()));
						WigiSetAnnotation(__) : notSameStruct(WigiAnnotation(-1));
						WigiClearTextFormatting() : false;
						WigiSetParagraphStyle(__, __) : true;
						WigiModifyParagraphStyle(__) : true;
						WigiReplaceParagraphStyle(__) : true;
						WigiClearParagraphFormatting() : true;
					}
				}
				concat(filter(style, styleFilter), styleToAdd);
			}

			getNewTextStyle = \path, oldStyle -> {
				getWigiTextStyleFull(styleDict, doc, path, oldStyle)
				|> applyStyle |> getWigiTextStyle
				|> (\fullStyle -> getWigiTextStyleShort(styleDict, doc, path, fullStyle))
			}

			// split WigiText into [WigiText] if text symbols can not accept new font family
			splitWigiTextAtSymbols = \e : WigiText, newStyle -> {
				fontFamilyChanged = extractStruct(symmetricDifferenceA(e.style, newStyle), FontFamily("")).name != "";
				if (fontFamilyChanged) {
					newFontFamily = extractStruct(newStyle, FontFamily("Book")).name;
					part : ref WigiText = ref WigiText("", []);
					nacc = ref [];
					parts = stringFoldi(e.text, [], \i, acc, code ->{
						ch = fromCharCode(code);
						nacc := acc;
						part := if (!validFontFamily(ch, newFontFamily)){ // symbol can not take new style
							if (i == 0)  WigiText(ch, e.style)
							else if (^part.style != newStyle) WigiText(^part.text + ch, ^part.style)
							else {
								nacc := arrayPush(acc, ^part);
								WigiText(ch, e.style);
							}
						} else {
							if (i == 0) WigiText(ch, newStyle)
							else if (^part.style == newStyle) WigiText(^part.text + ch, ^part.style)
							else {
								nacc := arrayPush(acc, ^part);
								WigiText(ch, newStyle);
							}
						}
						^nacc;
					});
					arrayPush(parts, ^part);
				} else {
					[WigiText(e.text, newStyle)];
				}
			}

			splitWigiTextElementsAtSymbols = \elements, path, firstIndex  -> {
				switch(event){
					WigiSetFontFamily(__):{
						foldi(elements, [], \i, acc : [WigiElement], el -> {
							p = arrayPush(path, i + firstIndex);
							switch(el : WigiElement){
								WigiText(t, ts): concat(acc, splitWigiTextAtSymbols(el, getNewTextStyle(p, ts)));
								default: arrayPush(acc, el)
							}
						})
					}
					default: elements
				}
			}

			// true if each character from WigiText can accept style's fontFamily
			validTextStyle = \e : WigiText, style ->{
				fontFamilyChanged = extractStruct(symmetricDifferenceA(e.style, style), FontFamily("")).name != "";
				if (fontFamilyChanged) {
					newFont = extractStruct(style, FontFamily("Book")).name;
					all(map(enumFromTo(0, strlen(e.text) - 1), \i -> validFontFamily(getCharAt(e.text, i), newFont)))
				} else true
			}

			applyStyleToWholeElement = ref \e, path -> WigiEmpty();
			applyStyleToWholeElement := \e: WigiElement, path : [int] -> {
				switch (e: WigiElement) {
					WigiEmpty(): WigiEmpty();
					WigiText(et, es): {
						newStyle = getNewTextStyle(path, es);
						style = if (validTextStyle(e, newStyle)) newStyle else es;
						WigiText(et, style);
					}
					WigiParagraph(elems, style): {
						elements = splitWigiTextElementsAtSymbols(elems, path, 0);
						WigiParagraph(mergeParagraphElements(mapi(elements, \i, el -> ^applyStyleToWholeElement(el, arrayPush(path, i)))), style);
					}
					WigiStory(paragraphs, views, style): {
						makeWigiStory(mapi(^paragraphs, \i,p -> ^applyStyleToWholeElement(p, arrayPush(path, i))), style);
					}
					WigiRecursive(elements, type, style): {
						isCell = isSameStructType(type, dummyWigiTableCell) || isSameStructType(type, dummyWigiSpreadsheetCell);
						newStyle = getWigiRecursiveStyle(applyStyle(style));

						applyToChildren = \ -> WigiRecursive(mapi(elements, \i, el -> ^applyStyleToWholeElement(el, arrayPush(path, i))), type, if (isCell) style else newStyle);

						if (isWigiRecursive(e, [dummyWigiTable, dummyWigiTableCell, dummyWigiSpreadsheetCell])) {
							// If it is a table or a cell, we need to apply change individually to each child
							applyToChildren();
						} else {
							switch (event) {
								WigiSetUnderline(__): WigiRecursive(elements, type, newStyle);
								WigiSetDoubleUnderline(__): WigiRecursive(elements, type, newStyle);
								WigiSetBaselineShift(__): WigiRecursive(elements, type, newStyle);
								WigiSetName(__): WigiRecursive(elements, type, newStyle);
								default: applyToChildren();
							}
						}
					}
					WigiBlock(type, style): {
						// Special case, we don't want to change style in our WigiPositionTag friend
						if (isSameStructType(type, WigiPositionTag(0))) {
							e
						} else {
							fullStyle = applyStyle(getWigiBlockStyleFull(styleDict, doc, path, style)) |> getWigiBlockStyle;
							newStyle = getWigiBlockStyleShort(styleDict, doc, path, fullStyle);
							WigiBlock(type, newStyle)
						}
					}
					WigiDocument(__, __): e;
				}
			}

			// Paragraphs, stories and recursives can be handled universally
			applyStyleAndReplaceElement = \ -> {
				children = getWigiElementChildren(curElement, false);

				newChildren = concatA([
					subrange(children, 0, start),
					subrange(children, start, end - start)
						|> (\es -> splitWigiTextElementsAtSymbols(es, root, start))
						|> (\es -> mapi(es, \i, ch -> ^applyStyleToWholeElement(ch, arrayPush(root, start + i)))),
					tailFrom(children, end)
				]);

				newElement = switch (curElement: WigiElement) {
					WigiParagraph(elements, style): {
						WigiParagraph(mergeParagraphElements(newChildren), style)
					}

					WigiStory(paragraphs, views, style): {
						makeWigiStory(newChildren, style)
					}

					WigiRecursive(elements, type, style): {
						WigiRecursive(newChildren, type, style)
					}

					default: {
						println("Composite Wigi element expected as argument to applyStyleAndReplaceElement");
						WigiEmpty()
					}
				}

				replaceElementInDocument(state, root, newElement);
			}

			switch (curElement: WigiElement) {
				WigiEmpty(): {}
				WigiText(text, st): {
					fullStyle = applyStyle(getWigiTextStyleFull(styleDict, doc, root, st)) |> getWigiTextStyle;
					newStyle = getWigiTextStyleShort(styleDict, doc, root, fullStyle);
					leftPart = if (start > 0) WigiText(strLeft(text, start), st) else WigiEmpty();
					centerParts = splitWigiTextAtSymbols(WigiText(substring(text, start, end - start), st), newStyle);
					rightPart = if (end < strlen(text)) WigiText(substring(text, end, strlen(text) - end), st) else WigiEmpty();

					newParts: [WigiElement] = filter(concat3([leftPart], centerParts, [rightPart]), neq(WigiEmpty()));

					// Now we need to replace our text with newParts
					parentElementPath = wigiParentPath(root);
					parentParagraph = getElementAtPosition(getValue(state.document), parentElementPath);
					indexInParent = lastElement(root, -1);

					switch (parentParagraph: WigiElement) {
						WigiParagraph(elements, pstyle): {
							newElements = concatA([
								subrange(elements, 0, indexInParent),
								newParts,
								tailFrom(elements, indexInParent + 1)
							]) |> mergeParagraphElements;

							newParagraph = WigiParagraph(newElements, pstyle);

							replaceElementInDocument(state, parentElementPath, newParagraph);
						}

						default: {
							// It can be fine if we have position deep in the text, and then our parent is text again
						}
					}
				}

				WigiBlock(type, style): {
					switch(type) {
						WigiPositionTag(__): {}
						default: replaceElementInDocument(state, root, ^applyStyleToWholeElement(curElement, root));
					}
				}

				WigiParagraph(elements, style): {
					applyStyleAndReplaceElement();
				}

				WigiStory(paragraphs, views, style): {
					applyStyleAndReplaceElement();
				}

				WigiRecursive(elements, type, style): {
					applyStyleAndReplaceElement();
				}

				WigiDocument(__, __): {
					println("Applying style to the document structure (not story), can't really happen");
				}
			}
		}
	}
}

getWigiBlockStyle(wigiStyle : [WigiStyle]) -> [WigiBlockStyle] {
	filtermap(wigiStyle, \s -> switch(s) {
		Underline(): { r : Maybe<WigiBlockStyle> = Some(s); r }
		DoubleUnderline(): Some(s);
		WigiName(__): Some(s);
		BaselineShift(__): Some(s);
		FontFamily(__): Some(s);
		FontSize(__): Some(s);
		Fill(__): Some(s);
		FillOpacity(__): Some(s);
		LetterSpacing(__): Some(s);
		BackgroundFill(__): Some(s);
		BackgroundFillOpacity(__): Some(s);
		WigiLock(__): Some(s);
		default: None();
	})
}

getWigiTextStyle(wigiStyle : [WigiStyle]) -> [WigiTextStyle] {
	filtermap(wigiStyle, \s -> switch(s) {
		Fill(__): { r : Maybe<WigiTextStyle> = Some(s); r }
		Underline(): Some(s);
		DoubleUnderline(): Some(s);
		FontSize(__): Some(s);
		FontFamily(__): Some(s);
		FillOpacity(__): Some(s);
		BaselineShift(__): Some(s);
		LetterSpacing(__): Some(s);
		BackgroundFill(__): Some(s);
		BackgroundFillOpacity(__): Some(s);
		WigiLock(__): Some(s);
		Language(__): Some(s);
		WigiAnnotation(__): Some(s);
		default: None();
	})
}

getWigiRecursiveStyle(wigiStyle : [WigiStyle]) -> [WigiRecursiveStyle] {
	filtermap(wigiStyle, \s -> switch(s) {
		Underline(): { r : Maybe<WigiRecursiveStyle> = Some(s); r }
		DoubleUnderline(): Some(s);
		WigiName(__): Some(s);
		BaselineShift(__): Some(s);
		default: None();
	})
}

changeSelectionStyle(state: WigiEditorState, event: WigiSetStyle) -> void {
	// We either have rectangular selection or usual selection
	eitherFn(
		getRectangularSelection(getValue(state.selection), getValue(state.document), false),
		\rectSelection -> changeSelectionStyleRectangular(state, event, rectSelection),
		\ -> changeSelectionStyleRegular(state, event)
	);
}

// Change selection style in rectangular selection
// See case http://process.area9.dk/cases/default.asp?34398
changeSelectionStyleRectangular(state: WigiEditorState, event: WigiSetStyle, rectSelection: RectangularSelection) {
	tablePath = rectSelection.path;

	// We know it's a table!
	tableElement = cast(getElementAtPosition(getValue(state.document), tablePath): WigiElement -> WigiRecursive);

	// Now, let's go through all cells in the table and apply changes to each cell if it happens to be inside the selection
	iteri(tableElement.elements, \i, el -> {
		// If this cell is inside rectangular selection, apply style change to it
		if (rectSelection.isInside(i)) {
			// Do the change in this cell
			changeStyleInElement(state, rectSelection.path, i, i + 1, event);
		}
	});
}

// Does doChangeSelectionStyle and preserves selection and cursor positions
changeSelectionStyleRegular(state: WigiEditorState, event: WigiSetStyle) {
	selection = getValue(state.selection);

	// If selection is empty, we won't mess around with cursor and selection position changes
	isSelectionEmpty = (selection.start == selection.end);

	if (!isSelectionEmpty) {
		cursorAtSelectionStart = selection.start == getValue(state.cursor);	// Otherwise we suppose the cursor == selection.end

		// Let's add tags for selection start, end and cursor position, so that we can restore all of these later
		startSelectionTag = WigiBlock(WigiPositionTag(0), []);
		endSelectionTag = WigiBlock(WigiPositionTag(1), []);

		pasteWigi(state, selection.end, endSelectionTag, false);
		pasteWigi(state, selection.start, startSelectionTag, false);

		newStartSelection = findTagPosition(state, [], startSelectionTag, false, true);
		newEndSelection = findTagPosition(state, [], endSelectionTag, false, true);

		doChangeSelectionStyle(state, newStartSelection, newEndSelection, event);

		// Update selection and delete PositionTag blocks
		newStartSelection2 = findTagPosition(state, [], startSelectionTag, true, true);
		newEndSelection2 = findTagPosition(state, [], endSelectionTag, true, true);

		setWigiEditorSelection(state, WigiSelection(newStartSelection2, newEndSelection2), false);
		next(state.selectionAnchor, Some(if (cursorAtSelectionStart) newStartSelection2 else newEndSelection2));
		next(state.cursor, if (cursorAtSelectionStart) newStartSelection2 else newEndSelection2);
	} else {
		root = getValue(state.document);
		cursor = getValue(state.cursor);
		switch (event : WigiSetStyle) {
			WigiClearTextFormatting(): {
				if (isPositionStartOfParagraph(root, cursor) || isPositionEndOfParagraph(root, cursor)) {
					changeStyleInElement(state, cursor, 0, 0, event);
				} else {
					clearWordFormatting(state, event);
				}
			}
			default: {
				// Let's just find an element under cursor and do the thing
				changeStyleInElement(state, cursor, 0, 0, event);
			}
		}
	}
}

clearWordFormatting(state : WigiEditorState, event : WigiSetStyle) -> void {
	if (isEmptySelection(getValue(state.selection))) {
		cursor = getValue(state.cursor);

		textBorders = getTextBorders(getValue(state.document), Pair(cursor, cursor));
		leftBorder = textBorders.first;
		rightBorder = textBorders.second;

		if (leftBorder != rightBorder && leftBorder != cursor && rightBorder != cursor) {
			cursorTag = WigiBlock(WigiPositionTag(0), []);
			endTag = WigiBlock(WigiPositionTag(1), []);

			pasteWigi(state, rightBorder, endTag, false);
			pasteWigi(state, cursor, cursorTag, false);

			doChangeSelectionStyle(state, leftBorder, cursor, event);

			newEnd = findTagPosition(state, [], endTag, true, true);
			newStart = findTagPosition(state, [], cursorTag, false, true);

			doChangeSelectionStyle(state, newStart, newEnd, event);

			next(state.cursor, findTagPosition(state, [], cursorTag, true, true));
		}
	}
}

doChangeSelectionStyle(state: WigiEditorState, start: [int], end: [int], style: WigiSetStyle) {
	// We need to find 3 pieces again, and change style in them
	root = getValue(state.document);
	if (compareDocumentPosition(start, end) >= 0) {	// Check if `end` is `after` start in the document
		if (start == end) {
			if (isSome(getParagraphStyleUpdater(style))) {
				// we process paragraph level event
				switch (maybeGetParentWigiParagraph(root, start)) {
					Some(pair): unpair(pair, \el, path -> {
						if (length(path) < length(start))
							changeStyleInElement(state, path, start[length(path)], end[length(path)], style);
						{}
					});
					None(): {}
				}
			} else {
				// or clear empty text formatting
				switch (style : WigiSetStyle) {
					WigiClearTextFormatting(): {
						if (isWigiEmptyText(getElementAtPosition(root, start)))
							changeStyleInElement(state, wigiParentPath(start), lastElement(start, 0), lastElement(start, 0), style);
						{}
					}
					default: {}
				}
			}
		} else {}
	} else {
		// This is usual selection (or rectangular selection is disabled)
		// So we do our usual 3 things for a general selection
		top = commonPath(start, end);
		if (isPositionParent(top, start) && isPositionParent(top, end)) {
			// The same parent - we can do this
			n = length(top);
			si = start[n];
			ei = end[n];

			changeStyleInElement(state, top, si, ei, style);
		} else {
			// Do three changes: (1-2-3)
			// (3)
			if (top != end) {
				lastTop = arrayPush(top, end[length(top)]);
				lastTopElement = getElementAtPosition(root, lastTop);

				startLast = concat(lastTop, getStartPositionOfDocument(lastTopElement));
				doChangeSelectionStyle(state, startLast, end, style);
			}

			// (2)
			tl = length(top);
			if (length(start) > tl && length(end) > tl) {
				changeFrom = start[tl] + 1;
				changeTo = end[tl];

				if (changeTo > changeFrom) {
					changeStyleInElement(state, top, changeFrom, changeTo, style);
				}
			}

			// (1)
			if (top != start) {
				startTop = arrayPush(top, start[length(top)]);
				startTopElement = getElementAtPosition(root, startTop);
				startTopElementEnd = getEndPositionOfDocument(startTopElement, false);

				endStart = concat(startTop, startTopElementEnd);
				doChangeSelectionStyle(state, start, endStart, style);
				// [-Explain-] workaround for tailscalls optimization in js
				nop();
			}
		}
	}
}

// Assuming state.cursor is exactly 3 integers long - [paragraph index, text in paragraph, index in text (or block)]
doInsertPageBreak(state: WigiEditorState) {
	wigiNewParagraph(state, getValue(state.cursor));
	wigiMoveCursor(state, -1, false);
	wigiNewParagraph(state, getValue(state.cursor));

	// Now we should basically replace current paragraph that consists of empty text with our pageBreak element
	paragraphIndex = getValue(state.cursor)[0];

	wigiMoveCursor(state, 1, false);

	topmostStory = getValue(state.document);	// This should be a story
	switch (topmostStory: WigiElement) {
		WigiStory(paragraphs, views, style): {
			newParagraphs = mapi(^paragraphs, \i, paragraph -> {
				if (i != paragraphIndex) {
					paragraph
				} else {
					// Replace our paragraph with a pageBreak
					WigiBlock(WigiPageBreak(false, false), [])
				}
			});

			next(state.document, makeWigiStory(newParagraphs, style));
		}
		default: {
			println("Failed to insert page break");
		}
	}
}

maybeGetNextElementFontSize(defStyle : [WigiStyles], root : WigiElement, path : [int]) -> Maybe<double> {
	if (path == []) {
		None();
	} else {
		parentPath = wigiParentPath(path);
		siblings = getWigiElementChildren(getElementAtPosition(root, parentPath), false);
		index = path[length(path) - 1];
		if (index < length(siblings) - 1){
			nextPath = arrayPush(parentPath, index + 1);
			switch(getElementAtPosition(root, nextPath)){
				WigiText(t, style):{
					fullstyle = getWigiTextStyleFull(defStyle, root, nextPath, style);
					Some(extractStruct(fullstyle, FontSize(11.0)).size);
				}
				default: None();
			}
		} else {
			None()
		}
	}
}

switchEditorFontFamily(state : WigiEditorState, style: FontFamilyStyle) -> void {
	currentFontFamily = getValue(state.fontFamily);
	newFont = switchWigiMappedFont(currentFontFamily, style, None());
	nextDistinct(state.fontFamily, newFont)
}

deleteElementSafely(state: WigiEditorState, path: [int]) {
	parentPath = wigiParentPath(path);
	index = lastElement(path, -1);

	cursorTag = WigiBlock(WigiPositionTag(-1), []);

	// We should determine if cursor is before beforeElementTag or after afterElementTag or in between
	afterPosition = arrayPush(parentPath, index + 1);

	isCursorBefore = compareDocumentPosition(getValue(state.cursor), path) < 0;
	isCursorAfter = !isCursorBefore && compareDocumentPosition(afterPosition, getValue(state.cursor)) < 0;

	newCursorPosition = if (isPositionParentGeneral(parentPath, getValue(state.cursor))) {
		// Cursor is inside our paragraph somehow, we need to take care of it
		if (isCursorBefore) {	// Cursor is before and therefore isn't affected
			None()
		} else {
			if (isCursorAfter) {
				Some(getValue(state.cursor))
			} else {
				// Cursor is inside the block that we're going to delete, then it should be after the "path" block
				Some(arrayPush(parentPath, index + 1))
			}
		}
	} else {
		// Cursor is outside of changes scope, so we can leave it where it is
		None()
	}

	maybeApply(newCursorPosition, \cp -> pasteWigi(state, cp, cursorTag, false));

	deleteRangeInElement(state, parentPath, index, index + 1, true);

	if (isSome(newCursorPosition)) {
		setCursorWhereTagIs(state, parentPath, cursorTag, false);
	}
}

// Insert empty text between recursives, before first recursive in a paragraph and after last recursive
// Returns true when fully completed
normalizeContent(state: WigiEditorState, wigiRootPath: [int]) -> bool {
	document = getValue(state.document);
	rootElement = getElementAtPosition(document, wigiRootPath);

	switch (rootElement: WigiElement) {
		WigiParagraph(elements, style): {	// That's what we wanna change
			filteredElements = filterAspectsInWigiParagraph(elements, extractStructMany(style, dummyWigiAspect));
			normalizedElements = normalizeWigiElements(filteredElements);
			newElements = map(normalizedElements, \element -> prepareWigiElementForPaste(document, element));

			if (newElements != elements) {
				newParagraph = WigiParagraph(newElements, style);
				replaceElementInDocument(state, wigiRootPath, newParagraph);

				// Watch out for cursor...
				if (isPositionParentGeneral(wigiRootPath, getValue(state.cursor))) {
					// Fix cursor position after normalization, i.e. it helps to find out
					// a correct position considering some normalization reducing
					fixedCursor = fixCursorPositionAfterNormalize(state, wigiRootPath, elements, newElements);

					// Here we check if this fixed position exists in document in general, and
					// if not - correct it to be real
					wigiSetCursor2(state, positionCursorInElement(document, fixedCursor), false, false);
				}

				// Watch out for selection as well
				selection = getValue(state.selection);
				if (isPositionParentGeneral(wigiRootPath, selection.start) || isPositionParentGeneral(wigiRootPath, selection.end)) {
					nextDistinct(state.selection, wigiClearSelection(document));
				}
				false
			} else {
				true
			}
		}

		default: {
			// Normalize recursively until there's nothing more to normalize
			children = getWigiElementChildren(rootElement, false);
			lastNormalizedChild = countUntil(0, length(children), \i -> {
				!normalizeContent(state, arrayPush(wigiRootPath, i))
			});

			if (lastNormalizedChild == length(children)) {
				true 	//  We're done with normalization
			} else {
				// Start all over again
				normalizeContent(state, wigiRootPath)
			}
		}
	}
}

fixCursorPositionAfterNormalize(state : WigiEditorState, wigiRootPath : [int], elements : [WigiElement], newElements : [WigiElement]) -> [int] {
	// We need to fix cursor's position only if there were some normalizations
	// before our current position
	wasNormalizationBeforeUs = \index -> {
		foldi(newElements, false, \i, acc, e -> acc || (i < index && e != elements[i]))
	}

	currentCursor = getValue(state.cursor);
	delta = length(elements) - length(newElements);
	if (delta > 0) {
		path = tailFrom(currentCursor, length(wigiRootPath));
		if (length(path) > 0) {
			rest = tail(path);
			if (wasNormalizationBeforeUs(path[0])) {
				result = path[0] - delta;
				if (result >= 0) {
					fixedCursorParent = arrayPush(wigiRootPath, result);

					// Place cursor at the end of current element after normalization.

					// TODO: we can improve this behaviour in the next way:
					// calculate getEndPositionOfDocument of previous element, which we were
					// merged with during normalization, and add it to our position in the element
					// before normalization. It's better to use this position instead of just simple
					// getEndPositionOfDocument of current element
					endOfCurrentElement = getEndPositionOfDocument(getElementAtPosition(getValue(state.document), fixedCursorParent), false);

					concat(fixedCursorParent, endOfCurrentElement)
				} else currentCursor
			} else currentCursor
		} else currentCursor
	} else currentCursor
}

applyallWigiElement(element: WigiElement, currentCell : WigiCellRefA1, action: (WigiCellRefA1, WigiElement) -> WigiElement) -> WigiElement {
	recursiveCall = \el -> {
		cellName = switch(element) {
			WigiRecursive(elements, type, style): {
				name = extractStruct(style, WigiName("")).name;
				if (name != "") WigiCellRefA1(name) else currentCell
			}
			default: currentCell;
		}
		applyallWigiElement(el, cellName, action)
	}
	action(
		currentCell,
		switch(element) {
			WigiDocument(root, style): WigiDocument(root |> recursiveCall, style);
			WigiStory(paragraphs, views, style): WigiStory(ref map(^paragraphs, recursiveCall), views, style);
			WigiParagraph(elements, style): WigiParagraph(map(elements, recursiveCall), style);
			WigiRecursive(elements, type, style): WigiRecursive(map(elements, recursiveCall), type, style);
			default: element;
		}
	)
}

getSpreadSheetCellA1Name(doc: WigiElement, path: [int]) -> WigiCellRefA1 {
	if (path == []) {
		WigiCellRefA1("");
	} else {
		parentPath = wigiParentPath(path);
		parent = getElementAtPosition(doc, parentPath);
		switch(parent) {
			WigiRecursive(__, type, style): {
				switch(type){
					WigiSpreadsheetCell(__, __, cellStyle): WigiCellRefA1(extractStruct(style, WigiName("")).name);
					default: getSpreadSheetCellA1Name(doc, parentPath);
				}
			}
			default: getSpreadSheetCellA1Name(doc, parentPath);
		}
	}
}

isEnabledEvent(state : WigiEditorState, event : WigiEvent) -> bool {
	// It is workaround of such behaviour:
	// When we set cursor in element_view.flow by WigiSendEvent(state, WigiSetCursor(newCursor, c.selecting))
	// the current cursor must be @newCursor, but state.cursor contains previous value of cursor
	cursor = switch(event) {
		WigiSetCursor(c, __): c;
		default: getValue(state.cursor);
	}
	isLockEditAllowed(state)
	|| isAllowedEvent(event, getLockAtPosition(getValue(state.document), cursor));
}

insertWigiElement(state : WigiEditorState, el : WigiElement) -> void {
	element = if (state.lock.status != LockIgnored()) applyLockToWigiElement(el, getValue(state.lock.current)) else el;
	switch (element) {
		WigiRecursive(elements, type, style): {
			selection = getValue(state.selection);
			pl = getRecursivePlaces(type);
			contentDestIndexInRecursive = pl.first;
			cursorDestIndexInRecursive = pl.second;

			path = getStartPositionOfDocument(elements[contentDestIndexInRecursive]);
			newElements = if (isEmptySelection(selection)) {
				Pair(elements, contentDestIndexInRecursive)
			} else {
				selectedContent = extractWigiRange(getValue(state.document), selection.start, selection.end);

				// replace proper element in our recursive with selectedContent
				applySelectedContent = \ -> {
					Pair(
						replace(elements, contentDestIndexInRecursive,
							replaceElement(elements[contentDestIndexInRecursive], path, selectedContent).first
						),
						cursorDestIndexInRecursive
					)
				}

				switch (selectedContent) {
					WigiText(text, st): switch (type : WigiRecursiveType) {
						WigiHyperlink(__): {
							Pair(
								replace(
									elements,
									contentDestIndexInRecursive,
									replaceElement(
										elements[contentDestIndexInRecursive],
										path,
										WigiText(text, concat(st, [Fill(blue), Underline()]))
									).first
								),
								//elements,
								cursorDestIndexInRecursive
							);
						}
						default: applySelectedContent();
					}
					WigiBlock(__, __): applySelectedContent();
					WigiRecursive(__, __, __): applySelectedContent();
					WigiStory(ps, vs, sst): {
						newParagraphs = map(^ps, \p ->
							switch(p) {
								WigiParagraph(es, st): if (contains(st, TightWidth())) p else WigiParagraph(es, arrayPush(st, TightWidth()));
								default: p
						});
						Pair(replace(elements, contentDestIndexInRecursive,
							replaceElement(
								elements[contentDestIndexInRecursive],
								[0],
								WigiStory(ref newParagraphs, vs, sst)
							).first,
						), cursorDestIndexInRecursive);
					}
					WigiParagraph(es, st): {
						oldStyleWithFixedAlignment = if (isRecursiveWithMathPlaceholder(element)) subtractA(st, alignStyles) else st;
						newStyle = if (contains(oldStyleWithFixedAlignment, TightWidth())) oldStyleWithFixedAlignment else arrayPush(oldStyleWithFixedAlignment, TightWidth());
						Pair(replace(elements, contentDestIndexInRecursive, replaceElement(
							elements[contentDestIndexInRecursive],
							[0, 0],
							WigiParagraph(es, newStyle)
						).first), cursorDestIndexInRecursive);
					}
					WigiEmpty(): {
						// We cannot be here, because selection was no empty
						Pair(elements, contentDestIndexInRecursive)
					}
					WigiDocument(__, __): {
						// We cannot be here, because selection cannot be the document itself
						Pair(elements, contentDestIndexInRecursive)
					}
				}
			}

			deleteSelection(state);

			removeMathPlaceholder(state);

			recursiveCopy = wigiForStorage(WigiRecursive(newElements.first, type, style), false);
			newElementsCopy = switch(recursiveCopy) {
				WigiRecursive(e, t, s): e;
				default: newElements.first;
			}

			// Specifically forbid deleteing of empty recursives, because we can easily delete what we've just inserted
			pasteWigiAndNormalize(state, getValue(state.cursor), recursiveCopy, false);

			wigiSetCursor2(state, concat(findWigiElement(getValue(state.document), newElementsCopy[newElements.second]), path), false, false);

			// Wait until form sizes are updated and reset cursor to make it visually be in proper place
			deferUntilRender(\ -> {
				next(state.cursor, getValue(state.cursor));
			});
		}
		default: {
			deleteSelection(state);

			removeMathPlaceholder(state);

			pasteWigiAndNormalize(state, getValue(state.cursor), wigiForStorage(element, false), true);
		}
	}
}

// WARNING: This is a quite simple check.
// It does not do recursive check, i.e. if element is WigiStory or WigiParagraph
// and there are some potential doubled wigiNames, they won't be fixed
renameDuplicateElement(state : WigiEditorState, element : WigiElement) -> WigiElement {
	newName = \name -> {
		getProperName(getWigiNameWithoutNumber(name), getValue(state.document));
	}

	switch (element) {
		WigiRecursive(elements, type, style): {
			wigiName = extractStruct(style, WigiName("")).name;
			if (wigiName != "") {
				switch (type) {
					WigiTable(__, __, __, __): {
						switch(findWigiElementByName(getValue(state.document), wigiName)) {
							Some(el): {
								newStyle = updateWigiName(style, newName(wigiName));
								WigiRecursive(elements, type, newStyle)
							}
							None(): element;
						}
					}
					default : element;
				}
			} else {
				element;
			}
		}
		WigiBlock(type, style): {
			wigiName = extractStruct(style, WigiName("")).name;
			if (wigiName != "") {
				switch(type) {
					WigiFormula(__, __) : {
						switch(findWigiElementByName(getValue(state.document), wigiName)) {
							Some(el): {
								newStyle = updateWigiName(style, newName(wigiName));
								WigiBlock(type, newStyle)
							}
							None(): element;
						}
					}
					WigiExternalBlock(exType, content): {
						switch (findWigiElementByName(getValue(state.document), wigiName)) {
							Some(__): {
								newWigiName = newName(wigiName);
								newStyle = updateWigiName(style, newWigiName);
								WigiBlock(WigiExternalBlock(exType, setTree(content, "wigiName", newWigiName)), newStyle)
							}
							None(): element;
						}
					}
					default : element;
				}
			} else {
				element;
			}
		}
		default : element;
	}
}

maybeGetParentRadioOption(root: WigiElement, position: [int]) -> Maybe<Triple<WigiRecursive, WigiRadioOption, [int]>> {
	recursivePath = wigiFindParentRecursive(root, [dummyWigiRadioOption], position);
	if (recursivePath != []) {
		recursive = getElementAtPosition(root, recursivePath);
		switch(recursive) {
			WigiRecursive(__, type, __): {
				switch (type) {
					WigiRadioOption(__, __): {
						Some(Triple(recursive, type, recursivePath))
					}
					default: None();
				}
			}
			default: None();
		}
	} else None();
}

makeWigiRadioOptionContent(layout: WigiRadioOptionAlign, frameM: Maybe<WigiFrame>, button: [WigiElement], otherElements: [WigiElement], paragraphStyle : [WigiParagraphStyle]) -> WigiElement {
	forLeft = [WigiParagraph(concatA([button, otherElements]), paragraphStyle)];
	forRight = [WigiParagraph(concatA([otherElements, button]), paragraphStyle)];
	paragraphs = switch (layout) {
		WigiLineStart(): if (getDefaultRtl()) forRight else forLeft;
		WigiLineEnd(): if (getDefaultRtl()) forLeft else forRight;
		WigiLeft(): forLeft;
		WigiAbove(): [WigiParagraph(button, paragraphStyle), WigiParagraph(otherElements, paragraphStyle)];
		WigiRight(): forRight;
		WigiBelow(): [WigiParagraph(otherElements, paragraphStyle), WigiParagraph(button, paragraphStyle)];
	}
	story = makeWigiStory(paragraphs, []);
	eitherMap(frameM, \frame -> WigiRecursive([story], frame, []), story)
}

maybeGetWigiRadioOptionProperties(recursive: WigiRecursive) -> Maybe<WigiRadioOptionProperties> {
	if (length(recursive.elements) == 1) {
		child = recursive.elements[0];
		switch(child) {
			WigiRecursive(__, type, __): {
				switch(type) {
					WigiFrame(__, __, __): maybeGetWigiRadioOptionProperties0(child, Some(type));
					default: maybeGetWigiRadioOptionProperties0(recursive, None())
				}
			}
			default: maybeGetWigiRadioOptionProperties0(recursive, None())
		}
	} else None()
}

maybeGetWigiRadioOptionProperties0(recursive: WigiRecursive, frame: Maybe<WigiFrame>) -> Maybe<WigiRadioOptionProperties> {
	if (length(recursive.elements) == 1) {
		switch (recursive.elements[0]) {
			WigiStory(paragraphs, views, __): {
				if (length(^paragraphs) == 1) {
					// left or right
					switch(^paragraphs[0])  {
						WigiParagraph(elements, style): {
							if (length(elements) > 1) {
								if (isWigiRadioButton(elements[0])) {
									// left
									layout : WigiRadioOptionAlign = WigiLeft();
									Some(WigiRadioOptionProperties(layout, frame, [elements[0]], tail(elements), style))
								} else if (isWigiRadioButton(elements[length(elements) - 1])) {
									// right
									layout : WigiRadioOptionAlign = WigiRight();
									Some(WigiRadioOptionProperties(layout, frame, [elements[length(elements) - 1]], subrange(elements, 0, length(elements) - 1), style))
								} else None()
							} else None()
						}
						default: None()
					}
				} else if (length(^paragraphs) == 2) {
					// above or below
					elements1 = getWigiElementChildren(^paragraphs[1], false);
					switch(^paragraphs[0])  {
						WigiParagraph(elements, style): {
							if (length(elements) == 1) {
								if (isWigiRadioButton(elements[0])) {
									// above
									layout : WigiRadioOptionAlign = WigiAbove();
									Some(WigiRadioOptionProperties(layout, frame, [elements[0]], elements1, style))
								} else {
									// below
									layout : WigiRadioOptionAlign = WigiBelow();
									Some(WigiRadioOptionProperties(layout, frame, elements1, [elements[0]], style))
								}
							} else None()
						}
						default: None()
					}
				} else None()
			}
			default: None()
		}
	} else None()
}

// #38761 (delete RadioButton and convert all text from RadioOption to normal text)
deleteWigiRadioButton(state : WigiEditorState) -> void {
	root = getValue(state.document);
	cursor = getValue(state.cursor);
	parentRadioOptionM = maybeGetParentRadioOption(root, cursor);
	maybeApply(parentRadioOptionM, \parentRadioOption -> {
		untriple(parentRadioOption, \recursive, radioOption, recursivePath -> {
			maybeApply(maybeGetWigiRadioOptionProperties(recursive), \layoutProperties -> {
				deleteElementSafely(state, recursivePath);
				iter(layoutProperties.otherElements, \element -> {
					position = getValue(state.cursor);
					pasteWigi(state, position, element, true)
				})
			})
		})
	});

}

wigiChangeTable(s : WigiEditorState, event : WigiTableEvent) -> bool {
	executeWigiEditorChange(s, \ -> wigiSendEvent(s, event), nop, false)
}

changeFirstLineIndent(state : WigiEditorState, shift : bool) -> void {
	switch (maybeGetParagraphIndent(state, FirstLineIndent(0.0))) {
		Some(indent): {
			fs = getDefaultDocumentFontSize(state.defaultStyles) / 4.0;
			di = if (shift) -fs else fs;
			newIndent = indent + di;
			wigiSendEvent(state, WigiSetParagraphStyle([FirstLineIndent(indent)], [FirstLineIndent(newIndent)])) |> ignore;
		}
		None(): {}
	}
}

changeGeneralIndent(state : WigiEditorState, shift : bool) -> void {
	switch (maybeGetParagraphIndent(state, GeneralIndent(0.0))) {
		Some(indent): {
			fs = getDefaultDocumentFontSize(state.defaultStyles);
			di = if (shift) -fs else fs;
			newIndent = max(indent + di, 0.0);
			if (indent > 0.0 || newIndent > 0.0) {
				wigiSendEvent(state, WigiSetParagraphStyle([GeneralIndent(indent)], [GeneralIndent(newIndent)])) |> ignore;
			}
		}
		None(): {}
	}
}

changeWigiParagraphIndent(state : WigiEditorState, shift : bool) -> void {
	switch (maybeGetParagraphIndent(state, FirstLineIndent(0.0))) {
		Some(fli): {
			switch (maybeGetParagraphIndent(state, GeneralIndent(0.0))) {
				Some(gi): {
					if (!shift && fli == 0.0 || shift && gi == 0.0) {
						changeFirstLineIndent(state, shift);
					} else {
						changeGeneralIndent(state, shift);
					}
				}
				None(): {}
			}
		}
		None(): {}
	}
}

setCursorInFirstWigiTextOfParagraph(state : WigiEditorState) -> void {
	eitherFn(
		maybeGetParentWigiParagraph(getValue(state.document), getValue(state.cursor)),
		\pair : Pair<WigiParagraph, [int]> -> {
			firstWigiTextM = findi(pair.first.elements, \e -> isSameStructType(e, WigiText("", [])));
			eitherFn(
				firstWigiTextM,
				\index -> wigiSetCursor(state, concat(pair.second, [index, 0]), false),
				nop
			);
		},
		nop
	);
}

showNaturalMathEditor(caption : string, formula : string, onOK : (string) -> void) -> void {
	focusId = currentKeyboardFocusId();
	tis = [Focus(true), Multiline(false), Content(formula, []), Selection(strlen(formula), strlen(formula)), TabIndex(0)];
	sketchW = 170.0;
	sketchH = 75.0;
	editor = \t -> Cols([
		TextEditorWithScrollbar(t, 400.0, 100.0, [], make(tis), ignore, nop, nop, false, nop),
		Fixed(10.0, 0.0),
		makeOrangeWindow("Preview",
			if (!existFormulaFormBuilder()) {
				mes = ["Formula", "can not be processed", "in this environment"];
				Size2(const(WidthHeight(sketchW, sketchH)),
					Center(Lines(map(mes, \line -> Align(0.5, 0.0, Text(line, []))))));
			} else {
				Scrollable(make(0.0), make(0.0), const(sketchW), const(sketchH),
					Center(
						Select(t, \math -> if (math != "") {
							switch(useFormulaFormBuilder(math, 0, 11.0)){
								Some(preview) : preview;
								None(): Text("Syntax error", []);
							}
						} else {
							Empty()
						}
				)))
			}
		)
	]);
	askStringInPopup2(caption, formula, neq(""),
		\f -> {
			updateKeyboardFocus(focusId);
			onOK(f);
		},
		\ -> {
			updateKeyboardFocus(focusId);
		},
		editor
	)
}

clearParagraphFormatting(state : WigiEditorState) -> void {
	doc = getValue(state.document);
	curParaPath = ref [];
	getIndents = \elementPath ->
		switch (maybeGetParentWigiParagraph(doc, elementPath)) {
			Some(pair): unpair(pair, \paragraph, path -> {
				if (^curParaPath != path){
					curParaPath := path;
					fullStyle = getWigiParagraphStyleFull(state.defaultStyles, doc, path, paragraph.style);
					fli = extractStruct(fullStyle, FirstLineIndent(0.0));
					gi = extractStruct(fullStyle, GeneralIndent(0.0));
					list = extractStruct(fullStyle, dummyListed);
					interline = extractStruct(fullStyle, dwis);
					aspects = extractStructMany(fullStyle, dummyWigiAspect);
					//remove WigiParagraphExternalStyle style, where cleared == true
					paragraphExternalStyles = filter(extractStructMany(fullStyle, WigiParagraphExternalStyle("")),
						\extStyle : WigiParagraphExternalStyle -> getJsonBoolField(parseJson(extStyle.data), CLEARED_STYLE_KEY, true)
					);
					concat3(aspects, paragraphExternalStyles, [fli, gi, list, interline])
				} else [];
			});
			None(): []
		}

	selection = getValue(state.selection);
	styleToRemove = concat(
		if (isEmptySelection(selection)) {
			getIndents(getValue(state.cursor))
		} else {
			concatA(mapWigiStylesFromRange(state.defaultStyles, doc, selection.start, selection.end,
				\e, path, style -> getIndents(path)));
		},
		[TightWidth(), FixedWidth(), StartAlign(), EndAlign(), LeftAlign(), CenterAlign(), RightAlign(), Justify()]
	);

	// no need to pass style to be added as we keep current style
	// elements with current style will be normalized by this call
	changeSelectionStyle(state, WigiSetParagraphStyle(styleToRemove, []));
	nextDistinct(state.interlineSpacing, dwis.d);
}

clearTextFormatting(state : WigiEditorState) -> void {
	changeSelectionStyle(state, WigiClearTextFormatting());
	nextDistinct(state.interlineSpacing, dwis.d);
}

// it makes deep cloning, including behaviours, all styles, callbacks, etc for all elements
// so resulting WigiElement is not depend on the source in by any means
cloneWigiElement(doc : WigiElement) -> WigiElement {
	// we have to clone styles that has behaviours, refs, callbacks, etc.
	cloneWigiDocumentStyle = \s : WigiDocumentStyle -> {
		switch (s : WigiDocumentStyle) {
			WigiName(__): s;
		}
	}

	cloneWigiStoryStyle = \s : WigiStoryStyle -> {
		switch (s : WigiStoryStyle) {
			WigiName(__): s;
			ParagraphSpacing(__): s;
			WigiReference(__): s;
			WigiConvertToRelativeSize(): s;
			RemoveAllListSpacing(): s;
		}
	}

	cloneWigiLockType = \s : WigiLockType -> {
		switch (s : WigiLockType) {
			WigiReadOnly(): s;
			WigiSelectOnly(): s;
			WigiAddOnly(): s;
			WigiNoLock(): s;
		}
	}

	cloneWigiTextStyle = \s : WigiTextStyle -> {
		switch (s: WigiTextStyle) {
			BaselineShift(__): s;
			FontFamily(__): s;
			FontSize(__): s;
			Fill(__): s;
			FillOpacity(__): s;
			LetterSpacing(__): s;
			BackgroundFill(__): s;
			BackgroundFillOpacity(__): s;
			DoubleUnderline(): s;
			Language(__): s;
			Underline(): s;
			WigiHtmlResponsiveFontSize(__, __, __): s;
			WigiLock(type): WigiLock(cloneWigiLockType(type));
			WigiRelativeFontSize(__): s;
			WigiHtmlRelativeFontSizeWithEm(__): s;
			WigiAnnotation(__) : s;
		}
	}

	cloneWigiParagraphStyle = \s : WigiParagraphStyle -> {
		switch (s : WigiParagraphStyle) {
			CenterAlign(): s;
			LeftAlign(): s;
			RightAlign(): s;
			StartAlign(): s;
			EndAlign(): s;
			Justify(): s;
			TightWidth(): s;
			InterlineSpacing(__): s;
			GeneralIndent(__): s;
			FirstLineIndent(__): s;
			FixedWidth(): s;
			Listed(type, style):  Listed(type, map(style, cloneWigiTextStyle));
			ReplaceTightWidthWithAlign(): s;
			ReplaceAlignWithTightWidth(): s;
			WigiStylesName(__): s;
			WigiAspect(__, __): s;
			DynamicBlockDelay(__): s;
			ParagraphBorder(__, __): s;
			WigiParagraphExternalStyle(__): s;
		}
	}

	cloneBehaviour1 = \s : Behaviour -> {
		switch (s : Behaviour) {
			ConstBehaviour(v): s;
			DynamicBehaviour(v, __): make(^v);
		}
	}

	cloneWigiRecursiveStyle = \s: WigiRecursiveStyle -> {
		switch (s : WigiRecursiveStyle) {
			WigiName(__): s;
			Underline(): s;
			BaselineShift(__): s;
			DoubleUnderline(): s;
			WigiEnabled(enabled): WigiEnabled(cloneBehaviour1(enabled));
			WigiEditorPreview(): s;
			WigiRecursiveFontStyle(__) : s;
		}
	}

	cloneWigiBlockStyle = \s : WigiBlockStyle -> {
		switch (s : WigiBlockStyle) {
			WigiName(__): s;
			BaselineShift(__): s;
			FontFamily(__): s;
			FontSize(__): s;
			Fill(__): s;
			FillOpacity(__): s;
			LetterSpacing(__): s;
			BackgroundFill(__): s;
			BackgroundFillOpacity(__):  s;
			DoubleUnderline():  s;
			Language(__):  s;
			Underline():  s;
			WigiHtmlResponsiveFontSize(__, __, __):  s;
			WigiLock(__):  s;
			WigiRelativeFontSize(__):  s;
			WigiHtmlRelativeFontSizeWithEm(__):  s;
			ExternalDeleteElement(__): ExternalDeleteElement(nop);
			WigiEditorPreview(): s;
			WigiAnnotation(__) : s;
		}
	}

	switch(doc : WigiElement){
		WigiDocument(root, ds) : WigiDocument(cloneWigiElement(root), map(ds, cloneWigiDocumentStyle));
		WigiStory(pars, __, ss): WigiStory(ref map(^pars, cloneWigiElement), ref [], map(ss, cloneWigiStoryStyle));
		WigiParagraph(elements, ps): WigiParagraph(map(elements, cloneWigiElement), map(ps, cloneWigiParagraphStyle));
		WigiRecursive(elements, type, rs): WigiRecursive(map(elements, cloneWigiElement), type, map(rs, cloneWigiRecursiveStyle));
		WigiText(text, ts): WigiText(text, map(ts, cloneWigiTextStyle));
		WigiBlock(type, bs): WigiBlock(type, map(bs, cloneWigiBlockStyle));
		WigiEmpty(): doc;
	}
}

isEventAllowed(state : WigiEditorState, event : WigiEvent) -> bool {
	isAnnotationMode = getValue(extractStruct(state.wigiEditorStyle, WigiEditorAnnotationModeTrigger(const(false))).isAnnotationModeB);
	if (isAnnotationMode) isAnnotationRelatedEvent(event) else true
}

isAnnotationRelatedEvent(event : WigiEvent) -> bool {
	switch (event) {
		WigiNone(): false;
		WigiCursorLeft(__) : true;
		WigiCursorRight(__) : true;
		WigiCursorDown(__) : true;
		WigiCursorUp(__) : true;
		WigiPageUp(__) : true;
		WigiPageDown(__) : true;
		WigiHome(__) : true;
		WigiEnd(__) : true;
		WigiSelectAll() : true;
		WigiSelectWord() : true;
		WigiSelectSentence() : true;
		WigiCopy(__): true;
		WigiCopySpecial(__): true;

		WigiSpace(): false;
		WigiInsertText(__) : false;
		WigiInsertElement(__) : false;
		WigiCut(): false;
		WigiPaste(): false;
		WigiDelete(): false;
		WigiDeleteElement(__): false;
		WigiBackspace(): false;
		WigiEnter(__): false;
		WigiUndo(): true;
		WigiRedo(): true;
		WigiSetColor(__): false;
		WigiSetBackgroundColor(__): false;
		WigiSetFontSize(__): false;
		WigiSetFontFamily(__): false;
		WigiSetLetterSpacing(__) : false;
		WigiSwitchFontFamily(__, __): false;
		WigiModifyFontSize(__, __): false;
		WigiSetUnderline(__): false;
		WigiSetDoubleUnderline(__): false;
		WigiSetBaselineShift(__): false;
		WigiClearTextFormatting(): false;
		WigiSetName(__): false;
		WigiSetLock(__): false;
		WigiSetLanguage(__): false;
		WigiSetTableHighlight(__, __): false;
		WigiSetShowGrid(__): false;
		WigiSetDontFitToAvailableWidth(__): false;
		WigiSetSameRowHeight(__): false;
		WigiSetShowHeaders(__): false;
		WigiSetShowFormulaBar(__): false;
		WigiSetTableBorder(__): false;
		WigiSetTableSize(__, __): false;
		WigiSetParagraphStyle(__, __): false;
		WigiSetCellsTightWidth(__): false;
		WigiSetVisibleFormula(__): false;
		WigiClearParagraphFormatting(): false;
		WigiModifyParagraphStyle(__): false;
		WigiReplaceParagraphStyle(__): false;
		WigiSetStoryStyle(__, __): false;
		WigiModifyStoryStyle(__): false;
		WigiLeftWord(__) : false;
		WigiRightWord(__): false;
		WigiUpWord(__): false;
		WigiDownWord(__): false;
		WigiDeleteWord(): false;
		WigiBackspaceWord(): false;
		WigiTab(__): false;
		WigiInsertFormula(__): false;
		WigiZoomIn(): false;
		WigiZoomOut(): false;
		WigiResetZoom(): false;
		WigiSetCellCursor(): false;
		WigiSetCursor(__, __): false;
		WigiChangeBlock(__): false;
		WigiChangeRecursive(__): false;
		WigiInsertColumn(__, __): false;
		WigiDeleteColumn(): false;
		WigiInsertRow(__, __): false;
		WigiDeleteRow(): false;
		WigiMergeCellsRight(): false;
		WigiMergeCellsDown(): false;
		WigiSplitCellsHorizontal(): false;
		WigiSplitCellsVertical(): false;
		WigiSetColumnWidth(__): false;
		WigiSetRowHeight(__): false;
		WigiSetTableCellStyle(__): false;
		WigiApplyTableCellTemplate(__): false;
		WigiDeleteTable(): false;
		WigiSetColumnsRigid(__) : false;
		WigiInsertPageBreak(): false;
		WigiInsertNaturalMath(): false;
		WigiInsertNativeWiki(__): false;
		WigiInsertHTML(__): false;
		WigiRenameRadioGroup(__): false;
		WigiDeleteRadioGroup(): false;
		WigiChangeRadioOptionValue(__): false;
		WigiDeleteRadioOption(): false;
		WigiSetRadioGroupLayout(__): false;
		WigiSetRadioGroupWidth(__): false;
		WigiSwapParagraph(__): false;
		WigiCleanUpParagrapshIndents(__): false;

		WigiSetAnnotation(__) : true;
	}
}
