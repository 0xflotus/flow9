import wigi/types;
import lingo/pegcode/driver;
import wigi/wigi_expr_pegop;
import algorithms;

export {
	// Parses the formula, and returns the expression where var refs have been uppercases
	parseWigiExpr(code : string) -> WigiExpr;

	// The same but uses parsic3 inside, so that it retunrs error as well
	parseWigiExprExtended(code : string) -> WigiExprParseResultExt;

	// Same as parseWigiExpr, but it doesn't make names uppercase
	// (used for condition editor)
	parseWigiExprNoPreprocessing(code : string) -> WigiExpr;
	semanticActionsForWigiExpr : SemanticActions;

	WigiExprParseResultExt(expr : WigiExpr, parsedSoFar : int, errorMessage : string);

	isValidWigiExpression(code : string) -> bool;
}

// interval in milliseconds between worker of the cache wakes up.
// it cleanup cache (deletes entries not accessed wigiExprParserCacheAgeoutTime) and print stats (if enabled)
wigiExprParserCacheWorkerInterval : int = 60000;

// time in milliseconds used to cleanup entries from the cache.
// entries not accessed more than this value will be purged from the cache by worker in its next run
wigiExprParserCacheAgeoutTime : double = 300000.0;

// it is used to relieve timestamp overhead - timestamp() called onece for wigiExprParserCacheTimestampSkips times entry accesses
wigiExprParserCacheTimestampSkips : int = 500;


// ADT to handle left-associative expressions like a.b(c)[d][e]().f[g]
WigiParseValuePart ::= WigiParseInfixCall, WigiParseField, WigiParsePrefixCall;
	WigiParseInfixCall(op : string, index : [WigiExpr]);
	WigiParseField(field : WigiExpr);
	WigiParsePrefixCall(args : [WigiExpr]);

semanticActionsForWigiExpr = SemanticActions(
	defaultPegActions.t |> (\t -> setTree(
		t,
		"parseLAssocInfixSeq",
		\args : [flow] -> fold(args[1], args[0], \arg1, exprPart -> {
			switch (exprPart : WigiParseValuePart) {
				WigiParseInfixCall(op, indexes) : WigiCall(WigiString(op), concat([arg1], indexes));
				WigiParsePrefixCall(arg) : WigiCall(arg1, arg);
				WigiParseField(field) : WigiField(arg1, [field]);
			}
		}))
	) |> (\t : Tree<string, ([flow]) -> flow> -> setTree(t, "deserializeString", \args : [flow] -> {
	        deserialized = deserializeString(args[0]);
	        if (deserialized.second == "") WigiString(deserialized.first) else WigiError("PARSING FAILED")
	}))
);

parseWigiExpr(code : string) -> WigiExpr {
	parseAction : () -> WigiExpr = \ -> {
		flo : flow = parsic(pegOps4Wigi_expr, code, semanticActionsForWigiExpr);
		// dumpParseCacheStats(foldTree(grammar.second, [], \k, v, acc -> arrayPush(acc, v)));
		if (flo == "PARSING FAILED") WigiError(flo) else preProcessWigiExpr(flo)
	}

	if (useWigiExprParserCache)	{
		wigiExprParserCacheLookup(code, \ -> WigiExprParserCacheEntry(parseAction(), WigiExprParserCacheStats(ref 0, ref 0.0))).expr
	} else {
		parseAction();
	}
}

parseWigiExprNoPreprocessing(code : string) -> WigiExpr {
	parseAction : () -> WigiExpr = \ -> {
		flo : flow = parsic(pegOps4Wigi_expr, code, semanticActionsForWigiExpr);
		// dumpParseCacheStats(foldTree(grammar.second, [], \k, v, acc -> arrayPush(acc, v)));
		if (flo == "PARSING FAILED") WigiError(flo) else flo
	}

	if (useWigiExprParserCache)	{
		wigiExprParserCacheLookup("#1:" + code, \ -> WigiExprParserCacheEntry(parseAction(), WigiExprParserCacheStats(ref 0, ref 0.0))).expr;
	}
	else {
		parseAction();
	}
}

parseWigiExprExtended(code : string) -> WigiExprParseResultExt {
	parseAction : () -> WigiExprParseResultExt = \ -> {
		def = WigiError("PARSING FAILED");
		flo : flow = parsic3(pegOps4Wigi_expr, code, semanticActionsForWigiExpr, def);
		WigiExprParseResultExt(preProcessWigiExpr(flo.first), flo.second, flo.third);
	}

	if (useWigiExprParserCache) {
		result2cacheEntry = \t : WigiExprParseResultExt, stats : WigiExprParserCacheStats -> WigiExprParserCacheEntry3(t.expr, t.parsedSoFar, t.errorMessage, stats);

		cacheEntry = wigiExprParserCacheLookup(code, \ -> result2cacheEntry(parseAction(), WigiExprParserCacheStats(ref 0, ref 0.0)));

		switch (cacheEntry : WigiExprParserCacheEntries) {
			WigiExprParserCacheEntry(__, stats): {
				// we have parsed expression in the cache but we are requested for extended result so we upgrade cache entry to extended
				parseResult : WigiExprParseResultExt = parseAction();
				wigiExprParserCache := setTree(^wigiExprParserCache, code, result2cacheEntry(parseResult, stats));
				parseResult;
			}

			WigiExprParserCacheEntry3(expr, parsedSoFar, errorMessage, __): {
				WigiExprParseResultExt(expr, parsedSoFar, errorMessage);
			}
		}
	} else {
		parseAction();
	}
}

preProcessWigiExpr(e : WigiExpr) -> WigiExpr {
	switch(e : WigiExpr) {
		WigiBuiltInName(name): e |> preProcessWigiValue;
		WigiArray(values): WigiArray(map(values, preProcessWigiValue));
		WigiRecord(fields): WigiRecord(map(fields, \p -> Pair(p.first, p.second |> preProcessWigiValue)));
		WigiVarRef(x): e |> preProcessWigiVarRef;
		WigiCellRefA1(x): e |> preProcessWigiCellRefA1;

		WigiLambda(args, body): WigiLambda(args, body |> preProcessWigiExpr);
		WigiCall(fn, args): WigiCall(fn |> preProcessWigiExpr, map(args, preProcessWigiExpr));
		WigiIf(condition, then, _else): WigiIf(condition |> preProcessWigiExpr, then |> preProcessWigiExpr, _else |> preProcessWigiExpr);
		WigiSequence(exprs): WigiSequence(map(exprs, preProcessWigiExpr));
		WigiMatch(expr, cases): WigiMatch(expr |> preProcessWigiExpr, map(cases, \case -> WigiMatchCase(case.pattern |> preProcessWigiExpr, case.body |> preProcessWigiExpr)));
		WigiRangeA1(start, end): WigiRangeA1(start |> preProcessWigiCellRefA1, end |> preProcessWigiCellRefA1);
		WigiField(left, right): WigiField(left |> preProcessWigiExpr, map(right, preProcessWigiExpr));
		WigiNamespace(ns, right): WigiNamespace(ns, right |> preProcessWigiExpr);
		WigiMultiplicative(exprs): WigiMultiplicative(map(exprs, preProcessWigiExpr));
		WigiMult(op, expr): WigiMult(op, expr |> preProcessWigiExpr);
		WigiMakeArray(values): WigiMakeArray(map(values, preProcessWigiExpr));
		WigiMakeRecord(fields): WigiMakeRecord(map(fields, \p -> Pair(p.first, p.second |> preProcessWigiExpr)));

		WigiBool(__): e;
		WigiInt(__): e;
		WigiDouble(__): e;
		WigiString(__): e;
		WigiTime(__, __, __): e;
		WigiError(__): e;
		WigiDate(__, __, __): e;
		WigiRangeRC(__, __): e;
		WigiDefaultValue(): e;
		WigiCellRefRC(__, __): e;
		WigiElementValue(__): e;

		WigiDatafunList(__, __) : e;
		WigiDatafunInExpr(__, __) : e;
	}
}

preProcessWigiVarRef(v : WigiVarRef) -> WigiVarRef {
	preFn = toUpperCase;
	WigiVarRef(v.x |> preFn);
}

preProcessWigiCellRefA1(v : WigiCellRefA1) -> WigiCellRefA1 {
	preFn = toUpperCase;
	WigiCellRefA1(v.x |> preFn);
}

preProcessWigiValue(v : WigiValue) -> WigiValue {
	preFn = toUpperCase;
	switch(v) {
		WigiBuiltInName(name): WigiBuiltInName(name |> preFn);
		default: v;
	}
}

useWigiExprParserCache = {
	if (isParameterTrue(getUrlParameterDef("wigiParserCache", "true"))) {
		devtrace("Global cache for wigi parser is ON");
		cacheStatsReport : ref [WigiExprParserCacheReportLine] = ref [];
		ignore(subscribe2(repeatable(wigiExprParserCacheWorkerInterval).value, \v -> wigiExprParserCacheWorker(cacheStatsReport, 10)));
		true;
	} else {
		devtrace("Global cache for wigi parser is OFF");
		false;
	}
}

WigiExprParserCacheEntries ::= WigiExprParserCacheEntry, WigiExprParserCacheEntry3;
WigiExprParserCacheEntry(expr : WigiExpr, cacheStats : WigiExprParserCacheStats);
WigiExprParserCacheEntry3(expr : WigiExpr, parsedSoFar : int, errorMessage : string, cacheStats : WigiExprParserCacheStats);
WigiExprParserCacheStats(touchCount : ref int, accessTime : ref double);

wigiExprParserCache : ref Tree<string, WigiExprParserCacheEntries> = ref makeTree();

WigiExprParserCacheReportLine(code : string, touchCount : int, accessTime : double);

wigiExprParserCacheLookup(key : string, makeEntryFn : () -> WigiExprParserCacheEntries) -> WigiExprParserCacheEntries {
	wigiExprParserCacheTouchEntry(
		lookupTreeSet(
			wigiExprParserCache,
			key,
			\__ -> makeEntryFn()
		)
	);
}

wigiExprParserCacheTouchEntry(entry : WigiExprParserCacheEntries) -> WigiExprParserCacheEntries {
	// timestamp is relatively expensive function so we call it seldom
	if (mod(^(entry.cacheStats.touchCount), wigiExprParserCacheTimestampSkips) == 0) entry.cacheStats.accessTime := timestamp();
	entry.cacheStats.touchCount := ^(entry.cacheStats.touchCount) + 1;
	entry;
}

wigiExprParserCacheWorker(cacheStatsReport : ref [WigiExprParserCacheReportLine], lines : int) -> void {
	currentTime = timestamp();

	wigiExprParserCache := filterTree(^wigiExprParserCache, \__, value : WigiExprParserCacheEntries -> (currentTime - ^(value.cacheStats.accessTime)) <= wigiExprParserCacheAgeoutTime);

	if (isUrlParameterTrue("wigiParserCacheStats")) {
		allLines = foldTree(^wigiExprParserCache, [], \key : string, value : WigiExprParserCacheEntries, acc : [WigiExprParserCacheReportLine] -> {
					arrayPush(acc, WigiExprParserCacheReportLine(key, ^(value.cacheStats.touchCount), ^(value.cacheStats.accessTime)))
				});
		newcacheStatsReport = take(
			sortCustom(
				allLines,
				\reportLine : WigiExprParserCacheReportLine -> reportLine.touchCount,
				false
			),
			lines
		);
		if (newcacheStatsReport != ^cacheStatsReport) {
			cacheStatsReport := newcacheStatsReport;
			println("--wigiExprParserCache--");
			println("Total elements: " + i2s(length(allLines)));
			println("Access count | Accessed sec ago | code");
			iter(^cacheStatsReport, \rl : WigiExprParserCacheReportLine -> {
				println(formatString("%1 | %2 | %3", [rpad(i2s(rl.touchCount), " ", 8), rpad(d2st((currentTime - rl.accessTime) / 1000., 1), " ", 8), rl.code]));
			});
			println("---------------------------------");
		}
	}
}

isValidWigiExpression(code : string) -> bool {
	parseWigiExprExtended(code).errorMessage == "";
}