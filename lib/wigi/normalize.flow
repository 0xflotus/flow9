import wigi/recursive_tools;
import wigi/block_debug;
import wigi/random_names;
import wigi/table_cells_creator;
import wigi/wigi_paragraph_style;

export {
	// Make sure to sprinkle empty texts in between recursives to get editing to work well
	normalizeWigiElements(elements : [WigiElement]) -> [WigiElement];
	normalizeWigiDocument(doc : WigiElement) -> WigiElement;

	// Check if the element is properly normalized
	isElementNormalized(element: WigiElement) -> bool;

	// Check if the element is properly formed
	isElementCorrect(element: WigiElement) -> bool;

	// Transform element so that it can be pasted
	prepareWigiElementForPaste(document : WigiElement, element : WigiElement) -> WigiElement;
}

normalizeWigiElements(wigiElements : [WigiElement]) -> [WigiElement] {
	elements = normalizeTextElements(wigiElements);
	foldi(elements, [], \i, acc : [WigiElement], e -> {
		switch (e: WigiElement) {
			WigiRecursive(__, __, __): {
				if (i == 0 && length(elements) == 1) {
					// This paragraph consist only of one recursive, so we should add two empty texts
					[emptyWigiText, e, emptyWigiText]
				} else {
					if (i == 0) {	// This paragraph starts with recursive, so insert empty text before it
						concat(acc, [emptyWigiText, e])
					} else if (i == length(elements) - 1 || isWigiBlock(elements[i+1], [WigiPositionTag(1)])) {
						// Paragraph ends with recursive or after recursive is WigiPositionTag, insert emptyText after recursive
						concat(acc, [e, emptyWigiText])
					} else {
						// We're in the middle
						le = lastElement(acc, WigiEmpty());
						if (isWigiRecursive(le, [])) {
							// We have two recursives in a row, insert empty text between them
							concat(acc, [emptyWigiText, e])
						} else {
							arrayPush(acc, e)
						}
					}
				}
			}
			default: {
				arrayPush(acc, e)
			}
		}
	});
}

// join some consecutive text elements with the same style to a single text element
normalizeTextElements(elements : [WigiElement]) -> [WigiElement]{
	textAcc : ref WigiText = ref emptyWigiText;

	addTextAcc = \acc2 : [WigiElement] -> {
		if (^textAcc != emptyWigiText){
			nacc = arrayPush(acc2, ^textAcc);
			textAcc := emptyWigiText;
			nacc
		} else acc2;
	}

	newElements = fold(elements, [], \acc, e -> {
		switch(e){
			WigiText(text, ts): {
				if (e != emptyWigiText){
					if (^textAcc == emptyWigiText){
						textAcc := e;
						acc
					} else if (ts == ^textAcc.style){
						textAcc := WigiText(^textAcc.text + text, ts);
						acc
					} else if (trim2(text, "_") == "" && trim2(^textAcc.text, "_") == "") {
						//#39203.
						// WigiParagraph([WigiText("_", []), WigiText("___", [FontFamily("Book")])], []) is not normilized
						// as [FontFamily("Book")] is not default style with paamskin=1 and, thus, is not reduced to [].
						textAcc := WigiText(^textAcc.text + text, ^textAcc.style);
						acc
					} else {
						acc2 = addTextAcc(acc);
						textAcc := e;
						acc2;

					}
				} else {
					arrayPush(addTextAcc(acc), e);
				}
			}
			default: {
				arrayPush(addTextAcc(acc), e);
			}
		}
	});
	// do not forget to add stuff from text acc if there is any
	addTextAcc(newElements);
}

// applies normalizeWigiElements to all the paragraphs in Wigi document and normalizes paragraphs' styles
normalizeWigiDocument(doc : WigiElement) -> WigiElement {
	switch(doc){
		WigiDocument(root, ds) : WigiDocument(normalizeWigiDocument(root), ds);
		WigiStory(pars, __, ss): WigiStory(ref map(^pars, normalizeWigiDocument), ref [], ss);
		WigiParagraph(elements, ps): WigiParagraph(map(normalizeWigiElements(elements), normalizeWigiDocument), normalizeWigiParagraphStyle(ps));
		WigiRecursive(elements, type, rs): WigiRecursive(map(elements, normalizeWigiDocument), type, rs);
		WigiText(__, __): doc;
		WigiBlock(__, __): doc;
		WigiEmpty(): doc;
	}
}

isElementNormalized(element: WigiElement) -> bool {
	switch (element: WigiElement) {
		WigiParagraph(elements, style): {	// That's what we wanna check
			normalizedElements = normalizeWigiElements(elements);
			newElements = map(normalizedElements, \el -> prepareWigiElementForPaste(WigiEmpty(), el));

			length(newElements) == length(elements)
		}

		default: {
			// Check recursively
			children = getWigiElementChildren(element, false);
			all(map(children, isElementNormalized))
		}
	}
}

isElementCorrect(element: WigiElement) -> bool {
	checkElements = \elements -> {
		all(map(elements, isElementCorrect))
	}

	switch (element: WigiElement) {
		WigiRecursive(elements, type, style): {	// That's what we wanna check
			switch (type: WigiRecursiveType) {
				WigiTable(rows, cols, cellSpans, s): {
					// Number of cells is reduced by merged cells
					if (length(elements) == rows * cols - fold(cellSpans, 0, \acc, cs -> acc + cs.row + cs.col - 2)) {
						checkElements(elements)
					} else {
						false
					}
				}

				default: (findWigiElement(element, WigiEmpty()) == []);
			}
		}

		default: {
			// Check recursively
			children = getWigiElementChildren(element, false);
			checkElements(children)
		}
	}
}

addStoryParagraphToWigiElements(elements : [WigiElement]) -> [WigiElement] {
	map(elements, \element -> {
		switch(element) {
			WigiStory(__, __, __): element;
			WigiParagraph(__, __): makeWigiStory([element], []);
			default: makeWigiStory([WigiParagraph([element], [TightWidth()])], []);
		}
	});
}

prepareWigiElementForPaste(document : WigiElement, element : WigiElement) -> WigiElement {
	switch (element: WigiElement) {
		WigiRecursive(es, t, s): {
			newElements = fold(es, [], \ne, e -> {
				switch(e) {
					WigiRecursive(ces, ct, cs): {
						arrayPush(ne, WigiRecursive(addStoryParagraphToWigiElements(ces), ct, cs));
					}
					WigiEmpty(): {
						switch(t) {
							WigiTable(__, __, __, __): ne;
							default: arrayPush(ne, WigiRecursive([makeWigiStory([WigiParagraph([WigiText("", [])], [TightWidth()])], [])], WigiFrame(1000.0, 1000.0, [TightWidth(), TightHeight()]), []));
						}
					}
					default: arrayPush(ne, e);
				}
			});

			switch (t: WigiRecursiveType) {
				WigiTable(rs, cs, cellSpans, tableStyle): {
					elementsCount = length(newElements);
					spansCount = length(cellSpans);

					if (elementsCount != spansCount) {
						isSpreadsheet = elementsCount > 0 && isWigiRecursive(newElements[0], [dummyWigiSpreadsheetCell]);

						newTableName = getRandomName("table", \name -> isProperName(name, document));
						newStyle = arrayPush(filter(s, \st -> switch(st) {WigiName(__): false; default: true;}), WigiName(newTableName));

						cellsCount = max(elementsCount, spansCount);

						newElementsCount = cellsCount - elementsCount;

						ne = concat(newElements, if (isSpreadsheet) createWigiSpreadsheetCells(newElementsCount, [])
							else createWigiTableCells(newElementsCount, []));

						newSpansCount = cellsCount - spansCount;

						newTable = WigiRecursive(
							ne,
							WigiTable(rs, cs, concat(cellSpans, generate(0, newSpansCount, \__ -> WigiCellSpan(1, 1))), tableStyle),
							newStyle
						);

						if (isSpreadsheet) setWigiTableCellNames(newTable) else newTable;
					} else WigiRecursive(newElements, t, s);
				}
				default: WigiRecursive(newElements, t, s);
			}
		}
		default: element;
	}
}

