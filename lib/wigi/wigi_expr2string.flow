import wigi/wigi2string;
import stringmath;

export {
	// Converts WigiExpr to string representation
	wigiExpr2string(expr: WigiExpr) -> string;
}

wigiExpr2string(expr: WigiExpr) -> string {
	recursiveCall = \e -> wigiExpr2string(e);

	wigiRecord2String = \fields : [Pair<string, WigiExpr>] -> {
		"{" + strGlue(map(fields, \p -> formatString("%1:%2", [p.first, p.second |> recursiveCall])), ",") + "}"
	}

	wigiArray2String = \values : [WigiExpr] -> {
		"[" + strGlue(map(values, recursiveCall), ",") + "]"
	}

	switch(expr : WigiExpr) {
		WigiBool(b): b2s(b);
		WigiInt(v): i2s(v);
		WigiDouble(v): d2st(v, 10);	// To avoid 0.12000000001
		WigiString(v): serialize(v);
		WigiDate(y, m, d): i2s(d) + "/" + i2s(m) + "/" + i2s(y);
		WigiTime(h, m, s): i2s(h) + ":" + i2s(m) + ":" + i2s(s);
		WigiError(message): "Error: " + message;
		WigiDefaultValue(): ""; // have to be empty
		WigiElementValue(element): wigi2string(element);
		WigiBuiltInName(name): name;
		WigiVarRef(x): x;
		WigiCellRefA1(x): x;
		WigiCellRefRC(r, c): {
			ref2string = \d: CellRef -> {
				switch(d) {
					RelRef(dx): if (dx == 0) "" else "[" + i2s(dx) + "]";
					AbsRef(x): i2s(x)
				}
			}
			"R" + ref2string(r) + "C" + ref2string(c)
		}
		WigiLambda(args, body): ""; // because WigiLambda isn't implemented yet
		WigiArray(values): wigiArray2String(values);
		WigiCall(fn, args): {
			func = switch (fn) { // since we don't want wigistring quotes in operators
				WigiString(fun): fun;
				default: recursiveCall(fn);
			}
			arguments = map(args, recursiveCall);
			infixOperators = ["+", "-", "*", "/", "=", "<>", "!=", "<=", ">=", ">", "<", "^", "%"];
			infixTextOperators = ["and", "or"];
			if (contains(infixOperators, func)) "(" + strGlue(arguments, func) + ")"
			else if (contains(infixTextOperators, func)) "(" + strGlue(interleave(arguments, func), " ") + ")"
			else if (func == "[") arguments[0] + "[" + arguments[1] + "]"
			else func + "(" + strGlue(arguments, ",") + ")"
		}
		WigiIf(condition, then, else_): {
			condStr = condition |> recursiveCall;
			thenStr = then |> recursiveCall;
			elseStr = else_ |> recursiveCall;
			"if " + condStr + " then " + thenStr + (if (elseStr != "") " else " + elseStr else "")
		}
		WigiSequence(exprs): fold(exprs, "{", \acc, e -> acc + (if (acc != "{") "; " else "") + wigiExpr2string(e)) + "}";
		WigiMatch(e, cases): ""; // because WigiMatch isn't implemented yet
		WigiRangeA1(start, end): (start |> recursiveCall) + ":" + (end |> recursiveCall);
		WigiRangeRC(start, end): (start |> recursiveCall) + ":" + (end |> recursiveCall);
		// Local function record2string(fs) inlined for new compiler
		WigiRecord(fields): wigiRecord2String(map(fields, \f -> Pair(f.first, cast(f.second : WigiValue -> WigiExpr))));
		WigiField(l, rs): fold(rs, wigiExpr2string(l), \acc, r -> {
			acc + "." + wigiExpr2string(r)
		});
		WigiNamespace(ns, r): fold(ns, "", \acc, n -> {
			acc + n + "!"
		}) + wigiExpr2string(r);
		WigiMultiplicative(exprs): {
			arguments = map(exprs, recursiveCall);
			strGlue(arguments, "")
		}
		WigiMult(op, e): {
			exprStr = e |> recursiveCall;
			exprStr + op
		}
		WigiMakeArray(values): wigiArray2String(values);
		// Local function record2string(fs) inlined for new compiler
		WigiMakeRecord(fields): wigiRecord2String(fields);

		WigiDatafunList(mainExpr, varsExprs) : {
			varsExprsStrings = map(varsExprs, recursiveCall);

			"[" + recursiveCall(mainExpr) + "|" + strGlue(varsExprsStrings, ",") + "]";
		}
		WigiDatafunInExpr(id, e) : id + " in " + recursiveCall(e);
	}
}
