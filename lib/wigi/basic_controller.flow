import wigi/editor_types;
import wigi/recursive_tools;


export {
	// Returns the resulting element, and a bool defining whether it was handled by side effect or not.
	// If false, then the change is done by side effects only
	replaceElement(root : WigiElement, path : [int], element : WigiElement) -> Pair<WigiElement, bool>;
	replaceElementInDocument(state : WigiEditorState, path : [int], e : WigiElement) -> void;

	// Some service functions for controller
	hasFixedChildCount(element: WigiElement) -> bool;
	isWigiComap(e: WigiElement) -> bool;

	// Finds element that satisfies given predicate and contains given position `pos`
	findElementContainingPosition(state: WigiEditorState, predicate: (WigiEditorState, [int]) -> bool, pos: [int]) -> Maybe<[int]>;

	isEmptyDeletableRecursive(state: WigiEditorState, path: [int]) -> bool;

	// Scrolls so that the point is visible
	ensurePointVisible(state : WigiEditorState, point : Point) -> void;

}

replaceElementInDocument(state : WigiEditorState, path : [int], e : WigiElement) -> void {
	root = getValue(state.document);
	pair = replaceElement(root, path, e);
	if (pair.second) {
		nextDistinct(state.document, pair.first);
	}
}

replaceElement(root : WigiElement, path : [int], element : WigiElement) -> Pair<WigiElement, bool> {
	if (path == []) Pair(element, true)
	else {
		first = path[0];
		rest = tail(path);
		switch (root : WigiElement) {
			WigiDocument(r, s): {
				ce : Pair<WigiElement, bool> = replaceElement(r, rest, element);
				if (ce.second)
					Pair(cast(WigiDocument(ce.first, s) : WigiDocument -> WigiElement), true)
				else Pair(root, false);
			}
			WigiStory(p, v, s): {
				if (first >= length(^p)) {
					println("Incorrect path in replace");
				}

				step = indexWigiChildren(root, first, root);
				ce = replaceElement(step, rest, element);
				isFormArrayEmpty = ^v == [];
				if (ce.second) {
					p := replace(^p, first, ce.first);

					if (!isFormArrayEmpty) {
						fa0 = ^(v)[0];
						replaceTropicArray(fa0, first, ce.first);
					}
				}
				// There is never any change in the element itself - it is only side effects
				Pair(root, isFormArrayEmpty);
			}
			WigiParagraph(el, s): {
				if (first >= length(el)) {
					println("Incorrect path in replace");
				}

				step = indexWigiChildren(root, first, root);
				ce = replaceElement(step, rest, element);
				if (ce.second) {
					ne = replace(el, first, ce.first);
					Pair(cast(WigiParagraph(ne, s) : WigiParagraph -> WigiElement), true);
				} else {
					Pair(root, false);
				}
			}
			WigiText(txt, style): Pair(element, true);
			WigiEmpty(): Pair(element, true);
			WigiRecursive(el, type, style): {
				step = indexWigiChildren(root, first, root);
				ce = replaceElement(step, rest, element);
				if (ce.second) {
					ne = replace(el, first, ce.first);
					Pair(cast(WigiRecursive(ne, type, style) : WigiRecursive -> WigiElement), true);
				} else {
					Pair(root, false);
				}
			}
			WigiBlock(type, style): Pair(element, true);
		}
	}
}

ensurePointVisible(state : WigiEditorState, point : Point) -> void {
	wh = getValue(state.viewSize);
	x1 = getValue(state.viewX);
	x2 = x1 + wh.width;
	y1 = getValue(state.viewY);
	y2 = y1 + wh.height;

	ensureWithin(state.viewX, x1, x2, point.x);
	ensureWithin(state.viewY, y1, y2, point.y);
}

ensureWithin(v : DynamicBehaviour<double>, x1 : double, x2 : double, x : double) -> void {
	if (x < x1) {
		delta = x1 - x;
		nextDistinct(v, getValue(v) - delta);
	} else if (x > x2) {
		delta = x - x2;
		nextDistinct(v, getValue(v) + delta);
	}
}

// Finds element that satisfies given predicate and contains given position `pos`
findElementContainingPosition(state: WigiEditorState, predicate: (WigiEditorState, [int]) -> bool, pos: [int]) -> Maybe<[int]> {
	if (predicate(state, pos)) {
		Some(pos)
	} else {	// Go to parent
		if (pos == []) {	// We're at the top element already, found nothing
			None()
		} else {
			findElementContainingPosition(state, predicate, wigiParentPath(pos))
		}
	}
}

isEmptyDeletableRecursive(state : WigiEditorState, path : [int]) -> bool {
	root = getValue(state.document);
	e = getElementAtPosition(root, path);
	isComap = isWigiComap(e);
	isException = \ -> isWigiRecursive(e, [dummyWigiTable, dummyWigiTableCell, dummyWigiSpreadsheetCell, WigiVersions([]), WigiFrame(0.0, 0.0, [])]);
	areChildrenEmpty = \ -> all(map(getWigiElementChildren(e, false), isEmptyElement));

	if ((hasFixedChildCount(e) || isComap) && !isException() && areChildrenEmpty()) {
		// We should also check if we can delete this element, i.e. parent element should have non-fixed child count
		parent = getElementAtPosition(root, wigiParentPath(path));

		// There is also a special case, allow delete empty comaps under other comaps
		!hasFixedChildCount(parent) || isWigiComap(e) && isWigiComap(parent)
	} else {
		false
	}
}

hasFixedChildCount(element: WigiElement) {
	switch (element) {
		WigiRecursive(elements, type, style): {
			switch (type: WigiRecursiveType) {
				WigiTable(__, __, __, __): true;
				WigiExternalRecursive(exType, content): {
					eitherFn(
						getExternalRecursiveAPI(exType),
						\api -> {
							canDeleteFn = extractStruct(api.style, ExternalRecursiveCanDeleteChild(\__, __ -> true)).fn;
							!canDeleteFn(content, elements);
						},
						\ -> false
					)
				}
				default: wigiRecursiveChildCount(type) != -1;
			}
		}

		default: false;
	}
}

isWigiComap(e: WigiElement) -> bool {
	switch (e) {
		WigiRecursive(__, t, __):
			switch(t) {
				WigiComap(__): true;
				default: false;
			}
		default: false;
	}
}

