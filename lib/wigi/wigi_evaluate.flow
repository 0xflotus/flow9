import wigi/wigi_environment;
import wigi/wigi_cell_refs;
import wigi/wigi_builtins;
import wigi/wigi_datafun_support;

export {
	// Does an evaluation of an expression
	evaluateEngineExpr(env : ref WigiEnvironment, externalFunctions: Tree<string, ([WigiValue]) -> WigiValue>, namespace : WigiScope, exprName: string, e : WigiExpr) -> WigiValue;

	// Removes any dollars in the name
	simplifyWigiCellRef(x: string) -> string;

	calculateChoiceCondition(operator : ChoiceOperator, v1 : WigiValue, v2 : WigiValue) -> bool;
}

evaluateEngineExpr(env : ref WigiEnvironment, externalFunctions: Tree<string, ([WigiValue]) -> WigiValue>, namespace : WigiScope, exprName: string, e : WigiExpr) -> WigiValue {
	evaluateEngineExprExt(env, externalFunctions, namespace, exprName, e, false, [])
}

evaluateEngineExprExt(env : ref WigiEnvironment, externalFunctions: Tree<string, ([WigiValue]) -> WigiValue>, namespace : WigiScope, exprName: string, e : WigiExpr, isFuncName : bool, requiredFields : [[string]]) -> WigiValue {
	recursiveCall = \expr -> evaluateEngineExprExt(env, externalFunctions, namespace, exprName, expr, isFuncName, requiredFields);
	// we want to treat names of the function to be called in a special way - we should check first if there is a built-in with the same name
	recursiveCallWigiCall = \expr -> evaluateEngineExprExt(env, externalFunctions, namespace, exprName, expr, true, requiredFields);
	// we want to create missed fileds in all WigiRecords down to the deepest field
	recursiveCallEnforceField = \expr, fields : [[string]] -> evaluateEngineExprExt(env, externalFunctions, namespace, exprName, expr, isFuncName, fields);

	switch (e : WigiExpr) {
		WigiBool(v): e;
		WigiInt(v): e;
		WigiDouble(v): e;
		WigiString(v): e;
		WigiDate(y, m, d): e;
		WigiTime(h, m, s): e;
		WigiError(v): e;
		WigiDefaultValue(): e;
		WigiElementValue(el): e; // TODO: Maybe we should traverse this and do stuff?
		WigiBuiltInName(v): e;
		WigiRecord(fields): e;
		WigiVarRef(x): {
			evaluateWigiName(env, namespace, x, isFuncName, externalFunctions, requiredFields)
		}
		WigiCellRefA1(x): {
			evaluateWigiName(env, namespace, simplifyWigiCellRef(x), isFuncName, externalFunctions, requiredFields);
		}
		WigiCellRefRC(r, c): {
			if ((r == RelRef(0)) && (c == RelRef(0))) WigiError("Recursive formula in cell " + exprName)
			else eitherMap(convertCellRefRC2CellRefA1(e, WigiCellRefA1(exprName)), recursiveCall, WigiError("Can't evaluate formula in cell " + exprName))
		}
		WigiLambda(args, body): {
			e;
		}
		WigiCall(fn, args): {
			lam = recursiveCallWigiCall(fn);
			eargs = map(args, recursiveCall);
			switch (lam) {
				WigiString(name): {
					callEngineBuiltin(env, name, eargs);
				}
				WigiBuiltInName(name): {
					if (containsKeyTree(getWigiBuiltIns(), name)) {
						callEngineBuiltin(env, name, eargs)
					} else {
						if (containsKeyTree(externalFunctions, name)) {
							callExternalFunction(externalFunctions, name, eargs)
						} else WigiError("Name not found: " + name)
					}
				}
				WigiLambda(largs, body): {
					nenv = foldi(largs, ^env, \i, acc, n -> {
						cell = wigiCellName(n, namespace);
						addWigiName(acc, cell, const(eargs[i]));
					});
					evaluateEngineExpr(ref nenv, externalFunctions, namespace, exprName, body);
				}
				WigiError(__): lam;
				default: {
					// TODO!
					WigiError("Call not implemented yet: " + lam.structname);
				}
			}
		}
		WigiIf(condition, then, else_): {
			v = condition |> recursiveCall;
			if (wigiValue2Bool(v)) {
				then |> recursiveCall;
			} else {
				else_ |> recursiveCall;
			}
		}
		WigiArray(values): {
			WigiArray(map(values, recursiveCall));
		}
		WigiSequence(exprs): {
			fold(exprs, WigiBool(false), \acc, ex -> {
				recursiveCall(ex);
			});
		}
		WigiMatch(value, cases): {
			v = value |> recursiveCall;
			doWigiMatch(env, v, cases);
		}
		WigiRangeA1(start, end): {
			evaluateRangeA1Expr(env, namespace, start, end)
		}
		WigiRangeRC(start, end): {
			_start = convertCellRefRC2A1(start);
			_end = convertCellRefRC2A1(end);
			recursiveCall(WigiRangeA1(_start, _end));
		}
		WigiField(l, rs): {
			// we collect all required field names and add to the requiredFields lsit to be used to check if they are axists later in evaluateWigiName
			le = recursiveCallEnforceField(l, concat([getRequiredRecordFields(rs)], requiredFields));
			switch(le) {
				WigiRecord(__): evaluateRecordField(le, rs);
				WigiArray(__): evaluateArrayField(le, rs);
				default: WigiError("It can't be calculated now");
			}
		}
		WigiNamespace(ns, r): {
			nsResolved = resolveWigiNamespace(^env, wigiCellName(exprName, namespace), ns);
			evaluateEngineExpr(env, externalFunctions, WigiScope(concat([exprName], nsResolved.names)), exprName, r);
		}
		WigiMultiplicative(exprs): {
			foldi(exprs, Pair(WigiDefaultValue(), ""), \idx, acc : Pair<WigiValue, string>, item -> {
				switch(item) {
					WigiMult(op, expr): {
						if (idx == 0) Pair(expr |> recursiveCall, op)
						else Pair(callEngineBuiltin(env, acc.second, [acc.first, expr |> recursiveCall]), op)
					}
					default: {
						if (idx == 0) Pair(WigiDefaultValue(), "")
						else Pair(callEngineBuiltin(env, acc.second, [acc.first, item |> recursiveCall]), "")
					}
				}
			}).first
		}
		WigiMult(op, expr): {
			// it is calculated in WigiMultiplicative
			WigiError("WigiMulti is not implemented")
		}
		WigiMakeArray(values): WigiArray(map(values, recursiveCall));
		WigiMakeRecord(fields): WigiRecord(map(fields, \p -> Pair(p.first, recursiveCall(p.second))));

		WigiDatafunList(mainExpr, varsExprs) : evaluateWigiDatafunList(mainExpr, varsExprs, recursiveCall);
		WigiDatafunInExpr(__, __) : WigiError("WigiDatafunInExpr could not be used besides WigiDatafunList");
	}
}

getRequiredRecordFields(rs : [WigiExpr]) -> [string] {
	fold(rs, [], \acc : [string], r : WigiExpr -> {
		switch (r : WigiExpr) {
			WigiVarRef(n): if (n == "*") acc else arrayPush(acc, n);
			default: acc;
		}
	})
}


evaluateRecordField(le : WigiValue, rs : [WigiExpr]) -> WigiValue {
	fold(rs, le, \acc : WigiValue, r : WigiExpr -> {
		switch (acc) {
			WigiRecord(fs): {
				switch (r : WigiExpr) {
					WigiVarRef(n): {
						if (n == "*") {
							map(fs, \f -> f.second) |> WigiArray
						} else {
							fold(fs, WigiError(n + " field not found"), \acc2, f -> {
								if (toUpperCase(f.first) == n) f.second else acc2
							})
						}
					}
					WigiCellRefA1(n): {
						fold(fs, WigiError(n + " field not found"), \acc2, f -> {
							if (toUpperCase(f.first) == n) f.second else acc2
						});
					}
					default: {
						println("Field index not supported yet 1: " + wigiExpr2string(r));
						WigiError("Can not index field");
					}
				}
			}
			default: {
				println("Field index not supported yet 2: " + wigiExpr2string(acc) + " " + wigiExpr2string(r));
				WigiError("Can not index field");
			}
		}
	})
}

evaluateArrayField(left : WigiValue, right : [WigiExpr]) -> WigiValue {
	valid = fold(right, true, \valid, r -> {
		if (valid) {
			switch(r) {
				WigiVarRef(__): true;
				WigiCellRefA1(__): true;
				default: false
			}
		} else false
	});

	if (!valid) WigiError("Can not index field")
	else {
		names = map(right, \r -> {
			switch(r) {
				WigiVarRef(name): name;
				WigiCellRefA1(name): name;
				default: "";
			}
		});
		evaluateArrayFieldRecursive(left, names)
	}
}

evaluateArrayFieldRecursive(left : WigiValue, right : [string]) -> WigiValue {
	if (length(right) == 0) left
	else {
		switch(left) {
			WigiArray(els): WigiArray(map(els, \e -> evaluateArrayFieldRecursive(e, right)));
			WigiRecord(pairs): {
				// Find the field, case insensitive
				switch(find(pairs, \p -> { toUpperCase(p.first) == right[0] })) {
					Some(pair): evaluateArrayFieldRecursive(pair.second, tail(right));
					None(): WigiDefaultValue()
				}
			}
			default: WigiDefaultValue();
		}
	}
}

// this function steps into passsed WigiValue and for all nested WigiRecords creates required fileds recursively using path
// path is an array of strings that reppresents stack of the arrays of the names of the fiels collected when wee was stepping down to the WigiExp
// returns Pair<new value, isChanged>
enforceWigiRecordField(v : WigiValue, path : [[string]]) -> Pair<WigiValue, bool> {
	switch (v : WigiValue) {
		WigiRecord(fields): {
			requiredFields = elementAt(path, 0, []);
			if (requiredFields == []) {
				Pair(v, false)
			} else {
				// the fields falls into 3 categories:
				// 1) fields that aren't mentioned in the list of current lelel (requiredFields)
				//    just leave them as they are
				// 2) fields that are in both lists - in the requiredFields and in the fields list
				//    we have to call ourselves reqursively for the tail of the path
				// 3) fields that are in the requiredFields list but aren't existing in the fields
				//    we adds them with WigiDefaultValue

				processedFields = map(fields, \field : Pair<string, WigiValue> -> {
					if (contains(requiredFields, toUpperCase(field.first))) {
						switch (field.second) {
							WigiRecord(__): {
								children = enforceWigiRecordField(field.second, tail(path)); // (2)
								if (children.second) {
									Pair(Pair(field.first, children.first), true); // modified
								} else {
									Pair(field, false);
								}
							}
							default: Pair(field, false);
						}
					} else {
						Pair(field, false); // (1)
					}
				});

				presentFieldNames = map(fields, \f -> toUpperCase(f.first));
				missedFields = fold(requiredFields, [], \acc, rf -> if (contains(presentFieldNames, toUpperCase(rf))) acc else arrayPush(acc, Pair(rf, WigiDefaultValue())));

				// if somthing has  changed, return new WigiRecord otherwise just return input
				// without intermediate var compiler commplains abouut types
				res : Pair<WigiValue, bool> =
					if (missedFields != [] || any(map(processedFields, secondOfPair))) {
						Pair(
							WigiRecord(
								concat(
									map(processedFields, firstOfPair), // (1) and (2)
									missedFields // (3)
								)
							),
							true // modified
						);
					} else {
						Pair(v, false);
					}

				res;
			}
		}
		default: Pair(v, false);
	}
}

// We want to create all required fileds in accessed WigiRecords
// to be able to do it, we have collected all required fileds when we stepped down to the WigiExpr
// now we are ready to investigate WigiRecord and check it and its nested components against required files on each level
evaluateWigiName(env : ref WigiEnvironment, namespace : WigiScope, x : string, isFuncName : bool, externalFunctions: Tree<string, ([WigiValue]) -> WigiValue>, path : [[string]]) -> WigiValue {
	if (x == "*") {
 		namespaceValueBs : [Pair<string, DynamicBehaviour<WigiValue>>] = collectValuesInNamespace(^env, WigiScope(tail(namespace.names)));
 		map(namespaceValueBs, \p -> Pair(p.first, getValue(p.second))) |> WigiRecord
 	} else {
 		// here we try to ensure that all required fields in the WigiRecord exists
 		processCell = \cell : Pair<WigiCellName, Behaviour<WigiValue>> -> {
 			if (length(path) == 0) {
	 			getValue(cell.second)
 			} else {
 				requiredFields = elementAt(path, 0, []);
 				if (requiredFields == []) {
 					getValue(cell.second)
 				} else {
 					currentValueB = cell.second;
 					currentValue = getValue(currentValueB);

					switch (currentValue : WigiValue) {
						WigiRecord(fields): {
							processedRecord = enforceWigiRecordField(currentValue, path);
							if (processedRecord.second) {
								newValue = processedRecord.first;
			 					switch (currentValueB : Behaviour<WigiValue>) {
			 						// in case we have DynamicBehaviour, we could just call nextDistinct to change its value
			 						DynamicBehaviour(__, __): nextDistinct(currentValueB, newValue);
			 						// if we have ConstBehaviour than we have to change whole WigiEnviironment to change content of WigiRecord
			 						ConstBehaviour(__): env := addWigiName(^env, cell.first, const(newValue));
			 					}
								newValue;
							} else {
								currentValue;
							}
						}
						default: currentValue;
					}
 				}
 			}
 		}

 		if (isFuncName) {
	 		if (containsKeyTree(getWigiBuiltIns(), x) || containsKeyTree(externalFunctions, x)) {
	 			WigiBuiltInName(x)
	 		} else {
	 			eitherFn(resolveWigiCell(^env, namespace, x), processCell, \ -> WigiError("'" + x + "' is not a variable nor known built-in"));
	 		}
 		} else {
 			eitherFn(resolveWigiCell(^env, namespace, x), processCell, \ -> WigiBuiltInName(x));
		}
	}
}


// A range evaluates to a 2d-array of values
evaluateRangeA1Expr(env : ref WigiEnvironment, namespace : WigiScope, left : WigiCellRefA1, right : WigiCellRefA1) -> WigiValue {
	l = simplifyWigiCellRef(left.x);
	r = simplifyWigiCellRef(right.x);

	WigiArray(map(getWigiRangeA1CellNames(l,r), \col -> {
		WigiArray(map(col, \cellName -> {
			switch (resolveWigiCell(^env, namespace, cellName)) {
				Some(v): getValue(v.second);
				None(): WigiError("Invalid cell value: " + cellName);
			}
		}))
	}))
}

doWigiMatch(env : ref WigiEnvironment, val : WigiValue, cases : [WigiMatchCase]) -> WigiValue {
	// TODO:
	val;
}


callEngineBuiltin(env : ref WigiEnvironment, name : string, args : [WigiValue]) -> WigiValue {
	builtin = lookupTree(getWigiBuiltIns(), name);
	switch(builtin) {
		None(): WigiError(name + " not known");
		Some(b): {
			if (b.args == -1 || length(args) == b.args) {
				b.fn(args);
			} else {
				WigiError("Wrong number of arguments to " + name + ". Expected " + i2s(b.args) + ", but got " + i2s(length(args)));
			}
		}
	}
}

callExternalFunction(externalFunctions: Tree<string, ([WigiValue]) -> WigiValue>, name : string, args : [WigiValue]) -> WigiValue {
	externalFn = lookupTree(externalFunctions, name);
	switch(externalFn) {
		None(): WigiError(name + " not known");
		Some(fn): fn(args);
	}
}



simplifyWigiCellRef(x: string) -> string {
	strReplace(x, "$", "")
}

calculateChoiceCondition(operator : ChoiceOperator, v1 : WigiValue, v2 : WigiValue) -> bool {
	correctValues = v1.structname != "WigiError" && v2.structname != "WigiError";
	switch (operator : ChoiceOperator) {
		WEquals(): correctValues && compareWigiValues(v1, v2) == 0;
		WNotEquals(): correctValues && compareWigiValues(v1, v2) != 0;
		WLessThan(): correctValues && compareWigiValues(v1, v2) < 0;
		WLessThanOrEqual(): correctValues && compareWigiValues(v1, v2) <= 0;
		WGreaterThan(): correctValues && compareWigiValues(v1, v2) > 0;
		WGreaterThanOrEqual(): correctValues && compareWigiValues(v1, v2) >= 0;
		WInside(): {
			correctValues &&
			switch (v2 : WigiValue) {
				WigiArray(values) : exists(values, \v -> compareWigiValues(v1, v) == 0);
				default: false;
			}
		}
		WOtherwise(): true;
		WCustomCondition(): v2.structname != "WigiError" && wigiValue2Bool(v2);
	}
}
