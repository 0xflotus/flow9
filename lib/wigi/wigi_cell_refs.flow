import wigi/wigi_expr;
import wigi/wigi_expr_parser;
import wigi/wigi_expr2string;

export {
	// Converts a formula with references to row/column format, used for copying
	// where we change all references to be relative to the given cell
	convertRefToRC(text: string, cellName : WigiCellRefA1) -> string;

	// Converts a formula with references to A1 format, used when pasting a formula
	// where we change all references to where we are pasting
	convertRefToA1(text: string, cellName: WigiCellRefA1) -> string;

	// Simple conversion that never fails
	convertCellRefRC2A1(e : WigiCellRefRC) -> WigiCellRefA1;

	// Conversion relative to a cell, which can fail
	convertCellRefRC2CellRefA1(e : WigiCellRefRC, relTo: WigiCellRefA1) -> Maybe<WigiCellRefA1>;
}

convertRefToRC(text: string, cellName: WigiCellRefA1) -> string {
	// check if this text can be parsed as formula
	if (startsWith(trim(text), "=") && cellName.x != "") {
		// In the lingo we have WigiVarRef() rule proirity over WigiCellRefA1() for certain reasons.
		// So in the spreadSheets for the correct copy/paste operation we need convert all
		// WigiVarRef() to the WigiCellRefA1() by call the "replaceVarRefToRefA1()"
		formula = replaceVarRefToRefA1(parseWigiExpr(text), cellName);
		switch(formula : WigiExpr) {
			WigiError(e): text;
			default: {
				"=" + (mapWigiExpr(formula, \expr : WigiExpr -> {
					switch(expr : WigiExpr) {
						WigiCellRefA1(x): convertCellRefA12CellRefRC(expr, cellName);
						WigiRangeA1(start, end): {
							_start = convertCellRefA12CellRefRC(start, cellName);
							_end = convertCellRefA12CellRefRC(end, cellName);
							WigiRangeRC(_start, _end);
						}
						default: expr;
					}
				}) |> wigiExpr2string)
			}
		}
	} else text;
}

// replacing WigiVarRef() to the WigiCellRefA1()
replaceVarRefToRefA1(formula : WigiExpr, cellName: WigiCellRefA1) -> WigiExpr {
	recursiveCall = \e -> replaceVarRefToRefA1(e, cellName);

	switch(formula) {
		WigiCall(func, args): WigiCall(func, map(args, recursiveCall));
		WigiIf(condition, then, else_): WigiIf(condition |> recursiveCall, then |> recursiveCall, else_ |> recursiveCall);
		WigiSequence(exprs): WigiSequence(map(exprs, recursiveCall));
		WigiMultiplicative(exprs): WigiMultiplicative(map(exprs, recursiveCall));
		WigiMult(op, e): WigiMult(op, e |> recursiveCall);
		WigiField(l, r): WigiField(l |> recursiveCall, map(r, recursiveCall));
		WigiMakeRecord(fs): WigiMakeRecord(map(fs, \p -> Pair(p.first, p.second |> recursiveCall)));

		WigiVarRef(x): if (isNameLikeRefA1(x)) WigiCellRefA1(x) else formula;

		default: formula;
	}
}

// Checking: does the variable name conforms to cell naming
isNameLikeRefA1(name : string) -> bool {
	arrChars = generate(0, strlen(name), \idx -> getCharAt(name, idx));
	isAllUpperLetters = \str -> forall(str, \s -> (s >= "A" && s <= "Z"));
	isAllDigits = \str -> forall(str, isDigit);

	switch(findi(arrChars, isDigit)) {
		Some(i): (i > 0) && (take(arrChars, i) |> isAllUpperLetters) && (tailFrom(arrChars, i) |> isAllDigits);
		None(): false;
	}
}

convertRefToA1(text: string, cellName: WigiCellRefA1) -> string {
	if (startsWith(trim(text), "=") && cellName.x != "") {
		// check if this text can be parsed as formula
		formula : WigiExpr = parseWigiExpr(text);
		switch(formula) {
			WigiError(e): text;
			default: {
				"=" + (mapWigiExpr(formula, \expr : WigiExpr -> {
					// have no idea why flowcpp compiler cannot resolve types here
					// so just a temp hack
					r0 : WigiExpr = switch(expr : WigiExpr) {
						WigiCellRefRC(r, c): {
							r1 : WigiExpr = switch(convertCellRefRC2CellRefA1(expr, cellName)) {
								None() : expr;
								Some(a1) : a1;
							}
							r1;
						}
						WigiRangeRC(start, end): {
							r2 : WigiExpr = eitherMap(convertCellRefRC2CellRefA1(start, cellName), \_start -> {
								eitherMap(convertCellRefRC2CellRefA1(end, cellName), \_end -> {
									WigiRangeA1(_start, _end)
								}, expr)
							}, expr);
							r2;
						}
						default: expr;
					}
					r0;
				}) |> wigiExpr2string)
			}
		}
	} else text;
}


CellRefInt(row: int, col: int, absRow: bool, absCol: bool);

convertCellRefA12CellRefRC(e: WigiCellRefA1, relTo: WigiCellRefA1) -> WigiCellRefRC {
	base = resolveCellName(relTo);
	cell = resolveCellName(e);
	row = if (cell.absRow) AbsRef(cell.row) else RelRef(cell.row - base.row);
	col = if (cell.absCol) AbsRef(cell.col) else RelRef(cell.col - base.col);
	WigiCellRefRC(row, col)
}

convertCellRefInt2CellRefA1(e : CellRefInt) -> Maybe<WigiCellRefA1> {
	baseCode = s2a("A")[0]-1;
	recConversion = ref \n -> "";
	recConversion := \n -> if (n <= 26) fromCharCode(baseCode + n) else ^recConversion(n / 26) + ^recConversion(n % 26);
	if ((e.row > 0) && (e.col > 0)) Some(WigiCellRefA1((if (e.absCol) "$" else "") + ^recConversion(e.col) + (if (e.absRow) "$" else "") + i2s(e.row))) else None()
}

convertCellRefRC2A1(e : WigiCellRefRC) -> WigiCellRefA1 {
	getRC = \cr: CellRef -> {
		switch(cr) {
			AbsRef(x): Pair(x, true);
			RelRef(dx): Pair(dx, false)
		}
	}
	row = getRC(e.r);
	col = getRC(e.c);
	i = CellRefInt(row.first, col.first, row.second, col.second);
	either(convertCellRefInt2CellRefA1(i), WigiCellRefA1("A1")); // Never fails
}

convertCellRefRC2CellRefA1(e : WigiCellRefRC, relTo: WigiCellRefA1) -> Maybe<WigiCellRefA1> {
	getRC = \cr: CellRef, i: int -> {
		switch(cr) {
			AbsRef(x): Pair(x, true);
			RelRef(dx): Pair(i + dx, false)
		}
	}
	base = resolveCellName(relTo);
	row = getRC(e.r, base.row);
	col = getRC(e.c, base.col);
	i = CellRefInt(row.first, col.first, row.second, col.second);
	convertCellRefInt2CellRefA1(i)
}


// Converts cell's name from A1 notation to CellRefInt
// Example: $A2 => CellRefInt(2, 1, false, true)
resolveCellName(namea1 : WigiCellRefA1)-> CellRefInt {
	name = namea1.x;
	baseCode = s2a("A")[0]-1;
	recConversion = ref \str -> 0;
	recConversion := \str -> if (strlen(str) == 1) getCharCodeAt(str, 0) - baseCode else (getCharCodeAt(str, 0) - baseCode) + 26 * ^recConversion(strRight(str, 1));
	// trying to find first digit
	sa = generate(0, strlen(name), \idx -> getCharAt(name, idx));
	switch(findi(sa, isDigit)) {
		Some(i): {
			n = if (sa[i-1] == "$") i-1 else i;
			letterPart = strLeft(name, n);
			absCol = startsWith(letterPart, "$");
			col = if (absCol) strRight(letterPart, 1) else letterPart;

			digitPart = strRight(name, n);
			absRow = startsWith(digitPart, "$");
			row = if (absRow) strRight(digitPart, 1) else digitPart;
			CellRefInt(s2i(row), ^recConversion(reverse(col)), absRow, absCol);
		}
		None(): {
			// Never going to happen because grammar ensures that we indeed have digits
			CellRefInt(0, 0, false, false);
		}
	}
}
