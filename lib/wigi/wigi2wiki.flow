import arrayutils; // subtractA, intersection
import wigi/types;
import wigi/styles;
import wigi/storage;
import formats/wiki/wikimath;

export {
	// Convert this Wigi to wiki format as well as possible
	wigi2wiki(w : WigiElement, defaultWigiStyles : Maybe<[WigiStyles]>) -> string; // Example of result: A**B**C
}

WikiPart ::=  WikiParagraph, WikiStyledText, WikiNonStyledText, WikiSpan2, WikiRecursive;
	WikiStyledText(text : string, style : [WigiTextStyle]);
	WikiParagraph(elements: [WikiPart], style: [WigiParagraphStyle]);
	WikiNonStyledText(type : WikiNonStyledTextType);
		WikiNonStyledTextType ::= WikiPicture, WikiSmartArt2, WikiPageBreak, WikiPageName, WikiCoach, WikiEmptyLine, WikiCalc, WikiAlterText, WikiNaturalMath;
			WikiPicture(url : string);
			WikiSmartArt2(content : string);
			WikiPageBreak(append: bool, autoScroll: bool);
			WikiPageName(name : string, disableCondition: string);
			WikiCoach(text : string);
			WikiEmptyLine();
			WikiAlterText(elements: [WikiPart]);
			WikiNaturalMath(formula : string);
	WikiSpan2(style : [WigiTextStyle], texts : [WikiStyledText]);
	WikiRecursive(type: WikiRecursiveType, elements : [[WikiPart]]);
		WikiRecursiveType ::= WikiTable2; 
			WikiTable2(rows : int, cols : int);

WigiWikiDefaultTextStyle : [WigiTextStyle] = [FontSize(16.0), Fill(darkGray)];

wigi2wiki(wigi : WigiElement, defaultWigiStyles : Maybe<[WigiStyles]>) -> string {
	textStyle = concatWigiTextStyles(WigiWikiDefaultTextStyle,
		eitherMap(defaultWigiStyles, \ws -> getDefaultDocumentStyle(ws).textStyle, []));

	preparedWigi = makeWigiShortStyled(wigi, defaultWigiStyles);

	wikiParts = getWikiParts(preparedWigi, [], textStyle) 
		|> addWikiPrefixes 
		|> processStyledEmptyLines;
 	makeWikiText(wikiParts);
}

makeWikiText(parts : [WikiPart]) -> string {
	strGlue(
		map(parts, \p -> switch(p){
			WikiParagraph(elements, ps):{
				isCentered = isSameStructType(getWigiParagraphAlignment(ps), CenterAlign());
				paraStr = makeWikiParagraph(elements);
				if (isCentered) "\\center " + paraStr 
				else paraStr;
			}
			default: makeWikiPartString(p);
		}),
		"\n"
	);
}

makeWikiParagraph(parts : [WikiPart]) -> string {
	paraParts = getSpans(parts);
	fold(paraParts, "", \acc, p -> acc + makeWikiPartString(p));
}

// we try to add styled empty lines to the following paragraph 
//because we can not represent such a line with a separate <span> constructuion
processStyledEmptyLines(parts : [WikiPart]) -> [WikiPart]{
	accEmpties = ref [];

	getEmptyLine = \p -> switch(p){
		WikiParagraph(els, ps):{
			if (length(els) == 1){
				switch(els[0]) {
					WikiStyledText(text, style): if (strIndexOf(text, "newline") != -1) Some(els[0]) else None();
					default: None()
				}
			} else None();
		}
		default: None()
	} 

	isStyledText = \p -> isSameStructType(p, WikiStyledText("", []));
	
	getLastParagraphStyle = \pa ->{
		fold(pa, [], \acc, p -> switch(p){
			WikiParagraph(__, ps): ps;
			default: acc;
		});
	}
	
	newParts = fold(parts, [], \acc, p -> {
		switch(getEmptyLine(p)){
			Some(line):{
				refArrayPush(accEmpties, line);
				acc;
			}
			None():{
				switch(p){
					WikiParagraph(els, ps):{
						if (^accEmpties != []){
							newParts = if (els > [] && isStyledText(els[0])) {
								[WikiParagraph(concat(^accEmpties, els), ps)]
							} else {
								[WikiParagraph(^accEmpties, ps), p];
							}
							accEmpties := [];
							concat(acc, newParts);
						} else {
							arrayPush(acc, p);
						}
					}	
					default: acc				
				}
			}
		}
	});
	if (^accEmpties != []){
		arrayPush(newParts, WikiParagraph(^accEmpties, getLastParagraphStyle(newParts)));
	} else newParts
}

getFillBasicColorName(st : WigiTextStyle)  -> string {
	switch(st) {
		Fill(color): {
			supported = find(supportedTeXLikeElements(), \me -> switch (me.type : TeXLikeExpression) {
				PredefinedColor(color2) : color == color2;
				default: false;
			});
			switch(supported){
				Some(me): me.representation;
				None(): ""
			}
		}
		default: "";
	}
} 

getSpans(parts : [WikiPart]) -> [WikiPart] {
	dummySpan = WikiSpan2([], []); 
	newParts = ref [];

	makeSpan = \t : WikiStyledText -> WikiSpan2(t.style, [t]);
	flushSpan = \span -> {
		if (span != dummySpan){
			refArrayPush(newParts, normalizeSpan(span));
		}
		dummySpan;
	}

	addToSpan = \span : WikiSpan2, text ->{
		if (span == dummySpan) 	{
			makeSpan(text)
		} else {
			commonStyle = intersection(span.style, text.style);
			if (commonStyle == []) {
				flushSpan(span);
				makeSpan(text);
			} else {
				st2 = subtractA(text.style, commonStyle);
				if (st2 == [] || length(st2) == 1 && getFillBasicColorName(st2[0]) != "") {
					WikiSpan2(commonStyle, arrayPush(span.texts, text))
				} else {
					flushSpan(span);
					makeSpan(text);
				}
			}
		}
	}

	addWikiPart = \acc, part -> {
		nacc = flushSpan(acc); 
		refArrayPush(newParts, part);
		nacc
	}

	last = fold(parts, dummySpan, \acc, p ->{
		switch(p){
			WikiStyledText(t, s):	{
				if (s == []) {
					addWikiPart(acc, p);
				} else {
					shift = extractStruct(s, BaselineShift(0.0)).shift;
					p1 = if (shift == -0.5) WikiStyledText("^" + t + "^", s) else if (shift == 0.5) WikiStyledText("_" + t + "_", s) else p;
					addToSpan(acc, p1);
				}
			}
			default: {
				addWikiPart(acc, p);
			}
		}
	});
	flushSpan(last);
	^newParts;
}

normalizeSpan(span : WikiSpan2) -> WikiSpan2 {
	WikiSpan2(
		span.style, 
		map(span.texts, \t -> WikiStyledText(t.text, subtractA(t.style, span.style)))
	)
}

getSpanHeadString(style : [WigiTextStyle])-> string {
	spans = fold(style, [], \acc, st -> switch(st) {
			FontSize(size): {
				if (contains(WigiWikiDefaultTextStyle, st)) acc		// ignore default wigi font-size
				else {
					arrayPush(acc, "font-size:" + i2s(round(size)) + "px");
				}
			}
			Fill(color): {
				if (contains(WigiWikiDefaultTextStyle, st)) acc		// ignore default wigi font-color
				else {
					arrayPush(acc, "color:#" + formatColor(color));
				}
			}
			BackgroundFill(color): {
				if (contains(WigiWikiDefaultTextStyle, st)) acc		// ignore default wigi background
				else {
					arrayPush(acc, "background:#" + formatColor(color));
				}
			}
			default : acc;
		}
	);

	if (spans != []) {
		"<span style=\"" + strGlue(spans, "; ") + "\">";
	} else ""
 }

getTableRows(cols : int, cells : [string], row : string, rows : [string], count : int) -> [string] {
	if (cells == []){
		if (row != "") arrayPush(rows, row) else rows;
	} else {
		if (mod(count + 1, cols) == 0)
			getTableRows(cols, tail(cells), "", arrayPush(rows, row + cells[0]), count + 1)
		else
			getTableRows(cols, tail(cells), row + cells[0], rows, count + 1);
	}
}

makeWikiPartString(part : WikiPart) -> string {
	switch (part) {
		WikiSpan2(style, texts): {
			text = concatStrings(map(texts, \text -> makeWikiPartString(text)));
			header = getSpanHeadString(style);
			if (header != ""){
				spanText = if (text == "") "\\newline" else text;
				getSpanHeadString(style) + spanText + "</span>"
			} else {
				text
			}
		}
		WikiStyledText(t, style):{
			specials = ["[", "]"];
			replaces = fold(specials, [], \acc, ch -> concat(acc, [ch, "\\" + ch]));
			text = strReplaces(t, replaces);
		 	if (length(style) == 1) {
		 		cn = getFillBasicColorName(style[0]);
		 		if (cn != "") cn + "{" + text + "}" else text;
		 	} else {
		 		text
		 	}
		}
		WikiNonStyledText(type):{
			switch (type){
				WikiPicture(url): "[" + url + "]";
				WikiSmartArt2(content): "<smartart>" + content + "</smartart>";
				WikiPageBreak(append, autoScroll): {
					suffix = (if (append) "+" else "") + (if (autoScroll) "n" else "");
					"---" + if (suffix != "") suffix else "-";
				}
				WikiPageName(name, disableCondition) : {
					disableCondition2string = \s -> {
						if (startsWith(s, "{") && endsWith(s, "}")) {
							"#" + substring(s, 1, strlen(s) - 2)
						} else ""
					}
					"PageName: " + name + disableCondition2string(disableCondition);
				}
				WikiCoach(text): "Coach: " + text;
				WikiEmptyLine():"";
				WikiCalc():"\\calc";
				WikiAlterText(elements): "\\alttext{" + makeWikiText(elements) + "}";
				WikiNaturalMath(formula): "`" + formula + "`";
			}
		}
		WikiRecursive(type, elements):{
			texts = map(elements, makeWikiText);
			switch(type){
				WikiTable2(rows, cols):{
					cells = map(texts, \t -> "|" + t);
					tableRows = if (rows * cols == length(cells)) {
						getTableRows(cols, cells, "", [], 0);
					} else {
						cells // if something is wrong with the content of the table, let's make one column table
					}
					strGlue(tableRows, "\n");
				}
			}
		}
		default: "";
	}
}

addWikiPrefixes(parts : [WikiPart]) -> [WikiPart] {
	// the sequence of elements is important: first we add prefix for FontFamily, then for Underline
	style4Prefix = [FontFamily(""), Underline()];
	map(parts, \part -> switch (part) {
		WikiStyledText(text, ts): addWikiPrefix(part, style4Prefix);
		WikiParagraph(paraParts, ps): WikiParagraph(addWikiPrefixes(paraParts), ps); 
		WikiRecursive(type, elements): WikiRecursive(type, map(elements, addWikiPrefixes));
		default: part;
	});
}

addWikiPrefix(text: WikiStyledText, style4prefix : [WigiTextStyle]) -> WikiStyledText {
	fold(style4prefix, text, \acc : WikiStyledText, st -> {
		trimmed = ltrim(acc.text);
		if (acc.text != "") {
			switch(st){
				FontFamily(__):{
					ff = extractStruct(acc.style, st);
					newText = if (ff.name == "Italic" && trimmed != "")
						strRepeat(" ", strIndexOf(acc.text, trimmed)) + "*" + trimmed + "*"  // "Italic" in GUI
					else if (ff.name == "Medium" && trimmed != "")
						strRepeat(" ", strIndexOf(acc.text, trimmed)) + "**" + trimmed + "**"  // "Bold" in GUI
					else if (ff.name == "MediumItalic" && trimmed != "")
						strRepeat(" ", strIndexOf(acc.text, trimmed)) + "***" + trimmed + "***" // "Bold Italic" in GUI
					else
						acc.text;
					WikiStyledText(newText, filter(acc.style, \s -> !isSameStructType(s, st)));
				}
				Underline():{
					newStyle = filter(acc.style, \s -> !isSameStructType(s, st));
					newText = if (newStyle != acc.style && trimmed != "")
						strRepeat(" ", strIndexOf(acc.text, trimmed)) + "+" + trimmed + "+"
					else acc.text;
					WikiStyledText(newText, newStyle);
				}
				default: acc;
			}
		} else {
			acc
		}
	})
}

getWikiParts(wigi : WigiElement, acc : [WikiPart], defStyle : [WigiTextStyle]) -> [WikiPart] {
	addText = \acc2, text : WikiStyledText ->{
		style = subtractA(text.style, defStyle);
		switch (lastElement(acc2, WikiNonStyledText(WikiPageBreak(false, false)))){
			WikiStyledText(t, s):{
				if (s == style) replace(acc2, length(acc2) - 1, WikiStyledText(t + text.text, s))
				else arrayPush(acc2, WikiStyledText(text.text, style));
			}
			default: arrayPush(acc2, WikiStyledText(text.text, style));
		}
	}

	getTextStyle = \e : WigiElement -> {
		switch(e) {
			WigiText(text, style): style;
			default: [];
		}
	}

	switch (wigi) {
		WigiDocument(root, style): {
			getWikiParts(root, acc, defStyle);
		}
		WigiStory(elements, views, style): {
			fold(^elements, acc, \acc2, e -> getWikiParts(e, acc2, defStyle));
		}
		WigiParagraph(elements, style): {
			if (isWigiEmptyLine(wigi) && length(elements) == 1) {
				ts = getTextStyle(elements[0]);
				if (ts == []) {
					arrayPush(acc, WikiParagraph([WikiNonStyledText(WikiEmptyLine())], style));
				} else {
					arrayPush(acc, WikiParagraph([WikiStyledText("\\newline", ts)], style));
				}
			} else {
				par = fold(elements, [], \acc2, e -> getWikiParts(e, acc2, defStyle));
				arrayPush(acc, WikiParagraph(par, style));
			}
		}
		WigiText(text, style): {
			// ignore empty texts
			if (text != "") {
				wikiSymbolsTree = getWikiSymbolsTree();
				text1 = stringFold(text, "", \acc2, code -> acc2 + lookupTreeDef(wikiSymbolsTree, code, fromCharCode(code)));
				addText(acc, WikiStyledText(text1, style))
			} else acc;
		}
		WigiRecursive(elements, type, style): { // TODO
			// wiki parts for each element
			recursiveElements = map(elements, \e -> getWikiParts(e, [], defStyle));
			// joint parts of all the elements
			recursiveParts = concatA(recursiveElements);
			switch(type) {
				WigiAltText(): {
					arrayPush(acc, WikiNonStyledText(WikiAlterText(recursiveParts)));
				}
				WigiTable(rows, cols, cellSpans, tStyle): {
					arrayPush(acc, WikiRecursive(WikiTable2(rows, cols), recursiveElements));
				}
				WigiTableCell(widthHeight, cStyle): {
					concat(acc, recursiveParts);
				}
				default: {
					concat(acc, recursiveParts);
				}
			}
		}
		WigiEmpty(): acc;
		WigiBlock(blocktype, blockstyle): {
			textstyle = extractWigiTextStyleFromBlockStyle(blockstyle);
			switch(blocktype) {
				WigiPicture(url, style): arrayPush(acc, WikiNonStyledText(WikiPicture(url)));
				WigiSmartArt(content, style): arrayPush(acc, WikiNonStyledText(WikiSmartArt2(content)));
				WigiPageBreak(a, s): arrayPush(acc, WikiParagraph([WikiNonStyledText(WikiPageBreak(a, s))], []));
				WigiPageName(name, disableCondition): arrayPush(acc, WikiNonStyledText(WikiPageName(name, disableCondition)));
				WigiCoach(text): arrayPush(acc, WikiNonStyledText(WikiCoach(text)));
				WigiNaturalMath(formula): arrayPush(acc, WikiNonStyledText(WikiNaturalMath(formula)));
				WigiVideo(url, style): acc;
				WigiAudio(url, style): acc;
				WigiFormula(formula, style): acc;
				WigiComboBox(s, v, r, w): acc;
				WigiInputBox(v, w, h, s): acc;
				WigiSlider(__,__,__,__,__,__): acc;
				WigiCheckBox(value, style): acc;
				WigiPositionTag(id): acc;
				WigiCustomSymbol(type, size): acc;
				WigiFormdesigner(drawing, style): acc;
				WigiNativeWiki(wiki): acc;
				WigiDotplot(v, s): acc;
				WigiHistogram(v, s): acc;
				WigiHistogramClasses(v, s): acc;
				WigiBoxplot(v, s): acc;
				WigiScatterplot(v, s): acc;
				WigiStackedBar(v, s): acc;
				WigiDatepicker(__, __): acc;
				WigiCalculator(): arrayPush(acc, WikiNonStyledText(WikiCalc()));
				WigiHTML(__, __, __, __): acc;
				WigiReferenceDocument(__, __): acc;
				WigiSetClipboardButton(__, __): acc;
				WigiChoiceBlock(__, __): acc;
				WigiRadioButton(__, __): acc;
				WigiExternalBlock(__, __): acc;
				WigiFeedback(__, __): acc;
				WigiFeedbackBlock(__, __, __, __): acc;
				WigiFillBlankBlock(__, __, __, __, __, __): acc;
			}
		}
	}
}

makeWigiShortStyled(wigi : WigiElement, defaultWigiStyles : Maybe<[WigiStyles]>) -> WigiElement{
	eitherMap(defaultWigiStyles, 
		\ws -> wigiForStorageShortStyles(wigi, false, ws),
		wigi
	);
}
