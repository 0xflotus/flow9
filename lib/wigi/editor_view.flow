import wigi/element_view;
import wigi/drop_api;
import wigi/editor_pinyin;

export {
	makeWigiView(state : WigiEditorState) -> Form;

	// Construct a view and controller for this document to allow editing there of. Only the document itself is made, no toolbar
	makeWigiView2(state : WigiEditorState, preview : bool) -> Form;
}

makeWigiView(state : WigiEditorState) -> Form {
	makeWigiView2(state, false)
}

makeWigiView2(state : WigiEditorState, preview : bool) -> Form {
	focusId = getFocusId();

	state.focusId := focusId;
	defaultStyles = getDefaultDocumentStyle(state.defaultStyles);

	viewSizeWB = make(0.0);
	viewSizeHB = make(0.0);

	isScrollable = !contains(state.wigiEditorStyle, WigiEditorNoScroll());
	fileDropEnabled = contains(state.wigiEditorStyle, WigiEditorEnableFileDrop());
	isEngineShared = contains(state.wigiEditorStyle, WigiEngineIsShared());

	stateDoc = make(getValue(state.document));
	viewWH = makeWH();

	Constructor(
		Interactive(
			ifArrayPush([
				KeyDown2(makeKeyDownHandler(state, focusId)),
				KeyUp2(\handled, ke -> {
					curKbdFocusId = currentKeyboardFocusId();
					inFocus = curKbdFocusId == focusId;
					if (!handled && inFocus) {
						if (isShiftAlone(ke) && getValue(state.shiftHeld)) {
							nextDistinct(state.shiftHeld, false);
							true
						} else if (isCtrlIn(ke) && handleKeyUpEvents) { // for IE we need to handle KeyUp events
							handleSpecialCtrlEvent(state, ke);
							true;
						} else {
							false;
						}
					} else {
						handled
					}
				}),
				MouseDown(\m -> {
					if (m.inside()) {
						// let's try to set cursor to some paragraph below if we click between pararaphs
						wigiView = getValue(state.editorView);
						realCoord = Point(
							m.x + if (isScrollable) getValue(state.viewX) else 0.0,
							m.y + if (isScrollable) getValue(state.viewY) else 0.0
						);
						// in case we click outside paragraph and start moving mouse we still have to start making selection
						nextDistinct(state.mouseSelecting, true);
						handledByParagraph = wigiView.setCursor(realCoord, getValue(state.shiftHeld), true);
						if (!handledByParagraph) {
							// if nobody handled this click we just set cursor to the end of document
							endPosition = getEndPositionOfDocument(getValue(state.document), false);
							wigiSetCursor(state, endPosition, getValue(state.shiftHeld));
						}
						// Grab keyboard focus
						updateKeyboardFocus(focusId);
					}
					false
				}),
				MouseUp(\__ -> {
					nextDistinct(state.mouseSelecting, false);
					false;
				})
				],
				fileDropEnabled,
				FileDrop(10, "", \files : [native] -> {
					iter(files, \file -> {
						filename = fileNameClient(file);
						readFileClient(file, "uri", \content -> {
							ext = filename |> getUrlExtension;
							dropFn = getWigiDropFn(ext);
							dropFn(WigiDropParameters(state, filename, content));
						}, println)
					})
				})
			),
			// This is the editor view
			Inspect([IAvailable2(state.viewSize)],
				Inspect([ISize(viewWH)], Select2(stateDoc, state.zoom, \d, __ -> {
					applyall(^(state.disposeDocument));

					if (!isEngineShared) {
						// we need to save env cells to work in the editor
						if (preview) state.engine.env := makeWigiEnvironment();
						state.engine.dependencies := makeTree();
					}

					// TODO: Allow the caller to specify what "root" namespace we should use here
					state.disposeDocument := registerToWigiEngineStub(d, state.engine, globalWigiNamespace, ref makeTree());

					view : WigiView = makeWigiElementView(state,
						ParentView(\ -> [], idfn, idfn, \__, __, __ -> false, \ -> defaultStyles, ref getDummyTransformMatrix),
						// TODO: Allow the caller to specify what "root" namespace we should use here
						globalWigiNamespace, d, preview, false
					);

					next(state.editorView, view);

					cursor = make([]);
					cursorHeight = make(0.0);

					cursorForm0 = Select2(cursor, cursorHeight, \c : [int], __ -> {
						if (isCellCursor(state)) { // Rectangular selection required
							el = getElementAtPosition(getValue(state.document), c);
							if (isWigiRecursive(el, [dummyWigiSpreadsheetCell])) {
								spreadsheetCell = cast(cast(el : WigiElement -> WigiRecursive).type : WigiRecursiveType -> WigiSpreadsheetCell);
								cellStyle = spreadsheetCell.cellStyle;
								padding = extractStruct(cellStyle, DefaultCellPadding);
								border = extractStruct(cellStyle, DefaultCellBorder);

								cv = view.getWigiView(c, view);
								p = cv.getGlobalCoordinate([0]);

								Select(spreadsheetCell.widthHeight, \s -> Offset(
									p.x - if (getDefaultRtl()) padding.endPadding + border.endBorder / 2.0 else padding.startPadding + border.startBorder / 2.0,
									p.y - padding.topPadding + border.topBorder / 2.0,
									Rectangle(
										max(20.0, s.width + padding.startPadding + padding.endPadding) - (if (getDefaultRtl()) border.startBorder else border.endBorder) / 2.0,
										s.height - border.bottomBorder / 2.0,
										[Stroke(newGreenColor), StrokeWidth(3.0)]
									)
								))
							} else {
								// p = view.getGlobalCoordinate(c);
								// Find the size of this child
								cv = view.getWigiView(c, view);
								p = cv.getGlobalCoordinate([]);
								s = cv.getSize();
								Offset(p.x, p.y, Rectangle(s.width, s.height, [Stroke(newGreenColor), StrokeWidth(3.0)]))
							}
						} else {
							// Draw normal cursor
							cursorBlink = make(1);
							cursorBlinkPeriod = 0.4; // in seconds

							Constructor(
								Select(state.cursorCoord, \coord -> {
									unpair(adjustCursorToBaselineShift(state), \hc, dy -> {
										Offset(coord.x, coord.y + dy, FixSize(0.0, 0.0,
											Visible(cursorBlink, Rectangle(2.0, hc, [Fill(black)]))
										))
									})
								}),
								\ -> {
									df = makeDrawFrameEventListener();
									df.attach();
									timerValue = ref 0.0;

									uns = subscribe2(df.timer, \t -> {
										timerValue := ^timerValue + t;

										if (^timerValue >= cursorBlinkPeriod) {
											next(cursorBlink, 1 - getValue(cursorBlink));
											timerValue := 0.0;
										}
									});

									\ -> {
										df.detach();
										uns();
									}
								}
							)
						}
					});
					cursorForm1 = FixSize(0.0, 0.0, Visibleb(state.hasKeyboardFocus, cursorForm0));

					cursorForm = Constructor(cursorForm1, \ -> {
						cursorFormUns = [
							connectDistinctTransistoru(state.shouldUpdateUI, state.cursor, cursor),
							connectDistinctTransistoru(state.shouldUpdateUI, state.cursorHeight, cursorHeight)
						];
						\ -> applyall(cursorFormUns);
					});

					// To ensure that the cursor is visible, we add a 1 pixel border
					Border(1.0, 0.0, 1.0, 0.0,
						Group([
							view.form(),
							cursorForm
						])
					)
				}))
				|> (\editorContent -> Group([
					Select2(viewWH, state.viewSize, \wh, wh2 -> Rectangle(
						max(wh.width, wh2.width),
						max(wh.height, wh2.height),
						[Fill(red), FillOpacity(0.0)]
					)),
					editorContent
				]))
				|> (\editorContent ->
					if (isScrollable)
						doStyledScrollableCustom(
							state.viewX,
							state.viewY,
							viewSizeWB,
							viewSizeHB,
							editorContent,
							standartScrollableStyleWithoutGap, true, true, false,
							commonShowFn, commonSizeFn, commonSizeFn, true,
							false
						)
					else
						editorContent
				)
			)
		)
		|> (\f -> if (!cpp) keyEventHandleWrapper(f, state.hasKeyboardFocus, ^(state.focusId), state.zorder) else f)
		|> (\f -> if (isPinyinRequired()) addPinyin(f, focusId, state) else f)
		,
		// The constructor function of the view
		\ -> {
			if ((!hasKeyboardFocus() || getValue(state.hasKeyboardFocus)) && state.grabFocus) {
				// Let's just grab the focus if noone else has it
				updateKeyboardFocus(focusId);
			}
			// Report whether we are in focus to the state
			uns2 = subscribe(getKeyboardFocusBehaviour(), \curFocus -> {
				nextDistinct(state.hasKeyboardFocus, curFocus == focusId);
			});

			// clear selection when lock editing disabled
			uns3 = subscribe(state.lock.preview, \p -> if (p) setWigiEditorSelection(state, wigiClearSelection(getValue(state.document)), false));

			uns4 = subscribe(state.viewSize, \wh -> {
				next(state.cursorWantThisX, -1.0);

				nextDistinct(viewSizeWB, wh.width);
				nextDistinct(viewSizeHB, wh.height);
			});

			// we want to disable updates for long change operations
			// we don't want use fusion here
			stateDocConnectUns = connectDistinctTransistoru(state.shouldUpdateUI, state.document, stateDoc);
			pasteListenerUns = addPasteEventListener(\files -> {

				pasteTextData = \ -> ignore(wigiSendEvent(state, WigiPaste()));
				tryToPasteFilesFirst = \ -> if (files == []) {
					pasteTextData()
				} else {
					filesPasteHandler = extractStruct(
						state.wigiEditorStyle,
						WigiEditorFilePastingHandler(\__, __, fulfill -> {pasteTextData(); fulfill();})
					).fn;
					executeWigiEditorAsyncChange(state, \fulfill -> {
						filesPasteHandler(state, files, fulfill)
					});
				};
				if (getValue(state.hasKeyboardFocus)) tryToPasteFilesFirst()
			});

			\ -> {
				uns2();
				uns3();
				keyboardFocusDies(focusId);
				uns4();
				stateDocConnectUns();
				pasteListenerUns();
			}
		}
	)
}


// as for IE9 on Windows it grabs almost all Ctrl+letter KeyDown events.
// This handler should be used  in either KeyDown or KeyUp listener, depending on the browser
// On MacOS use Cmd instead of Ctrl
handleSpecialCtrlEvent(state : WigiEditorState, ke : KeyEvent) -> void {
	// KeyEvent("[", false, false, false, false, 91, nop) on Cmd press
	if (isCtrlIn(ke) && !isCtrlAlone(ke)) {
		customKeyHandler = extractStruct(state.wigiEditorStyle, CustomKeyHandler(\__, __ -> false)).handler;
		if (customKeyHandler(ke, state)) {
		} else if (ke.utf == "a" || ke.utf == "A" || ke.keycode == KEY_A) {
			wigiSendEvent(state, WigiSelectAll());
			{}
		} else if (ke.utf == "b"  || ke.utf == "B" || ke.keycode == KEY_B) {
			// Ctrl+B - toggles bold
			if (isEmptySelection(getValue(state.selection))) {
				switchEditorFontFamily(state, SBold())
			} else {
				wigiSendEvent(state, WigiSwitchFontFamily(SBold(), true));
				{}
			}
		} else if (ke.utf == "i"  || ke.utf == "I" || ke.keycode == KEY_I) {
			// Ctrl+I - toggles italic
			if (isEmptySelection(getValue(state.selection))) {
				switchEditorFontFamily(state, SItalic())
			} else {
				wigiSendEvent(state, WigiSwitchFontFamily(SItalic(), true));
				{}
			}
		} else if (ke.utf == "u"  || ke.utf == "U" || ke.keycode == KEY_U) {
			// Ctrl+U - toggles underline
			wigiSendEvent(state, WigiSetUnderline(true));
			{}
		} else if (ke.utf == "c"  || ke.utf == "C" || ke.keycode == KEY_C || ke.keycode == KEY_SPACE) {
			// Ctrl+C - copy
			wigiSendEvent(state, WigiCopy(ke.keycode != KEY_SPACE && !ke.shift));
			ke.preventDefault();
		} else if (ke.utf == "d"  || ke.utf == "D" || ke.keycode == KEY_D) {
			// Ctrl+D - copying with replacing formulas by their values
			wigiSendEvent(state, WigiCopySpecial(!ke.shift));
			{}
		} else if (ke.utf == "x" || ke.utf == "X" || ke.keycode == KEY_X) {
			// Ctrl+X - cut
			wigiSendEvent(state, WigiCut());
			{}
		} else if (ke.utf == "v" || ke.utf == "V" || ke.keycode == KEY_V) {
			// Ctrl+V - paste
			if (isShiftIn(ke)) {
				showTextEditor("Paste as plain text", "", [], \text -> {
					wigiSendEvent(state, WigiInsertText(text));
					{}
				});
				ke.preventDefault();
			}
		} else if (ke.utf == "z" || ke.utf == "Z" || ke.keycode == KEY_Z) {
			// Ctrl+Z - undo
			wigiSendEvent(state, WigiUndo());
			{}
		} else if (ke.utf == "y" || ke.utf == "Y" || ke.keycode == KEY_Y) {
			// Ctrl+Y - redo
			wigiSendEvent(state, WigiRedo());
			{}
		} else if (ke.utf == "m" || ke.utf == "M" || ke.keycode == KEY_M) {
			if (ke.shift) {
				// Change showStructures.naturalMath
				next(state.showStructures.naturalMath, !getValue(state.showStructures.naturalMath))
			} else {
				// Insert Natural math
				wigiSendEvent(state, WigiInsertNaturalMath());
				{}
			}
		} else if (ke.utf == "'" || ke.utf == "|" || ke.keycode == 220) {
			// KeyEvent("", true, false, false, false, 220, nop) - flash, latin keyboard, Ctrl-\
			// KeyEvent("|", true, false, false, false, 92, nop) - C++, latin keyboard, Ctrl-\
			// KeyEvent("'", true, false, false, false, 222, nop) - flash, latin keyboard, Ctrl-'
			// KeyEvent("'", true, false, false, false, 0, nop) - C++, latin keyboard, Ctrl-'
			// Insert Native wiki
			CallWikiEditor("", WidthHeight(500.0, 200.0), None(), \result -> {
				wigiSendEvent(state, WigiInsertNativeWiki(result));
				{}
			}, \->{});

		} else if (ke.utf == "left" || ke.keycode == KEY_LEFT) {
			if (macosx()) {
				// Ctrl+Left = Home on Mac
				next(state.cursorWantThisX, -1.0);
				wigiSendEvent(state, WigiHome(ke.shift));
			} else {
				wigiSendEvent(state, WigiLeftWord(ke.shift));
			}
			{}
		} else if (ke.utf == "right" || ke.keycode == KEY_RIGHT) {
			if (macosx()) {
				// Ctrl+Right = End on Mac
				next(state.cursorWantThisX, -1.0);
				wigiSendEvent(state, WigiEnd(ke.shift));
			} else {
				wigiSendEvent(state, WigiRightWord(ke.shift));
			}
			{}
		} else if ((ke.utf == "up" || ke.keycode == KEY_UP)) {
			wigiSendEvent(state, WigiSwapParagraph(true));
			ke.preventDefault();
		} else if ((ke.utf == "down" || ke.keycode == KEY_DOWN)) {
			wigiSendEvent(state, WigiSwapParagraph(false));
			ke.preventDefault();
		} else if ((ke.utf == "home" || ke.keycode == KEY_HOME)) {
			next(state.cursorWantThisX, -1.0);
			wigiSetCursor(state, getStartPositionOfDocument(getValue(state.document)), ke.shift);
		} else if ((ke.utf == "end" || ke.keycode == KEY_END)) {
			// Ctrl+down = End of document on Mac
			next(state.cursorWantThisX, -1.0);
			wigiSetCursor(state, getEndPositionOfDocument(getValue(state.document), true), ke.shift);
		} else if (ke.utf == "delete" || ke.keycode == KEY_DELETE) {
			wigiSendEvent(state, WigiDeleteWord());
			{}
		} else if (ke.utf == "backspace" || ke.keycode == KEY_BACKSPACE) {
			wigiSendEvent(state, WigiBackspaceWord());
			{}
		// TODO: where do 219 and 221 come from? Danish or russian keyboards? Clarify
		} else if (ke.utf == "[" || ke.keycode == 219 || ke.keycode == KEY_BRACKET_LEFT) {
			wigiSendEvent(state, WigiZoomOut());
			{}
		} else if (ke.utf == "]"  || ke.keycode == 221 || ke.keycode == KEY_BRACKET_RIGHT) {
			wigiSendEvent(state, WigiZoomIn());
			{}
		} else if (ke.utf == "0" || ke.keycode == KEY_0) {
			wigiSendEvent(state, WigiResetZoom());
			{}
		} else if (ke.utf == "n" || ke.utf == "N" || ke.keycode == KEY_N) {
			changeFirstLineIndent(state, isShiftIn(ke));
		} else if (ke.utf == "p" || ke.utf == "P" || ke.keycode == KEY_P) {
			wigiSendEvent(state, WigiClearParagraphFormatting());
			ke.preventDefault();
		} else if (ke.utf == "l" || ke.utf == "L" || ke.keycode == KEY_L) {
			changeNumberedTypeParagraphStyle(state, None());
		} else if (ke.utf == "6" || ke.keycode == KEY_6) {
			wigiSendEvent(state, WigiSetBaselineShift(-0.5)) |> ignore; // superscript
		} else if (ke.utf == "-" || ke.keycode == 189) {
			wigiSendEvent(state, WigiSetBaselineShift(0.5)) |> ignore; // subscript
		} else if (ke.utf == "t"  || ke.utf == "T" || ke.keycode == KEY_T) {
			// Ctrl+T - add interactive
			// never show FullInteractiveList (should be true for templo)
//			addInteractive(state, false);
		}
	}
}



makeKeyDownHandler(state : WigiEditorState, focusId : int) -> (bool, KeyEvent) -> bool {
	\handled, ke -> {
		curKbdFocusId = currentKeyboardFocusId();
		// Only if we have focus, we handle keyboard events
		inFocus = curKbdFocusId == focusId ;
		shift = isShiftIn(ke);
		if (inFocus) nextDistinct(state.shiftHeld, shift);

		if (!handled && inFocus) {
			customKeyHandler = extractStruct(state.wigiEditorStyle, CustomKeyHandler(\__, __ -> false)).handler;
			if (isCtrlIn(ke) && !ke.alt && handleKeyDownEvents) {// Ctrl+Letter handling does not work on KeyDown in IE so we need to have Ctrl processing in both KeyDown and KeyUp handlers
				handleSpecialCtrlEvent(state, ke);
				true;
			} else if (customKeyHandler(ke, state)) {
				true;
			} else if (ke.utf == "right" || ke.keycode == KEY_RIGHT) {
				wigiSendEvent(state, WigiCursorRight(ke.shift));
			} else if (ke.utf == "left" || ke.keycode == KEY_LEFT) {
				wigiSendEvent(state, WigiCursorLeft(ke.shift));
			} else if (ke.utf == "up" || ke.keycode == KEY_UP) {
				wigiSendEvent(state, WigiCursorUp(ke.shift));
			} else if (ke.utf == "down" || ke.keycode == KEY_DOWN) {
				wigiSendEvent(state, WigiCursorDown(ke.shift));
			} else if (ke.utf == "page up" || ke.keycode == KEY_PAGEUP) {
				wigiSendEvent(state, WigiPageUp(ke.shift));
			} else if (ke.utf == "page down" || ke.keycode == KEY_PAGEDOWN) {
				wigiSendEvent(state, WigiPageDown(ke.shift));
			} else if (ke.utf == "home" || ke.keycode == KEY_HOME) {
				next(state.cursorWantThisX, -1.0);
				wigiSendEvent(state, WigiHome(ke.shift));
			} else if (ke.utf == "end" || ke.keycode == KEY_END) {
				next(state.cursorWantThisX, -1.0);
				wigiSendEvent(state, WigiEnd(ke.shift));
			} else if (ke.utf == "enter" || ke.keycode == KEY_ENTER) {
				wigiSendEvent(state, WigiEnter(ke.shift));
				true;
			} else if (ke.utf == "delete" || ke.keycode == KEY_DELETE) {
				wigiSendEvent(state, WigiDelete());
			} else if (ke.utf == "backspace" || ke.keycode == KEY_BACKSPACE) {
				wigiSendEvent(state, WigiBackspace());
			} else if (ke.utf == "esc" || ke.keycode == KEY_ESCAPE) {
//						wigiCursorToCell(state);
				wigiSendEvent(state, WigiSetCellCursor());
				true;
			} else if (ke.utf == "F2" || ke.keycode == KEY_F2) {
				// Start editing, but select the entire cell
				d = getValue(state.document);
				c = getValue(state.cursor);
				e = getElementAtPosition(d, c);
				s = getStartPositionOfDocument(e);
				en = getEndPositionOfDocument(e, true);
				wigiSetCursor(state, concat(c, s), false);
				wigiSetCursor(state, concat(c, en), true);
				true;
			} else if (strlen(ke.utf) != 1) {
				// tab, esc, function keys, etc.
				false;
			} else {
				isSpeadsheet = \ -> {
					doc = getValue(state.document);
					isWigiRecursive(getElementAtPosition(doc, wigiFindParentRecursive(doc, [], getValue(state.cursor))), [dummyWigiSpreadsheetCell])
				};
				if (isCellCursor(state) && !isSpeadsheet()) {
					// Cells have special behaviours
					if (ke.utf == " " || ke.keycode == KEY_SPACE) {
						wigiSendEvent(state, WigiSpace());
						{}
					}
				} else {
					// Ctrl+something combinations for IE must be handled in KeyUp handler
					if (!(isCtrlIn(ke) && handleKeyUpEvents))
						wigiSendEvent(state, WigiInsertText(ke.utf)) |> ignore;
				}
				true;
			}
		} else handled
	}
}


keyEventHandleWrapper(iForm: Interactive, focusB : DynamicBehaviour<bool>, focusId : int, zorder : Behaviour<int>) -> Form {
	dummyKeyHandler = \handled, ke -> handled;
	dummyMouseHandler = \handled, mi -> handled;

	iKeyDown: ref (bool, KeyEvent) -> bool = ref dummyKeyHandler;
	iMouseUp = ref dummyMouseHandler;

	otherListeners = fold(iForm.listeners, [], \acc, l -> switch(l){
		KeyDown2(f): {iKeyDown := f; acc;}
		MouseUp2(f): {iMouseUp := f; acc;}
		default : arrayPush(acc, l);
	});

	handlerState = make([]);

	stopHandler  = \-> next(handlerState, [Content("", []), Content("", []), Focus(false)]);
	startHandler = \-> next(handlerState, [Content("", []), Content("", []), Focus(true)]);
	clearHandler = \-> next(handlerState, [Content("", []), Content("", [])]);
	reader = ref(\-> TextInputModel("", 0.0, 0.0, 0, Selection(0, 0), false, None()));

	niceContent = make("");
	dummyKeyEvent = KeyEvent("", false, false, false, false, -1, nop);
	currentKeyEvent : ref KeyEvent = ref dummyKeyEvent;

	setCurrentKeyEvent = \ke : KeyEvent -> {
		if (^currentKeyEvent != dummyKeyEvent && ke != dummyKeyEvent){
			println("Keyboard buffer error: " + toString(ke) + " has come before the finish of " + toString(^currentKeyEvent) + " processing");
		}
		currentKeyEvent := ke;
	}

	handleKeyDown = \ke : KeyEvent -> {
		setCurrentKeyEvent(dummyKeyEvent);
		(^iKeyDown)(false, ke);
	}

	processBufferContent = \c ->{
		if (c != ""){
			ke = ^currentKeyEvent;
			if (ke != dummyKeyEvent){
				event = if (c != ke.utf) {
					KeyEvent(c, ke.ctrl, ke.shift, ke.alt, ke.meta, ke.keycode, ke.preventDefault)
				} else {
					ke;
				};
				handleKeyDown(event) |> ignore;
			} else {
				// println("Keyboard buffer error: \"" + c + "\" is lost because of unknown key event");
			}
		}
	}

	buffer = {
		b = TextInput([TextSize(0.1, 0.0)], // Safari doesn't set focus when width is 0.0
			[
				TextChange(\text -> {
					if (text.content != ""){
						next(niceContent, text.content);
						clearHandler();
					}
				}),
				FocusIn(\-> updateKeyboardFocus(focusId))
			],
			[
				StateChanger(handlerState),
				StateQuery2(reader) //Do not delete if there is a need to add StateQuery. Used in takeSnapshot
			]
		);

		b1 = if (zorder != const(-1)) Access([AccessZorder(zorder)], b) else b;

		Alpha(make(0.0), FixSize(0.0, 0.0, b1)); //LSTSBD-351 Offset(-10000, -10000) is replaced with Alpha as shadow calculation in Pixi JS doesn't ignore forms outside of screen.
	}

	newInteractive = Interactive(concat(
		[
			KeyDown2(\handled : bool, ke : KeyEvent -> {
				if (getValue(focusB) && !handled) {
					if (isCtrlIn(ke)) {
						handleKeyDown(ke);
					} else {
						setCurrentKeyEvent(ke);
						// check key code in case of ke.keycode is correct but ke.utf is somewhat strange
						specialKeyCodes = [8, 9, 13, 27, 33, 34, 35, 36, 37, 38, 39, 40, 46, 113];
						specialKey = contains(specialKeyCodes, ke.keycode) || strlen(ke.utf) != 1;
						state = (^reader)();
						if (specialKey) {
							if (!state.focus && (ke.utf == "backspace" || ke.keycode == KEY_BACKSPACE)) startHandler();
							handleKeyDown(ke);
						} else {
							if (!state.focus){
								println("Keyboard buffer warning: " + toString(ke) + " might be lost because the buffer has no focus");
								startHandler();
							}
							true
						}
					}
				} else {
					handled
				}
			}),
			MouseUp2(\handled, mi -> {
				if (getValue(focusB) && mi().inside) {
					startHandler();
				};
				(^iMouseUp)(handled, mi);
			})
		], otherListeners),
		Group([
			buffer,
			iForm.form
		])
	);

	Constructor(
		newInteractive,
		\->{
			if (getValue(focusB)) startHandler();
			u1 = subscribe2(focusB, \f -> if (f) startHandler() else stopHandler());
			u2 = subscribe(niceContent, processBufferContent);
			\->{
				u1();
				u2();
			}
		}
	)
}

// adjust height and vertical offset of cursor to state.baselineShift
adjustCursorToBaselineShift(state : WigiEditorState) -> Pair<double, double>{
	shortStyle = switch(getElementAtPosition(getValue(state.document), getValue(state.cursor))){
		WigiText (__, s): s;
		default: []
	};

	curStyle = getWigiTextStyleFull(state.defaultStyles, getValue(state.document), getValue(state.cursor), shortStyle);

	tShift = getValue(state.baselineShift); // this shift comes from toolbar
	dShift = extractStruct(curStyle, BaselineShift(0.0)).shift; // this shift is taken from document under cursor
	h = getValue(state.cursorHeight);

	k = SuperSubscriptScalingCoeff; // super/subscript font size scaling value

	// new cursor height
	hc = if (tShift == dShift) h
		else if (dShift == 0.0) h * k
		else if (tShift == 0.0) h / k
		else h;

	// y-offset adjustment for cursor
	dy = if (tShift == dShift) 0.0
		else if (dShift == 0.0) {
			if (tShift < 0.0) -h * (k - 0.5) else h * (0.8 - k * 0.4);
		} else if (dShift < 0.0) {
			if (tShift == 0.0) h * (k - 0.5) / k else h / k * (0.6 * k + 0.3);
		} else {
			if (tShift == 0.0) -h * (0.8 / k - 0.4)  else - h / k * (0.6 * k + 0.3);
		}
	Pair(hc, dy);
}


connectDistinctTransistoru(gateway : Behaviour<bool>, from : Behaviour<?>, to : DynamicBehaviour<?>) -> (() -> void) {
	helperTrans = transistoru(gateway, from);
	connectUns = connectDistinct(helperTrans.value, to);
	\-> { helperTrans.dispose(); connectUns(); }
}

