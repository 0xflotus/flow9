import wigi/wigi_engine_core;

export {
	// Simialr to linkValueToEngine but instead of setting and updating cell "x" it finds corresponding cell based on "exp"
	// and updates part of it's value based on "exp" structure. For example allows to update elements of array and record fields
	linkPartialValueToEngine(engine : WigiEngine, namespace : WigiScope, exp : WigiExpr, valB : DynamicBehaviour<WigiValue>, style : [WigiEngineStyle]) -> () -> void;
}

LinkPartialValueType(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr, valB : DynamicBehaviour<WigiValue>, style : [WigiEngineStyle], notLeftHandSideError : () -> () -> void);

// Linking to the value by expression we are making a array of special accessors.
// This array is used in runtime to get subvalue of the element by path and set subvalue in the element by path
WigiExprAccessElement(
	// getter returns the subvalue of case value by path, if it can't get the value, it returns passed default
	getter : (WigiValue /*base value*/, [WigiExprAccessElement] /* path to subvalue*/, WigiValue /*default value*/) -> WigiValue,
	// setter takes the base value and returns it with changed subvalue by the path. if path nnot found the base value reurned unchanged
	setter : (WigiValue /*base value*/, [WigiExprAccessElement] /* path to subvalue to be changed*/, WigiValue /*new value*/) -> WigiValue
);

getValueByPath(value : WigiValue, path : [WigiExprAccessElement], def : WigiValue) -> WigiValue {
	if (path == []) {
		value
	} else {
		callFn = \ -> {
			path[0].getter(value, tail(path), def);
		}

		switch (value : WigiValue) {
			WigiRecord(__): callFn();
			WigiArray(__): callFn();
			default: {
				devtrace("Expected WigiArray/WigiRecord, got " + toString(value));
				def
			}
		}
	}
}

setValueByPath(value : WigiValue, path : [WigiExprAccessElement], newValue : WigiValue) -> WigiValue {
	if (path == []) {
		newValue
	} else {
		callFn = \ -> {
			path[0].setter(value, tail(path), newValue);
		}

		switch (value : WigiValue) {
			WigiRecord(__): callFn();
			WigiArray(__): callFn();
			default: {
				devtrace("Expected WigiArray/WigiRecord, got " + toString(value));
				value
			}
		}
	}
}

linkPartialValueToEngineWigiField(lpvt : LinkPartialValueType, baseAccessPath : [WigiExprAccessElement], wStruct : WigiExpr, wFields : [WigiExpr]) -> () -> void {
	accessWigiExprAccessElement = WigiExprAccessElement(
		\value, subPath, def -> {
			switch (value : WigiValue) {
				WigiRecord(fields): {
					wFild = elementAt(wFields, 0, WigiDefaultValue());
					switch (wFild : WigiExpr) {
						WigiVarRef(name): {
							eitherFn(
								find(fields, \vField : Pair<string, WigiValue> -> toUpperCase(vField.first) == name),
								\field -> getValueByPath(field.second, subPath, def),
								\ -> {
									devtrace("Name '" + name + "' not found in WigiRecord " + toString(value));
									value;
								}
							)
						}
						default: {
							devtrace("Expected WigiVarRef, got " + toString(wFild));
							def;
						};
					}
				}
				default: {
					devtrace("Expected WigiRecord, got " + toString(value));
					def;
				}
			}
		},
		\value, subPath, newValue -> {
			switch (value : WigiValue) {
				WigiRecord(fields): {
					wFild = elementAt(wFields, 0, WigiDefaultValue());
					switch (wFild : WigiExpr) {
						WigiVarRef(name): {
							WigiRecord(
								map(fields, \vField : Pair -> {
									if (toUpperCase(vField.first) == name) {
										elem = vField.second;
										Pair(vField.first, setValueByPath(elem, subPath, newValue))
									} else {
										vField
									}
								})
							);
						}
						default: {
							devtrace("Expected WigiVarRef, got " + toString(wFild));
							value;
						}
					}
				}
				default: {
					devtrace("Expected WigiRecord, got " + toString(value));
					value;
				}
			}
		}
	);

	accessPath = concat([accessWigiExprAccessElement], baseAccessPath);

	switch (wStruct : WigiExpr) {
		WigiVarRef(xStruct): {
			wField = elementAt(wFields, 0, WigiDefaultValue());
			switch (wField : WigiExpr) {
				WigiVarRef(xField): {
					cell = wigiCellName(xStruct, lpvt.namespace);

					linkPartialValueToCell(lpvt, cell,
						\ofv, pv -> {
							switch (ofv) {
								WigiRecord(__): {
									setValueByPath(ofv, accessPath, pv);
								}
								default: {
									devtrace("Can't access field of non record");
									ofv
								}
							}
						},
						\opv, fv -> {
							switch (fv) {
								WigiRecord(__): {
									getValueByPath(fv, accessPath, opv);
								}
								default: {
									devtrace("Can't access field of non record");
									opv
								}
							}
						}
					)
				}
				default: lpvt.notLeftHandSideError();
			}
		}
		WigiCall(wFn1, wArgs1): {
			linkPartialValueToEngineWigiCall(lpvt, accessPath, wFn1, wArgs1);
		}
		WigiField(wStruct1, wFields1): {
			linkPartialValueToEngineWigiField(lpvt, accessPath, wStruct1, wFields1)
		}
		default: lpvt.notLeftHandSideError();
	}
}

linkPartialValueToEngineWigiCall(lpvt : LinkPartialValueType, baseAccessPath : [WigiExprAccessElement], wFn : WigiExpr, wArgs : [WigiExpr]) -> () -> void  {
	if (wFn == WigiString("[") && length(wArgs) == 2) {
		// array indexing
		wArray = wArgs[0];
		wIndex = wArgs[1];

		accessWigiExprAccessElement = WigiExprAccessElement(
			\value, subPath, def -> {
				res0 = switch (value : WigiExpr) {
					WigiArray(values): {
						xIndex = wigiValue2Int(calculateWigiValueFromExpr(wIndex, lpvt.engine, lpvt.namespace));
						elementAt(values, xIndex, WigiError("Can't get element by index " + i2s(xIndex) + " in array " + toString(value)))
					}
					default: WigiError("Expected WigiArray, got " + toString(value));
				}
				getValueByPath(res0, subPath, def);
			},
			\value, subPath, newValue -> {
				xIndex = wigiValue2Int(calculateWigiValueFromExpr(wIndex, lpvt.engine, lpvt.namespace));
				switch (value : WigiExpr) {
					WigiArray(values): {
						WigiArray(
							mapi(values, \i, v -> {
								if (i == xIndex) setValueByPath(v, subPath, newValue)
								else v
							})
						)
					}
					default: WigiError("Expected WigiArray, got " + toString(value));
				}
			}
		);

		accessPath = concat([accessWigiExprAccessElement], baseAccessPath);

		switch (wArray : WigiExpr) {
			WigiVarRef(xArray): {
				cell = wigiCellName(xArray, lpvt.namespace);

				linkPartialValueToCell(lpvt, cell,
					\ofv, pv -> {
						switch (ofv) {
							WigiArray(__): {
								setValueByPath(ofv, accessPath, pv);
							}
							default: {
								devtrace("Can't index non array value");
								ofv
							}
						}
					},
					\opv, fv -> {
						switch (fv) {
							WigiArray(__): {
								getValueByPath(fv, accessPath, opv);
							}
							default: {
								devtrace("Can't index non array value");
								opv
							}
						}
					}
				)
			}
			WigiField(wStruct, wFields): {
				linkPartialValueToEngineWigiField(lpvt, accessPath, wStruct, wFields);
			}
			default: lpvt.notLeftHandSideError();
		}
	} else {
		lpvt.notLeftHandSideError();
	}

}

linkPartialValueToEngine(engine : WigiEngine, namespace : WigiScope, expr : WigiExpr, valB : DynamicBehaviour<WigiValue>, style : [WigiEngineStyle]) -> () -> void {
	notLeftHandSideError = \ -> {
		devtrace("Given expression is not left-hand side value: " + toString(expr));
		nop
	}

	lpvt = LinkPartialValueType(engine, namespace, expr, valB, style, notLeftHandSideError);

	unsub1 = switch (expr : WigiExpr) {
		WigiNamespace(ns, rexpr): {
			linkPartialValueToEngine(engine, WigiScope(concat([""], ns)), rexpr, valB, style)
		}
		WigiVarRef(x): {
			linkValueToEngineExtended(engine, wigiCellName(x, namespace), valB, style)
		}
		WigiCall(wFn, wArgs): {
			linkPartialValueToEngineWigiCall(lpvt, [], wFn, wArgs);
		}
		WigiField(wStruct, wFields): {
			linkPartialValueToEngineWigiField(lpvt, [], wStruct, wFields);
		}
		default: {
			notLeftHandSideError();
		}
	}

	\ -> {
		unsub1();
	}
}

linkPartialValueToCell(
	lpvt : LinkPartialValueType,
	cell : WigiCellName,
	updateFullValueFn : (/* original full value */ WigiValue, /* new partial value */ WigiValue) -> WigiValue, /* new full value */
	updatePartialValueFn : (/* original partial value */ WigiValue, /* new full value */ WigiValue) -> WigiValue /* new partial value */
) -> () -> void {
	fullValueM = resolveWigiCell(^(lpvt.engine.env), cell.namespace, cell.name);

	switch(fullValueM) {
		Some(fullValuePair): {
			fullValueB = fullValuePair.second;
			switch (fullValueB) {
				ConstBehaviour(constValue): {
					// we want to treat const behaviour as dynamic so we change it to be dynamic in the env and call itself again
					uns1 = addValueToWigiEngineExtended(lpvt.engine, cell, make(constValue), arrayPush(lpvt.style, DeathlessVariable(true)));
					uns2 = linkPartialValueToCell(lpvt, cell, updateFullValueFn, updatePartialValueFn);
					\ -> { applyall([uns1, uns2]) }
				}
				DynamicBehaviour(__, __): {
					p2fv = \pv -> updateFullValueFn(getValue(fullValueB), pv);
					f2pv = \fv -> updatePartialValueFn(getValue(lpvt.valB), fv);

					// we have to update cell's dependencies when changing partial value because engine's dependencies works with full cell only
					uns1 = subscribe2(fullValueB, \__ -> updateEngineVariable(lpvt.engine, cell));
					uns2 = if (contains(lpvt.style, OverrideWigiVariableByNewValue()))
						bidirectionalLink(lpvt.valB, fullValueB, p2fv, f2pv)
					 else
						bidirectionalLink(fullValueB, lpvt.valB, f2pv, p2fv);
					\ -> { applyall([uns1, uns2]) }
				}
			}
		}
		None(): {
			devtrace("Can't find neither " + toString(cell) + " variable or formula in Wigi environment");
			nop
		}
	}
}