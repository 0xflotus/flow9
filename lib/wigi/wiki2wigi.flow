import arrayutils; // subtractA
import binarytree;
import textstyles;
import formats/wiki/wiki2parsedwiki;
import wigi/types;
import wigi/normalize;
import wigi/storage;

export {
	// Convert this Wiki to a Wigi document as well as possible.
	wiki2wigi(wiki : string, defaultWigiStyles : Maybe<[WigiStyles]>) -> Pair<WigiElement, [string]>;
	wikiAst2wigi(wikiAst : [WikiParsedToken], defaultWigiStyles : Maybe<[WigiStyles]>, multilineOnly : bool) -> Pair<WigiElement, [string]>;
}


//a weak helper for setting paragraph spacing
multilineTextOnly(wiki : string) -> bool {	
	fn : ref ((WikiToken) -> bool) = ref (\tkn -> false);
	fn := \tkn -> switch (tkn) {
		WText(text, __): isMultiline(text);
		WIndentedFirstLine(text): isMultiline(text);
		WIndentedText(text): isMultiline(text);
		WSmall(): true;
		WCenter(tkn2) : (^fn)(tkn2);
		default: false;
	};
	tokens = tokenize(wiki, false) |> lexems;
	fold(tokens, true, \acc, token -> acc && (^fn)(token));
}

WikiWigiDefaultTextStyle : [WigiTextStyle] = []; // is equal to default wigi editor text style
WikiWigiDefaultParagraphStyle : [WigiParagraphStyle] = []; // is equal to default wigi editor paragraph style
WikiWigiDefaultStoryStyle = [dwps];
smallText = ref false;
wikiWigiTextStyle : ref [WigiTextStyle] = ref [];
insideListed = ref false;


initConversionGlobalWigiStyles(defaultWigiStyles : Maybe<[WigiStyles]>) -> void {
	smallText := false;
	insideListed := false;
	wikiWigiTextStyle := eitherMap(defaultWigiStyles,
		\ws -> concatWigiTextStyles(WikiWigiDefaultTextStyle, getDefaultDocumentStyle(ws).textStyle),
		WikiWigiDefaultTextStyle
	);
}

wikiAst2wigi(wikiAst : [WikiParsedToken], defaultWigiStyles : Maybe<[WigiStyles]>, multilineOnly : bool) -> Pair<WigiElement, [string]> {
	initConversionGlobalWigiStyles(defaultWigiStyles);

	errors = ref [];
	elements = fold(wikiAst, defWigiWikiAcc(^wikiWigiTextStyle), \acc : WikiWigiAcc, token : WikiParsedToken -> {
		wikiParsedToken2Wigi(token, acc, errors);
	});

	flush = flushWikiWigi(elements);
	storyStyle = if (multilineOnly) [ParagraphSpacing(6.0)] else WikiWigiDefaultStoryStyle;
	wigi = makeWigiStory(flush.paragraphs, storyStyle) |> normalizeWigiDocument;

	Pair(
		makeWigiFullStyled(wigi, defaultWigiStyles),
		^errors
	);
}


wiki2wigi(rawWiki : string, defaultWigiStyles : Maybe<[WigiStyles]>) -> Pair<WigiElement, [string]> {
	if (rawWiki != ""){
		wiki = strReplace(rawWiki, "\u000d", "");
		wikiAst : [WikiParsedToken] = BuildFullWikiTree(wiki);
		wikiAst2wigi(wikiAst, defaultWigiStyles, multilineTextOnly(wiki))
	} else {
		initConversionGlobalWigiStyles(defaultWigiStyles);
		Pair(makeWigiStory([WigiParagraph([WigiText("", ^wikiWigiTextStyle)], WikiWigiDefaultParagraphStyle)], WikiWigiDefaultStoryStyle), []);
	}
}

WikiWigiAcc(runningParagraph : [WigiElement], paragraphs : [WigiElement], paragraphStyle : [WigiParagraphStyle], textStyle : [WigiTextStyle]);

wikiParsedToken2Wigi(token : WikiParsedToken, acc : WikiWigiAcc, errors : ref [string]) -> WikiWigiAcc {
	restoreParaStyle = \a -> WikiWigiAcc(a.runningParagraph, a.paragraphs, acc.paragraphStyle, a.textStyle);
	listed2Wigi = \constructs, listedStyle -> {
		nacc = flushWikiWigi(acc);
		ps = concat(acc.paragraphStyle, listedStyle);
		nacc2 = WikiWigiAcc(nacc.runningParagraph, nacc.paragraphs, ps, nacc.textStyle);
		nacc3 = wikiConstructions2Wigi(constructs, nacc2, errors);
		insideListed := false;
		flushWikiWigi(nacc3) |> restoreParaStyle;
	}

	bulletStyle : [WigiTextStyle] = BulletText |> getValue |> flow; // quick fix to compile #35549 changes. Sharpness is not expected in BulletText

	bulleted = Listed(Bulleted("\u2022"), bulletStyle);

	switch (token : WikiParsedToken) {
		WParsedText(constructions): {
			wikiConstructions2Wigi(constructions, acc, errors)
		}
		WNewLine(): {
			addWigiEmptyLine(acc);
		}
		WParsedCenter(tok): {
			acc2 = flushWikiWigi(acc);
			nacc = WikiWigiAcc(acc2.runningParagraph, acc2.paragraphs, arrayPush(acc2.paragraphStyle, CenterAlign()), acc.textStyle);
			nacc2 = wikiParsedToken2Wigi(tok, nacc, errors);
			nacc3 = flushWikiWigi(nacc2);
			WikiWigiAcc(nacc3.runningParagraph, nacc3.paragraphs, subtractA(acc2.paragraphStyle, [CenterAlign()]), nacc3.textStyle);
		}
		WParsedBullet1(constructions): {
			listed2Wigi(constructions, [bulleted]);
		}
		WParsedBullet2(constructions): {
			listed2Wigi(constructions, [GeneralIndent(10.0), bulleted]);
		}
		WParsedNumbered1(n, pretty, dotted, constructions):{
			numbered = Listed(Numbered(n, if (pretty) PrettyNumber() else if (dotted) DottedNumber() else SimpleNumber()), []);
			listed2Wigi(constructions, [numbered])
		}
		WParsedIndentedFirstLine(constructions): {
			cs = replaceLeadingSpaces(constructions, "\u00A0");
			acc2 = flushWikiWigi(acc);
			ps = concatWigiParagraphStyles(acc.paragraphStyle, [FirstLineIndent(32.0)]);
			acc3 = WikiWigiAcc(acc2.runningParagraph, acc2.paragraphs, ps, acc2.textStyle);
			nacc = wikiConstructions2Wigi(cs, acc3, errors);
			flushWikiWigi(nacc) |> restoreParaStyle;
		}
		WParsedIndentedText(constructions): {
			cs = replaceLeadingSpaces(constructions, "");
			acc2 = flushWikiWigi(acc);
			ps = concatWigiParagraphStyles(acc.paragraphStyle, [StartAlign(), GeneralIndent(32.0)]);
			acc3 = WikiWigiAcc(acc2.runningParagraph, acc2.paragraphs, ps, acc2.textStyle);
			nacc = wikiConstructions2Wigi(cs, acc3, errors);
			flushWikiWigi(nacc) |> restoreParaStyle;
		}
		WParsedHeading1(constructions):{
			nacc = flushWikiWigi(acc);
			hStyle = getWigiTextStyleFromCharacterStyle(HeadingText);
			nacc2 = WikiWigiAcc(nacc.runningParagraph, nacc.paragraphs, nacc.paragraphStyle, hStyle);
			nacc3 = wikiConstructions2Wigi(constructions, nacc2, errors);
			nacc4 = flushWikiWigi(nacc3);
			WikiWigiAcc(nacc4.runningParagraph, nacc4.paragraphs, nacc4.paragraphStyle, nacc.textStyle);
		}
		WParsedHeading2(constructions):{
			nacc = flushWikiWigi(acc);
			hStyle = getWigiTextStyleFromCharacterStyle(Heading2Text);
			nacc2 = WikiWigiAcc(nacc.runningParagraph, nacc.paragraphs, nacc.paragraphStyle, hStyle);
			nacc3 = wikiConstructions2Wigi(constructions, nacc2, errors);
			nacc4 = flushWikiWigi(nacc3);
			WikiWigiAcc(nacc4.runningParagraph, nacc4.paragraphs, nacc4.paragraphStyle, nacc.textStyle);
		}
		WNewPage(autoScroll):{
			smallText := false;
			nacc = flushWikiWigi(acc);
			flushWikiWigi(addWigiElement(nacc, WigiBlock(WigiPageBreak(false, autoScroll), [])));
		}
		WPageSeparator(autoScroll):{
			smallText := false;
			nacc = flushWikiWigi(acc);
			flushWikiWigi(addWigiElement(nacc, WigiBlock(WigiPageBreak(true, autoScroll), [])));
		}
		WParsedTable(cells):{
			//TODO figure out styles of recursive, table, cell
			rows = length(cells);
			cols = either(maxA(map(cells, length)), 0);
			arr = cells |> concatA;

			getTableCell = \pa -> {
				//create paragraph if it is empty
				_pa = if (length(pa) == 0) [WigiParagraph([WigiText("", [])], [StartAlign(), TightWidth()])] else pa;
				WigiRecursive([makeWigiStory(_pa, [])], WigiTableCell(makeWH(), [WigiCellPadding(6.0, 6.0, 6.0, 6.0)]), []);
			};

			getText = \i -> i2s(i + 1);

			tableAcc = WikiWigiAcc([],[],[StartAlign(), TightWidth()], acc.textStyle);
			elements = map(arr, \c -> {
				a = flushWikiWigi(wikiConstructions2Wigi(c, tableAcc, errors));
				getTableCell(a.paragraphs);
			});

			cellSpans = concatA(map(cells, \c -> {
				last = length(c) - 1;
				arrayPush(generate(0, last, \i -> WigiCellSpan(1, 1)), WigiCellSpan(1, cols - last));
			}));

			table = WigiRecursive(elements, WigiTable(rows, cols, cellSpans, []), []);
			nacc = flushWikiWigi(acc);
			flushWikiWigi(addWigiElement(nacc, table));
		}
		WPageName(name, disableCondition):{
			nacc = flushWikiWigi(acc);
			flushWikiWigi(addWigiElement(nacc, WigiBlock(WigiPageName(name, disableCondition), acc.textStyle)));
		}
		WParsedCoach(coachConstructions):{
			nacc = flushWikiWigi(acc);
			src = concatStrings(map(coachConstructions, \construction ->{
				switch(construction) {
					WikiSimpleConstructions(__, src): src;
					WikiSequenceEx(sequence): {
						result = wv_sequence2string(sequence);
						if (result.second != []) {
							refArrayPush(errors, "Could not convert kind 1 " + toString(token) + " to Wigi");
							""
						} else {
							"{" + result.first + "}";
						}
					}
					MathNaturalSyntaxEx(src): {
						println("WigiCoach takes a plain text only");
						src;
					}
					default: {
						refArrayPush(errors, "Could not convert kind 1 " + toString(token) + " to Wigi");
						""
					}
				}
			}));
			flushWikiWigi(addWigiElement(nacc, WigiBlock(WigiCoach(rtrim2(src, "\n")), updateBlockStyle(acc.textStyle, []))));
		}
		WSmall():{
			smallText := true;
			fs : FontSize = extractStruct(acc.textStyle, FontSize(11.0));
			newSize = if (fs.size > 4.0) fs.size - 2.0 else 2.0;
			newTextStyle = arrayPush(filter(acc.textStyle, neq(fs)), FontSize(newSize));
			WikiWigiAcc(acc.runningParagraph, acc.paragraphs, acc.paragraphStyle, newTextStyle);
		}
		WComment(text) : {
			nacc = flushWikiWigi(acc);
			flushWikiWigi(addWigiElement(nacc, WigiBlock(WigiNativeWiki("//"+text), acc.textStyle)));
		}
		default: {
			refArrayPush(errors, "Could not convert kind 1 " + toString(token) + " to Wigi");
			acc;
		}
	}
}

// when importing to Wigi we left-trim a text within <span> tag.
leftTrimSpanContent(construct : WikiConstruction) -> WikiConstruction {
	trimLeft = \cs -> if (cs == []) cs else concat([leftTrimSpanContent(cs[0])], tail(cs));

	switch (construct : WikiConstruction) {
		WikiSimpleConstructions(constrs, src): WikiSimpleConstructions(trimLeft(constrs), src);
		WikiBaseTextEx(hs): WikiBaseTextEx(ltrim(hs));
		WikiSimpleTextEx(hs, c): WikiSimpleTextEx(ltrim(hs), c);
		WikiItalicEx(cs, fix): WikiItalicEx(trimLeft(cs), fix);
		WikiBoldEx(cs): WikiBoldEx(trimLeft(cs));
		WikiBoldItalicEx(cs): WikiBoldItalicEx(trimLeft(cs));
		WikiPredefinedColorEx(col, cs): WikiPredefinedColorEx(col, trimLeft(cs));
		WikiSpanEx(cs, tt, clr, bkgr, ff, fsm): WikiSpanEx(trimLeft(cs), tt, clr, bkgr, ff, fsm);
		WikiUnderlineEx(txt): WikiUnderlineEx(ltrim(txt));
		WikiSubscriptEx(txt): WikiSubscriptEx(ltrim(txt));
		WikiSuperscriptEx(txt): WikiSuperscriptEx(ltrim(txt));
		WikiOneLineEx(es): WikiOneLineEx(trimLeft(es));
		MathUnknownConstruction(text) : MathUnknownConstruction(ltrim(text));
		default: {
			if (isDevMode()) {
				println("No left-trimming for " + toString(construct));
			}
			construct;
		}
	}
}

// if a bulletted/numbered text contains some lines we need to adjust style for the lines after the first one
getInsideListedParagraphStyle(acc : WikiWigiAcc, ps : [WigiParagraphStyle])-> [WigiParagraphStyle]{
	listed = extractStruct(ps, dummyListed);
	if (listed == dummyListed) ps else {
		fli : FirstLineIndent = extractStruct(ps, FirstLineIndent(0.0));
		gi : GeneralIndent = extractStruct(ps, GeneralIndent(0.0));
		fs = extractStruct(acc.textStyle, FontSize(11.0)).size;
		ns = filter(ps, \st -> st != listed && st != fli && st != gi);
		concat(ns, [GeneralIndent(gi.indent + fli.indent + fs * 1.25)]);
	}
}

addWigiEmptyLine(acc : WikiWigiAcc) -> WikiWigiAcc {
	emptyLine =  WigiText("", acc.textStyle);
	nacc = flushWikiWigi(acc);
	flushWikiWigi(WikiWigiAcc([emptyLine], nacc.paragraphs, nacc.paragraphStyle, nacc.textStyle));
}

replaceNbspConstructions(cs : [WikiConstruction], acc : [WikiConstruction]) -> [WikiConstruction]{
	nbspWiki = [GlueFragments(), WikiBaseTextEx(" "), GlueFragments()];
	nbspWikiWigi = WikiBaseTextEx("\u00A0");
	if (cs == []) acc
	else if (subrange(cs, 0, 3) == nbspWiki){
		replaceNbspConstructions(subrange(cs, 3, length(cs) - 3), arrayPush(acc, nbspWikiWigi));
	} else {
		replaceNbspConstructions(tail(cs), arrayPush(acc, cs[0]));
	}
}

wikiConstruction2Wigi(construct : WikiConstruction, acc : WikiWigiAcc, errors : ref [string]) -> WikiWigiAcc {
	switch (construct : WikiConstruction) {
		WikiSimpleConstructions(constrs, src): {
			cs = replaceNbspConstructions(constrs, []);
			wikiConstructions2Wigi(cs, acc, errors)
		}
		WikiBaseTextEx(hs): {
			s = unescapeNumericHtml(hs);
			nocr = strReplace(s, "\u000d", "");
//			lines = strSplit(nocr, "\n\n");

			sep = "\n";
			lines = strSplitLeave(nocr, sep);

			if (length(lines) == 1) {
				if (lines[0] != sep) addWigiElement(acc, WigiText(lines[0], acc.textStyle))
				else if (acc.runningParagraph == []) addWigiEmptyLine(acc)
				else flushWikiWigi(acc)
			} else {
				// we preserve paragraph style when each line of base text goes to its own WigiParagraph
				paraStyle = acc.paragraphStyle;
				foldi(lines, acc, \i, acc2, l -> {
					if (l == sep) {
						if (acc2.runningParagraph == []) addWigiEmptyLine(acc2) else flushWikiWigi(acc2);
					} else {
						// restore paragraph style for a new paragraph
						ps = if (i == 0) paraStyle else getInsideListedParagraphStyle(acc2, paraStyle);
						nacc = if (acc2.runningParagraph != []) acc2
							else WikiWigiAcc(acc2.runningParagraph, acc2.paragraphs, ps, acc2.textStyle);
						e = WigiText(l, nacc.textStyle);
						addWigiElement(nacc, e);
					}
				});
			}
		}
		WikiSimpleTextEx(hs, c): {
			newStyle = fold(c, [], \acc2, cs : CharacterStyle -> {
				switch (cs) {
					Fill(cl): arrayPush(acc2, cs);
					FontSize(sz): arrayPush(acc2, cs);
					FontFamily(ff): arrayPush(acc2, cs);
					default: {
						refArrayPush(errors, "Character style not supported: " + toString(cs));
						acc2;
					}
				}
			});
			style = concatWigiTextStyles(acc.textStyle, newStyle);
			s = unescapeHtml2(hs);
			e = WigiText(s, style);
			addWigiElement(acc, e);
		}
		WikiItalicEx(cs, fix): {
			// fix=true means 1 pixel difference between wigi and wiki views of italic. Let's don't think of it as an error of conversion
			// refArrayPush(errors, "Have no idea what the fix bool in italics is: " + b2s(fix));
			wikiConstructsWithTextStyle(cs, acc, errors, [FontFamily("Italic")]);// DejaVuSansOblique?
		}
		WikiBoldEx(cs): {
			wikiConstructsWithTextStyle(cs, acc, errors, [FontFamily("Medium")]);
		}
		WikiBoldItalicEx(cs): {
			wikiConstructsWithTextStyle(cs, acc, errors, [FontFamily("MediumItalic")]);
		}
		WikiPredefinedColorEx(col, cs): {
			wikiConstructsWithTextStyle(cs, acc, errors, [Fill(col)]);
		}

		WikiSpanEx(cs, tooltip, color, background, fontFamily, fontSizeMultiplier): {
			if (isSome(tooltip)) {
				refArrayPush(errors, "Tooltip not supported " + toString(tooltip));
			}
			col = if (isSome(color)) [Fill(either(color, 0))] else [];
			back = if (isSome(background)) [BackgroundFill(either(background, 0xffffff))] else [];
			fontFam = if (isSome(fontFamily)) [FontFamily(either(fontFamily, "Book"))] else [];
			fontMult = if (isSome(fontSizeMultiplier)) {
					mult : Pair<double, bool> = either(fontSizeMultiplier, Pair(1.0, true));
					sz = if (mult.second) {
						// Relative size
						fs = extractStruct(acc.textStyle, FontSize(16.0));
						fs.size * mult.first;
					} else mult.first;
					[FontSize(sz)]
				} else [];
			ns = concatA([col, back, fontFam, fontMult]);
			ncs = if (cs == []) cs else concat([leftTrimSpanContent(cs[0])], tail(cs));
			wikiConstructsWithTextStyle(ncs, acc, errors, ns);
		}
		WikiUnderlineEx(txt): {
			e = WigiText(txt, concatWigiTextStyles(acc.textStyle, [Underline()]));
			addWigiElement(acc, e);
		}
		GlueFragments(): {
			// TODO: Figure out the proper way to handle these
			// For now, we just skip these guys
			acc;
		}
		WikiSubscriptEx(txt): {
			e = WigiText(txt, concatWigiTextStyles(acc.textStyle, [BaselineShift(0.5)]));
			addWigiElement(acc, e);
		}
		WikiSuperscriptEx(txt): {
			e = WigiText(txt, concatWigiTextStyles(acc.textStyle, [BaselineShift(-0.5)]));
			addWigiElement(acc, e);
		}
		WikiOneLineEx(es): {
			// We emulate it with a wide wigiframe
			line = wikiConstructions2Wigi(es, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			e = withWigiFrame(line);
			addWigiElement(acc, e);
		}
		MathRootEx(degree, body, src): {
			deg = wikiConstructions2Wigi(degree, tightWigiWikiAcc([]), errors);
			bod = wikiConstructions2Wigi(body, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			e = WigiRecursive([withWigiFrame(deg), withWigiFrame(bod)], WigiRoot(), []);
			addWigiElement(acc, e);
		}
		MathFracEx(num, denum, src): {
			nu = wikiConstructions2Wigi(num, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			denu = wikiConstructions2Wigi(denum, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			e = WigiRecursive([withWigiFrame(nu), withWigiFrame(denu)], WigiFraction(), []);
			addWigiElement(acc, e);
		}
		MathBracketEx(lb, rb, cs, src): {
			nu = wikiConstructions2Wigi(cs, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			e = WigiRecursive([withWigiFrame(nu)], WigiBrackets(lb, rb), []);
			addWigiElement(acc, e);
		}
		CustomSymbol(symbol): {
			size = extract(acc.textStyle, 0.0, \_style -> switch(_style) { FontSize(size): Some(size); default: None() });
			e = WigiBlock(WigiCustomSymbol(symbol, size), acc.textStyle);
			addWigiElement(acc, e);
		}
		DefiniteControlEx(signType, tc, fc, bc): {
			wtc = wikiConstructions2Wigi(tc, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			wfc = wikiConstructions2Wigi(fc, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			wbc = wikiConstructions2Wigi(bc, tightWigiWikiAcc(WikiWigiDefaultTextStyle), errors);
			wt = switch (signType : DefiniteControlSignType) {
				IntegralSign(): WigiIntegral();
				SigmaSign(): WigiSum();
				ProductSign(): WigiProduct();
				OneCharSign(charSign): WigiIntegral2(charSign);
			}
			e = WigiRecursive([withWigiFrame(wtc),withWigiFrame(wfc),withWigiFrame(wbc)], wt, []);
 			addWigiElement(acc, e);
		}
		WikiScoringIconEx(type, tooltip): {
			wikiScoringIconType2string = \iconType : WikiScoringIconType -> {
				switch(iconType) {
					WikiScoringCorrect(): "\\correct";
					WikiScoringAlmostCorrect(): "\\almostcorrect";
					WikiScoringIncorrect(): "\\incorrect";
					WikiScoringMissing(): "\\missing";
					WikiScoringFeedback(): "\\feedback";
				}
			}
			e = WigiBlock(WigiNativeWiki(wikiScoringIconType2string(type) + "[" + tooltip + "]"), []);
			addWigiElement(acc, e);
		}
		WikiMediaEx(type):{
			switch(type){
				PictureContent(url, title, zoom):{
					ps = ref [];
					if (title != None()){
						cs = getCharacterStyleFromWigiTextStyle(acc.textStyle);
						refArrayPush(ps, PictureDecorations([ImageFooter(either(title,""), sizeOfText(cs), colorOfText(cs))]));
						// TODO ImageFooter decoration does not work in this case because we need to provide picture's width & height somehow (eventually makeImageDecorated2 needs them to show decoration)
						refArrayPush(errors, "Could not convert picture title in " + toString(construct) + " to Wigi because ImageFooter does not work in WikiMediaEx");
					}
					if (isSome(zoom.percent)) {
						refArrayPush(ps, PictureScale(100.0 * either(zoom.percent, 1.0)));
					}
					if (isSome(zoom.toWidth)) {
						refArrayPush(ps, PictureScaleToWidth(either(zoom.toWidth, 0.0)));
					}
					if (isSome(zoom.toHeight)) {
						refArrayPush(ps, PictureScaleToHeight(either(zoom.toHeight, 0.0)));
					}
					if (zoom.mouseZoom) {
						refArrayPush(ps, PictureAllowZoom());
					}
					if (zoom.extraZoom) {
						refArrayPush(ps, PictureExtraZoom());
					}
					e = WigiBlock(WigiPicture(url, ^ps), acc.textStyle);
					addWigiElement(acc, e);
				}
				ExternalLink(url, caption):{
					el = makeWigiStory([WigiParagraph([WigiText(either(caption, url), concatWigiTextStyles(acc.textStyle, [Underline(), Fill(0x0000ff)]))], [TightWidth()])], []);
					e = WigiRecursive([el], WigiHyperlink(url), []);
					addWigiElement(acc, e);
				}
				default:{
					refArrayPush(errors, "Could not convert WikiMediaEx, content type : " + toString(type) + " to Wigi");
					acc;
				}
			}
		}
		WikiScaleEx(cons, seq):{
			isBaseText = fold(cons, true, \acc2, c2 -> acc2 && switch (c2){
					WikiSimpleConstructions(cons3, src): fold(cons3, true, \acc3, c3 -> acc3 && isSameStructType(c3, WikiBaseTextEx("")));
					default : false;
			});
			if (isBaseText){
				scale = seq |> processWVSequence |> s2d;
				nacc = WikiWigiAcc(acc.runningParagraph, acc.paragraphs, acc.paragraphStyle,zoomFontSize(scale, acc.textStyle));
				nacc2 = wikiConstructions2Wigi(cons, nacc, errors);
				WikiWigiAcc(nacc2.runningParagraph, nacc2.paragraphs, nacc2.paragraphStyle, acc.textStyle);
			} else {
				refArrayPush(errors, "Scaling is supported for plain text only in WikiScaleEx");
				acc;
			}
		}
		WikiSmartArtEx(src):{
			addWigiElement(acc, WigiBlock(WigiSmartArt(src, []), acc.textStyle));
		}
		MathNaturalSyntaxEx(src):{
			addWigiElement(acc, WigiBlock(WigiNaturalMath(src), acc.textStyle));
		}
		WikiComboBoxEx(varName, suggestedWidth, reorderElements, items):{
			vs = fold(items, "", \str, item -> str + item + "\n");
			style = arrayPush(acc.textStyle, WigiName(strRight(varName, 1)));
			e = WigiBlock(WigiComboBox(make(0), vs, reorderElements, suggestedWidth), style);
			addWigiElement(acc, e);
		}
		WikiDecoratedImageEx(id):{
			ps = ref [];
			zoomDescr = parsePictureZoom(id.targetSize);
			refArrayPush(ps, PictureWidthHeight(id.width, id.height));
			scale = 100.0 * either(zoomDescr.percent, 1.0);
			if (scale != 100.0) {
				refArrayPush(ps, PictureScale(scale))
			}
			if (isSome(zoomDescr.toWidth)) {
				refArrayPush(ps, PictureScaleToWidth(either(zoomDescr.toWidth, id.width)));
			}
			if (isSome(zoomDescr.toHeight)) {
				refArrayPush(ps, PictureScaleToHeight(either(zoomDescr.toHeight, id.height)));
			}
			if (zoomDescr.mouseZoom) {
				refArrayPush(ps, PictureAllowZoom());
			}
			if (zoomDescr.extraZoom) {
				refArrayPush(ps, PictureExtraZoom());
			}
			if (id.decorations != []) {
				refArrayPush(ps, PictureDecorations(id.decorations))
			}
			e = WigiBlock(WigiPicture(id.filename, ^ps), acc.textStyle);
			addWigiElement(acc, e);
		}
		WikiSequenceEx(sequence):{
			str = wv_sequence2string(sequence);
			if (str.second == []) {
				addWigiElement(acc, WigiBlock(WigiNativeWiki("{" + str.first + "}"), acc.textStyle))
			} else {
				refArrayPush(errors, "Could not convert kind 2 " + toString(construct) + " to Wigi");
				acc;
			}
		}
		WikiNewLine():{
			addWigiEmptyLine(acc);
		}
		WikiSuperscriptMathEx(cons):{
			// we take the last element of running paragraph as a body for Superscript
			if (acc.runningParagraph != []) {
				last = length(acc.runningParagraph) - 1;
				body : WigiElement = acc.runningParagraph[last];
				nacc = WikiWigiAcc(removeIndex(acc.runningParagraph, last), acc.paragraphs, acc.paragraphStyle, acc.textStyle);
				ts = zoomFontSize(smallSizeCoeff, acc.textStyle);
				superscript = wikiConstructions2Wigi(cons, tightWigiWikiAcc(ts), errors) |> wikiWigi2WigiElement;
				e = WigiRecursive([body, superscript], WigiSupscript(), []);
				addWigiElement(nacc, e);
			} else {
				refArrayPush(errors, "Could not convert kind 2 " + toString(construct) + " to Wigi");
				acc;
			}
		}
		MathScriptEx(type,bc, sc, src):{
			switch(type){
				MathOverscript():{
					body = wikiConstructions2Wigi(bc, tightWigiWikiAcc(acc.textStyle), errors) |> withWigiFrame;
					overscript = wikiConstructions2Wigi(sc, tightWigiWikiAcc(acc.textStyle), errors) |> withWigiFrame;
					e = WigiRecursive([body, overscript], WigiOverscript(), []);
					addWigiElement(acc, e);
				}
				MathSubscript():{
					body = wikiConstructions2Wigi(bc, tightWigiWikiAcc(acc.textStyle), errors) |> withWigiFrame;
					ts = zoomFontSize(smallSizeCoeff, acc.textStyle);
					subscript = wikiConstructions2Wigi(sc, tightWigiWikiAcc(ts), errors) |> withWigiFrame;
					e = WigiRecursive([body, subscript], WigiSubscript(), []);
					addWigiElement(acc, e);
				}
				default: {
					refArrayPush(errors, "Could not convert kind 2 " + toString(construct) + " to Wigi");
					acc;
				}
			}
		}
		WikiCalc():{
			calcStyle = arrayPush(filter(acc.textStyle, \s -> !isSameStructType(s, FontSize(0.0))), FontSize(50.0));
			e = WigiBlock(WigiCalculator(), calcStyle);
			addWigiElement(acc, e);
		}
		WikiAltTextCollectorEx(altText):{
			el = makeWigiStory([WigiParagraph([WigiText(altText, acc.textStyle)], [TightWidth()])], []);
			e = WigiRecursive([el], WigiAltText(), []);
			addWigiElement(acc, e);
		}
		MathUnknownConstruction(text) : addWigiElement(acc, WigiBlock(WigiNativeWiki("//"+text), acc.textStyle));
		default: {
			// TODO: Here, we should have a raw wiki block with the text
			refArrayPush(errors, "Could not convert kind 2 " + toString(construct) + " to Wigi");
			acc;
		}
	}
}

defWigiWikiAcc(textStyle) {
	WikiWigiAcc([], [], WikiWigiDefaultParagraphStyle, textStyle);
}

tightWigiWikiAcc(textStyle) {
	WikiWigiAcc([], [], [TightWidth()], textStyle);
}

wikiConstructions2Wigi(constrs : [WikiConstruction], acc : WikiWigiAcc, errors : ref [string]) -> WikiWigiAcc {
	fold(constrs, acc, \acc2, c -> wikiConstruction2Wigi(c, acc2, errors));
}

wikiConstructsWithTextStyle(constrs : [WikiConstruction], acc : WikiWigiAcc, errors : ref [string], fontStyle : [WigiTextStyle]) -> WikiWigiAcc {
	nacc = WikiWigiAcc(acc.runningParagraph, acc.paragraphs, acc.paragraphStyle, concatWigiTextStyles(acc.textStyle, fontStyle));
	nacc2 = wikiConstructions2Wigi(constrs, nacc, errors);
	// Undo the font style
	WikiWigiAcc(nacc2.runningParagraph, nacc2.paragraphs, nacc2.paragraphStyle, acc.textStyle);
}

addWigiElement(acc : WikiWigiAcc, e : WigiElement) -> WikiWigiAcc {
	WikiWigiAcc(arrayPush(acc.runningParagraph, e), acc.paragraphs, acc.paragraphStyle, acc.textStyle);
}

flushWikiWigi(a : WikiWigiAcc) -> WikiWigiAcc {
	listed = \s-> extractStruct(a.paragraphStyle, dummyListed) != dummyListed;
	paraStyle = concat(WikiWigiDefaultParagraphStyle, if (contains(a.paragraphStyle, CenterAlign())) [CenterAlign()] else []);
	textStyle = if (^smallText) {
			fs = extractStruct(^wikiWigiTextStyle, FontSize(11.0)).size;
			concatWigiTextStyles(^wikiWigiTextStyle, [FontSize(fs - 2.0)]);
		} else {
			^wikiWigiTextStyle;
		}
	if (a.runningParagraph == []) a else {
		e = if ((length(a.runningParagraph) == 1) && (isWigiPageBreak(a.runningParagraph[0]))) {
				a.runningParagraph[0];
			} else {
				e = normalizeWigiElements(a.runningParagraph);
				WigiParagraph(e, a.paragraphStyle);
			}
		correctedParaStyle = if (listed(a.paragraphStyle) && !^insideListed){
				insideListed := true;
				getInsideListedParagraphStyle(a, a.paragraphStyle)
			} else {
				a.paragraphStyle;
			}
		WikiWigiAcc([], arrayPush(a.paragraphs, e), correctedParaStyle, concatWigiTextStyles(textStyle, a.textStyle));
	}
}

wikiWigi2WigiElement(a : WikiWigiAcc) -> WigiElement {
	flush = flushWikiWigi(a);
	if (length(flush.paragraphs) == 1) simplifyElement(flush.paragraphs[0])
	else simplifyElement(makeWigiStory(flush.paragraphs, []));
}

withWigiFrame(e : WikiWigiAcc) -> WigiElement {
	b = wikiWigi2WigiElement(e);
	wrapped = switch(b : WigiElement) {
		WigiStory(s, v, st): b;
		WigiParagraph(p, s): makeWigiStory([b], []);
		default: makeWigiStory([WigiParagraph([b], arrayPush(e.paragraphStyle, TightWidth()) )], []);
	}
	WigiRecursive([wrapped], WigiFrame(1000.0, 1000.0, [TightWidth(), TightHeight()]), []);
}

makeWigiFullStyled(wigi : WigiElement, defaultWigiStyles : Maybe<[WigiStyles]>) -> WigiElement{
	eitherMap(defaultWigiStyles,
		\ws -> wigiForStorageFullStyles(wigi, false, ws),
		wigi
	);
}

replaceLeadingSpaces(constructions : [WikiConstruction], replacement: string) -> [WikiConstruction]{
	if (constructions == []) {
		constructions
	} else {
		firstConstr = constructions[0];
		newFirstConstr = switch(firstConstr) {
			WikiSimpleConstructions(cs, src): {
				if (cs == []) firstConstr
				else WikiSimpleConstructions(
						concat(
							replaceLeadingSpaces([cs[0]], replacement),
							tail(cs)
						), src);
			}
			WikiBaseTextEx(text): {
				WikiBaseTextEx(
					{
						trimmed = ltrim(text);
						dl = strlen(text) - strlen(trimmed);
						if (dl == 0) text
						else concatStrings(arrayPush(generate(0, dl, \i -> replacement), trimmed));
					}
				)
			}
			default: firstConstr;
		};
		concat([newFirstConstr], tail(constructions));
	}
}
