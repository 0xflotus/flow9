import algorithms;
import wigi/random_names;
import wigi/wigi_expr;
import wigi/wigi_environment_types;

export {
	// Makes a qualified name when we have the specific namespace ready
	// Notice that the namespace should include the name of the cell itself as well as the namespace!
	wigiCellName(x : string, namespace : WigiScope) -> WigiCellName;

	// Variation on wigiCellName that does not require name of cell in ns
	wigiCellName2(x : string, ns : [string]) -> WigiCellName;

	cellName2string(c : WigiCellName) -> string;
	namespace2string(c : WigiCellName) -> string;

	// Gives the namespace, including the name of the cell itself
	namespaceOfCellName(c : WigiCellName) -> WigiScope;

	// Collects all the names and values in a given namespace. Only values, not calculated cells.
	collectValuesInNamespace(env: WigiEnvironment, namespace: WigiScope) -> [Pair<string, DynamicBehaviour<WigiValue>>];

	// Collects all the names and values from formulas in a given namespace.
	collectCellformulasValuesInNamespace(env: WigiEnvironment, namespace: WigiScope) -> [Pair<string, DynamicBehaviour<WigiValue>>];

	lookupWigiCellName(env : WigiEnvironment, cell : WigiCellName) -> Maybe<Behaviour<WigiValue>>;

	addWigiName(env : WigiEnvironment, cell : WigiCellName, val : Behaviour<WigiValue>) -> WigiEnvironment;
	removeWigiName(env : WigiEnvironment, cell : WigiCellName) -> WigiEnvironment;
	renameWigiCell(env : WigiEnvironment, old : WigiCellName, new : WigiCellName) -> WigiEnvironment;

	lookupWigiFormula(env : WigiEnvironment, cell : WigiCellName) -> Maybe<WigiFormulaType>;

	addWigiFormula(env : WigiEnvironment, cell : WigiCellName, val : WigiFormulaType) -> WigiEnvironment;
	removeWigiFormula(env : WigiEnvironment, cell : WigiCellName) -> WigiEnvironment;

	// When we update a formula, this is useful
	getWigiFormula(env : WigiEnvironment, cellname : WigiCellName) -> WigiFormulaType;

	// Go look for this cellname or cellformula, when we do not know it.
	resolveWigiCell(env : WigiEnvironment, namespace : WigiScope, x : string) -> Maybe<Pair<WigiCellName, Behaviour<WigiValue>>>;

	// Finds longest existing (env.namespaces) full namespace by prefixing "ns" with "cell"'s namespace prefixes
	// or fallbacks to cell's namespace if nothing found
	resolveWigiNamespace(env : WigiEnvironment, cell : WigiCellName, ns : [string]) -> WigiScope;

	generateUniqWigiName(env : WigiEnvironment, namespace : WigiScope, base : string) -> string;

	dumpWigiEnvironment(caption: string, env: WigiEnvironment) -> void;
	// extracting env variables names from the specified namespaces
	getEnvironmentVariables(env : WigiEnvironment, cellnames : bool, cellformulas : bool, namespaces : [WigiScope]) -> [string];

	isFreeWigiName(env : WigiEnvironment, namespace : WigiScope, name : string) -> bool;

	getNamespaceCellFromWigiEnvironment(env : WigiEnvironment, cell : WigiCellName) -> [string];


	setDefaultScope(env : WigiEnvironment, key : WigiCellName, scope : WigiScope) -> void;
	getDefaultStateScope(env : WigiEnvironment) -> WigiScope;
	// Set the default scope to some children scope of global state scope. subScope is the path, not the final scope
	setDefaultStateScope(env : WigiEnvironment, scope : WigiScope) -> void;

	namespace2scope(namespace : [string]) -> WigiScope;
	scope2namespace(scope : WigiScope) -> [string];

	setStateNamespaceCell(cell : WigiCellName) -> void;

	preprocessingScope() -> WigiScope;
}

preprocessingScope() -> WigiScope { namespace2scope(["preprocessing"]) };

resolveWigiCell(env : WigiEnvironment, namespace : WigiScope, x : string) -> Maybe<Pair<WigiCellName, Behaviour<WigiValue>>> {
	// We are trying to find x in three different namespaces, accepting first found cell.
	// Namespaces: argument namespace, namespace for preprocessing temporary values and in default state scope.
	// The last one is workaround for a correct spreadsheet cells calculation.

	// we could set defaultStateScope in the environment to the some child namespace of the main state scope
	// this case we have to add root scope to be searched into, because the common case is to use their variable too
	rootScope = namespace2scope([lastElement(namespace.names, "")]);
	findmap(
		uniq([namespace, preprocessingScope(), getDefaultStateScope(env), rootScope]),
		\ns -> {
			cell = wigiCellName(x, ns);
			mbCell = lookupTree(env.cellnames, cell);
			mbFormula = lookupTree(env.cellformulas, cell);
			maybeMap(
				if (isSome(mbCell)) mbCell
				else maybeMap(lookupTree(env.cellformulas, cell), \f -> f.value),
				\value -> Pair(cell, value)
			)
		}
	)
}


lookupWigiCellName(env : WigiEnvironment, cell : WigiCellName) -> Maybe<Behaviour<WigiValue>> {
	lookupTree(env.cellnames, cell);
}

getWigiCellName(env : WigiEnvironment, wigi : WigiCellName) -> Behaviour<WigiValue> {
	lookupTreeDef(env.cellnames, wigi, const(WigiError(cellName2string(wigi) + " not found")));
}

addWigiName(env : WigiEnvironment, cell : WigiCellName, val : Behaviour<WigiValue>) -> WigiEnvironment {
	// println("Adding " + cellName2string(cell));
	ns = if (isSome(lookupWigiCellName(env, cell)))
		env.namespaces
	else incTreeValue(env.namespaces, cell.namespace);
	WigiEnvironment(setTree(env.cellnames, cell, val), env.cellformulas, ns)
}

removeWigiName(env : WigiEnvironment, cell : WigiCellName) -> WigiEnvironment {
	// println("Removing " + cellName2string(cell));
	ns = if (isSome(lookupWigiCellName(env, cell)))
		decTreeValue(env.namespaces, cell.namespace)
	else env.namespaces;
	WigiEnvironment(removeFromTree(env.cellnames, cell), env.cellformulas, ns)
}

renameWigiCell(env : WigiEnvironment, old : WigiCellName, new : WigiCellName) -> WigiEnvironment {
	value = lookupWigiCellName(env, old);
	switch (value) {
		None(): env;
		Some(v): removeWigiName(env, old) |> \e -> addWigiName(e, new, v)
	}
}

lookupWigiFormula(env : WigiEnvironment, cell : WigiCellName) -> Maybe<WigiFormulaType> {
	lookupTree(env.cellformulas, cell)
}

getWigiFormula(env : WigiEnvironment, cell : WigiCellName) -> WigiFormulaType {
	// println("Lookup formula " + cellName2string(cell));
	c = lookupTree(env.cellformulas, cell);
	switch (c) {
		None(): WigiFormulaType(WigiError("NOT FOUND: " + cell.name), make(WigiError("NOT FOUND: " + cell.name)), globalWigiNamespace);
		Some(t): t;
	}
}

addWigiFormula(env : WigiEnvironment, cell : WigiCellName, val : WigiFormulaType) -> WigiEnvironment {
	// println("Adding formula " + cellName2string(cell));
	ns = if (isSome(lookupWigiFormula(env, cell)))
		env.namespaces
	else incTreeValue(env.namespaces, cell.namespace);
	WigiEnvironment(env.cellnames, setTree(env.cellformulas, cell, val), ns)
}

removeWigiFormula(env : WigiEnvironment, cell : WigiCellName) -> WigiEnvironment {
	// println("Removing formula " + cellName2string(cell));
	ns = if (isSome(lookupWigiFormula(env, cell)))
		decTreeValue(env.namespaces, cell.namespace)
	else env.namespaces;
	WigiEnvironment(env.cellnames, removeFromTree(env.cellformulas, cell), ns)
}

wigiCellName(x : string, namespace : WigiScope) -> WigiCellName {
	// println("Make wigi name: " + x + " in " + toString(namespace));
	WigiCellName(toUpperCase(x), WigiScope(map(tail(namespace.names), toUpperCase)));
}

wigiCellName2(x : string, ns : [string]) -> WigiCellName {
	// println("Make wigi name: " + x + " in " + toString(namespace));
	WigiCellName(toUpperCase(x), WigiScope(map(ns, toUpperCase)));
}

namespaceOfCellName(c : WigiCellName) -> WigiScope {
	WigiScope(concat([c.name], c.namespace.names));
}

trimAsterisks(scope : WigiScope) -> WigiScope {
	if (scope.names == []) {
		scope
	} else {
		if(scope.names[length(scope.names) - 1] == "*") {
			subrange(scope.names, 0, length(scope.names) - 1) |> WigiScope |> trimAsterisks
		} else {
			scope
		}
	}
}

isPartOfNamespace(parent: WigiScope, child: WigiScope) -> bool {
	parent2 = trimAsterisks(parent);

	if (length(child.names) < length(parent2.names)) {
		false
	} else {
		reversedChild = map(reverseA(child.names), toUpperCase);
		reversedParent = map(reverseA(parent2.names), toUpperCase);

		subrange(reversedChild, 0, length(reversedParent)) == reversedParent
	}
}

collectValuesInNamespace(env: WigiEnvironment, namespace: WigiScope) -> [Pair<string, DynamicBehaviour<WigiValue>>] {
	pairs = foldTree(env.cellnames, [], \name, value, acc -> {
		if (isPartOfNamespace(namespace, name.namespace)) {
			switch (value: Behaviour) {
				DynamicBehaviour(__, __): arrayPush(acc, Pair(name.name, value));
				ConstBehaviour(__): acc;	// This is a calculated cell
			}
		} else {
			acc
		}
	});

//	println("Collected pairs for " + cellName2string(WigiCellName("", namespace)));
//	println(map(pairs, \p -> Pair(p.first, getValue(p.second))));

	pairs
}

collectCellformulasValuesInNamespace(env: WigiEnvironment, namespace: WigiScope) -> [Pair<string, DynamicBehaviour<WigiValue>>] {
	foldTree(env.cellformulas, [], \name, value, acc -> {
		if (isPartOfNamespace(namespace, name.namespace)) {
			switch (value.value: Behaviour) {
				DynamicBehaviour(__, __): arrayPush(acc, Pair(name.name, value.value));
				ConstBehaviour(__): acc;	// This is a calculated cell
			}
		} else {
			acc
		}
	})
}

namespace2string(c : WigiCellName) -> string {
	strGlue(reverseA(c.namespace.names), "!")
}

cellName2string(c : WigiCellName) -> string {
	namespace2string(c) + "." + c.name;
}

resolveWigiNamespace(env : WigiEnvironment, cell : WigiCellName, ns : [string]) -> WigiScope {
	switch(resolveWigiNamespace2(env, cell.namespace.names, map(ns, toUpperCase))) {
		Some(res): res;
		None(): cell.namespace
	}
}

resolveWigiNamespace2(env : WigiEnvironment, prefix : [string], ns : [string]) -> Maybe<WigiScope> {
	variant = WigiScope(concat(ns, prefix));
	switch(lookupTree(env.namespaces, variant)) {
		Some(__): Some(variant);
		None(): if (length(prefix) > 0) resolveWigiNamespace2(env, tail(prefix), ns) else None()
	}
}

isFreeWigiName(env : WigiEnvironment, namespace : WigiScope, name : string) -> bool {
	switch(resolveWigiCell(env, namespace, name)) {
		Some(__): false;
		None(): true;
	}
}

generateUniqWigiName(env: WigiEnvironment, namespace : WigiScope, base : string) -> string {
	getRandomName(base, \s -> isFreeWigiName(env, namespace, s));
}

dumpWigiEnvironment(caption: string, env: WigiEnvironment) -> void {
	println("=== WigiEnvironment (" + caption + ") ===");
	println("1. cellnames");
	traverseInOrder(env.cellnames, \key, value -> println(toString(key) + "=" + toString(getValue(value))));
	println("2. cellformulas");
	traverseInOrder(env.cellformulas, \key, value -> println(toString(key) + "(" + toString(value.formula) + ")=" + toString(getValue(value.value))));
	println("3. namespaces");
	traverseInOrder(env.namespaces, \key, value -> println(toString(key) + "=" + toString(value)));
	println("==============================================");
}

getEnvironmentVariables(env : WigiEnvironment, cellnames : bool, cellformulas : bool, namespaces : [WigiScope]) -> [string] {
	addKeys = \res, wigiCellNames ->
		fold(wigiCellNames, res, \acc, k ->
			if (contains(namespaces, k.namespace))
				arrayPush(acc, toLowerCase(k.name))
			else acc
		);

	[]
	|> (\r -> if (cellnames) addKeys(r, getTreeKeys(env.cellnames))	else r)
	|> (\r -> if (cellformulas) addKeys(r, getTreeKeys(env.cellformulas)) else r)
	|> sort
}

getNamespaceCellFromWigiEnvironment(env : WigiEnvironment, cell : WigiCellName) -> [string] {
	switch (lookupWigiCellName(env, cell) : Maybe<Behaviour<WigiValue>>) {
		Some(v): {
			value = getValue(v);
			switch (value : WigiValue) {
				WigiString(s): [s];
				WigiArray(values): map(values, wigiValue2String);
				default: {
					println("Wrong type of scopeCell value: " + wigiValue2String(value));
					globalWigiNamespace.names
				}
			}
		}
		None(): globalWigiNamespace.names;
	}
}

getDefaultStateScope(env : WigiEnvironment) -> WigiScope {
	namespace2scope(getNamespaceCellFromWigiEnvironment(env, ^defaultStateNamespaceCell))
}

setDefaultScope(env : WigiEnvironment, key : WigiCellName, scope : WigiScope) -> void {
	if (scope.names == []) {
		devtrace("setDefaultScope: empty scope is not allowed for " + toString(key));
	} else {
		eitherFn(
			lookupWigiCellName(env, key),
			\cell -> {
				namespace = scope2namespace(scope);
				if (namespace == []) {
					devtrace("setDefaultScope: empty scope is not allowed - 2 for " + toString(key));
				} else {
					switch (cell : Behaviour<WigiValue>) {
						DynamicBehaviour(__, __): {
							newValue = if (length(namespace) == 1) WigiString(namespace[0]) else WigiArray(map(namespace, \n -> WigiString(n)));
							nextDistinct(cell, newValue);
						}
						ConstBehaviour(__): devtrace("setDefaultScope: can't change state cell because it's const: " + toString(key));
					}
				}
			},
			\ -> devtrace("setDefaultScope: can't find cell by key: " + toString(key))
		);
	}
}

setDefaultStateScope(env : WigiEnvironment, scope : WigiScope) -> void {
	setDefaultScope(env, ^defaultStateNamespaceCell, scope);
}

defaultStateNamespaceCell = ref WigiCellName("", globalWigiNamespace);

setStateNamespaceCell(cell : WigiCellName) -> void {
	defaultStateNamespaceCell := cell;
}

namespace2scope(namespace : [string]) -> WigiScope {
	WigiScope(concat([""], namespace))
}

scope2namespace(scope : WigiScope) -> [string] {
	if (scope.names == [] || scope.names[0] != "") scope.names
	else tail(scope.names);
}
