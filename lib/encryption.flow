
import array;
import runtime;
import math;
import list;
import binarytree;
import renderform;

import formats/base64;
import formats/json/json;

export {
	//dummy ecryption. to be removed later
	encrypt(method: string , key: string , data:string ) -> string;
	decrypt(method: string , key: string , data:string ) -> string;

	CipherResult: (success:bool, text: string);
	encryptText(text: string, onOk : (res:CipherResult) -> void) -> void;
	decryptText(text: string, onOk : (res:CipherResult) -> void) -> void;


}

encryptionSecretPhrase = "J@72CN8aG7FOz4!8mv0MdP6ZZfQDpa1#Z";
encryptionTimeout = 1000 * 30; // 30 seconds
textEncryptionQualifier = "#EncryptionQualifier#";

encryptedText = make("");
encryptFrameReady = make(false);
sendMsgToJS = ref \m : string -> {};

encryptBase(action: string, text: string, onOk : (res:CipherResult) -> void){
	uns = ref nop;
	uns2 = ref nop;
	isFinished = ref false;
	onCipherResult = \res ->{
		isFinished := true;
		^uns();
		^uns2();
		onOk(res);
	};
	uns := subscribe2(encryptedText, \t ->{
		if (!(^isFinished)){
			j = parseJson(t);
			onCipherResult(CipherResult(true, getJsonStringField(j, "result", "")));
		}
	});
	uns2 := subscribe(encryptFrameReady, \fReady ->{
		if (fReady)
			^sendMsgToJS(action + "^@_$_@^" + text + "^@_$_@^" + encryptionSecretPhrase);
	});

	if (!getValue(encryptFrameReady)){
		//use just pure RealHtml. RealHTMLCrossDomain is hidden when modal dialog is opened
		getHostCall = \hc -> {
			sendMsgToJS := \msg : string -> {
				println("sendMsgToJS");
				hc("postMessage", [msg, "*"]);
				{}
			};
		};
		flowMsgCallBack = \args -> {
			if (length(args) == 2 && args[0] == "postMessage") {
				if (args[1] == "\"ready\"")
					next(encryptFrameReady, true)
				else
					next(encryptedText, args[1]);
			}
			""
		};
		render(
			RealHTML("/flow/crypto-js.php", "", false, make(WidthHeight(1.0,1.0)), make(false), getHostCall, flowMsgCallBack)
		);
		nop();
	}

	timer(encryptionTimeout, \->{
		if (!(^isFinished)){
			// lets return the original text if we got timeout
			onCipherResult(CipherResult(false, text));
		}
	});
}
encryptText(text: string, onOk : (res:CipherResult) -> void){
	_text = encodeBase64(text);
	encryptBase("encrypt", _text, \res -> {
		onOk(CipherResult(res.success, if (res.success) textEncryptionQualifier + res.text else text))
	});
}
decryptText(text: string, onOk : (res:CipherResult) -> void){
	if (startsWith(text, textEncryptionQualifier))
		encryptBase("decrypt", strReplace(text, textEncryptionQualifier, ""), \res -> {
			_text = if (res.success) decodeBase64(res.text) else text;
			onOk(CipherResult(res.success, _text))
		})
	else
		onOk(CipherResult(true, text))
}

encryptionQualifier = "#ARE32469#";
encrypt(method: string , key: string , data:string ) {
	data
	// if (data == ""){
	// 	""
	// } else {
	// 	enc = encodeBase64(data);
	// 	l = strlen(enc);
	// 	s1 = substring(enc, 0, l/2);
	// 	s2 = substring(enc, l/2, l/2);
	// 	encryptionQualifier + reverse(s2) + reverse(s1)
	// }
};
decrypt(method: string , key: string , data:string ) {
	if (startsWith(data, encryptionQualifier)){
		_data = strReplace(data, encryptionQualifier, "");
		l = strlen(_data);
		s1 = strLeft(_data, l/2);
		s2 = substring(_data, l/2, l/2);
		decodeBase64(reverse(s2) + reverse(s1));
	}
	else
		data
}

