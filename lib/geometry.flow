// Â© Copyright 2012 Area9 Innovation. All rights reserved
import math;

export {
	Point(x : double, y : double);
	PositionScale(pos : Point, scale : Point);

	// A constant scaling factor
	Factor(x : double, y : double);

	PositionScale2Point(ps : PositionScale) -> Point;

	deg2rad(d : double) -> double;
	rad2deg(r : double) -> double;
	dotProduct(x1 : double, y1 : double, x2 : double, y2 : double) -> double;
	//2D Vectors
	V2 : (x : double, y : double);
	V2Circle: (center : V2, radius : double);
	v2Len(v : V2) -> double;
	v2SetLen(v : V2, l : double) -> V2;
	v2Mul(v : V2, m : double) -> V2;
	v2Add(v1 : V2, v2 : V2) -> V2;
	v2Sub(v1 : V2, v2 : V2) -> V2;
	v2Orthogonal(v : V2) -> V2;
	v2Ort(v : V2) -> V2;
	v2AngleBetween(v1 : V2, v2 : V2) -> double;
	v2ScalarMul(v1 : V2, v2 : V2) -> double;
	v2Bisector(v1 : V2, v2 : V2) -> V2;
	v2Reverse(v : V2) -> V2;

	zeroPoint = Point(0., 0.);
	zeroScale = Point(1., 1.);
	zeroPositionScale = PositionScale(zeroPoint, zeroScale);

	concatPositionScale(ps1 : PositionScale, ps2 : PositionScale) -> PositionScale;
}

PositionScale2Point(ps : PositionScale) -> Point {
	Point(ps.pos.x / ps.scale.x, ps.pos.y / ps.scale.y)
}

deg2rad(d : double) -> double {
	d * PI / 180.0
}

rad2deg(r : double) -> double {
	180.0 * r / PI;
}

dotProduct(x1 : double, y1 : double, x2 : double, y2 : double) -> double {
	x1 * x2 + y1 * y2;
}

v2Len(v : V2) -> double {
	sqrt(v.x * v.x + v.y * v.y);
}

v2SetLen(v : V2, l : double) -> V2 {
	len = v2Len(v);
	if (equalDoubles(len, 0.0)) v else v2Mul(v, l / len);
}

v2Mul(v : V2, m : double) -> V2 {
	V2(v.x * m, v.y * m);
}

v2Add(v1 : V2, v2 : V2) -> V2 {
	V2(v1.x + v2.x, v1.y + v2.y);
}

v2Sub(v1 : V2, v2 : V2) -> V2 {
	V2(v1.x - v2.x, v1.y - v2.y);
}

v2Orthogonal(v : V2) -> V2 {
	V2(v.y, -v.x)
}

v2Ort(v : V2) -> V2 {
	len = v2Len(v);
	if (equalDoubles(len, 0.0)) V2(0.0, 0.0) else V2(v.x / len, v.y / len);
}

v2AngleBetween(v1 : V2, v2 : V2) -> double { //radians
	if (v2Len(v1) > 0.0 && v2Len(v2) > 0.0) {
		(v2ScalarMul(v1, v2) / (v2Len(v1)*v2Len(v2))) |> acos
	} else {
		0.0
	}
}

v2ScalarMul(v1 : V2, v2 : V2) -> double {
	v1.x*v2.x + v1.y*v2.y
}

v2Bisector(v1 : V2, v2 : V2) -> V2 {
	v2Add(
		v2Ort(v1),
		v2Ort(v2)
	)
}

v2Reverse(v : V2) -> V2 {
	V2(-v.x, -v.y);
}

concatPositionScale(ps1 : PositionScale, ps2 : PositionScale) -> PositionScale {
	PositionScale(Point(ps1.pos.x + ps2.pos.x, ps1.pos.y + ps2.pos.y), Point(ps1.scale.x * ps2.scale.x, ps1.scale.y * ps2.pos.y))
}