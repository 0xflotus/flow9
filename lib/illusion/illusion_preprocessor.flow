import illusion/illusion_values;
export {
	//Pair(correct source, either source based value or some other value)
	IuPreprocessor : (intPreprocessor : (IuIntVar) -> Behaviour<Pair<bool, int>>, doublePreprocessor : (IuDoubleVar) -> Behaviour<Pair<bool, double>>);
	IuDummyPreprocessor : IuPreprocessor;
	//Expects preprocessor that ignores preview behaviours
	//Returns value either based on source or preview value
	makeIntPreprocessor(doublePreprocessor : (IuDoubleVar) -> Behaviour<Pair<bool, double>>) -> ((IuIntVar) -> Behaviour<Pair<bool, int>>);
	makePreviewPreprocessor(sourcePreprocessor : IuPreprocessor) -> IuPreprocessor;

}

makePreviewPreprocessor(preprocessor) {
	oldIntSrc = ref "";
	doublePreprocessor = \d -> {
		oldSource = ref "";
		sourceBasedValue = preprocessor.doublePreprocessor(d);
		select2(d.source, d.previewD, \source, previewValue -> {
			if (source != ^oldSource) {
				oldSource := source;
				p = getValue(sourceBasedValue);
				if (p.first) {
					p
				} else {
					Pair(false, previewValue)
				}
			} else {
				Pair(false, previewValue)
			}
		})
	}
	intPreprocessor = doublePreprocessor |> makeIntPreprocessor;
	IuPreprocessor(intPreprocessor, doublePreprocessor);
}

makeIntPreprocessor(doublePreprocessor) {
	\i : IuIntVar -> {
		select(doublePreprocessor(IuDoubleVar(i.source, make(i.previewI |> getValue |> i2d))), \p -> Pair(p.first, floor(p.second)))
	}
}

//Just returns preview value
IuDummyPreprocessor = IuPreprocessor(\i -> select(i.previewI, \val -> Pair(false, val)), \d -> select(d.previewD, \val -> Pair(false, val)));
