import material/internal/material_dragdrop;
import material/internal/selectmarray;
import tropic/tflexiblegrid;

export {
	MFlexibleGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MFlexibleGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MReorderGrids2T(manager : MaterialManager, parent : MFocusGroup, m : MReorderGrids, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MReorderGrid2T(manager : MaterialManager, parent : MFocusGroup, items0 : [MReorderItem],
		order : DynamicBehaviour<[int]>, style : [MReorderGridStyle], m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
	MDynamicGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic;
}

FlexibleGridItem(m : Material, tr : DynamicBehaviour<Point>, wh : DynamicBehaviour<Maybe<WidthHeight>>);

MFlexibleGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MFlexibleGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	en = extractStruct(m.style, MEnabled(const(true))).enabled;
	enableAnimation = contains(m.style, MEnableAnimation());
	cropSize = contains(m.style, MGridCropByContent());
	keepOrder = contains(m.style, MGridKeepOrder());
	verticalGrid = contains(m.style, MGridVertical());
	groupByCols = extractStruct(m.style, MGridGroupByCols(!verticalGrid)).cols;

	maxRows = if (!verticalGrid && keepOrder) -1 else extractStruct(m.style, MMaxRows(-1)).rows;

	(\par -> TFlexibleGrid(
		fmap(m.items, \it -> m2t(it, par)),
		concat(extractStructMany(m.style, CenterAlign()), extractStructMany(m.style, EndAlign()))
		|> (\st -> if (enableAnimation) arrayPush(st, TAnimation(manager.manager.deltaTimer)) else st)
		|> (\st -> if (cropSize) arrayPush(st, TCropView()) else st)
		|> (\st -> if (keepOrder) arrayPush(st, TOrdered(false)) else st)
		|> (\st -> if (verticalGrid) arrayPush(st, TVertical()) else st)
		|> (\st -> if (groupByCols) arrayPush(st, TGroupByCols()) else st)
		|> (\st -> arrayPush(st, TEnabled(en)))
	))
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MFlexibleGrid",
			[],
			f
		)
	)
}

MReorderGrid2T(manager : MaterialManager, parent : MFocusGroup, items0 : [MReorderItem],
	order : DynamicBehaviour<[int]>, style : [MReorderGridStyle], m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	en = extractStruct(style, MEnabled(const(true))).enabled;
	enableAnimation = contains(style, MEnableAnimation());
	cropSize = false;//contains(style, MGridCropByContent());
	keepOrder = true;//contains(style, MGridKeepOrder());
	verticalGrid = contains(style, MGridVertical());
	groupByCols = extractStruct(style, MGridGroupByCols(!verticalGrid)).cols;
	borders = extractStruct(style, MBorders(0.)).borders;
	grabDelay = extractStructMany(style, MGrabDelay(0));
	customDraggingOrder = false;//contains(style, MReorderCustomDraggingOrder());
	itemsLength = length(items0) + if (customDraggingOrder) 2 else 1;

	dropSpotM = None(); //tryExtractStruct(style, MReorderDropSpot(MEmpty()));
	items =
		eitherMap(
			dropSpotM,
			\__ -> map(items0, \it -> MReorderItem(it.content, concat([MDragging(make(false))], it.style))),
			items0
		);

	uniqueIds = ref makeTree();
	getUniqueIdByIndex = \index -> lookupTreeSet(uniqueIds, index, \__ -> makeTropicTag(manager));
	getIndexByUniqueId = \uniqueId -> either(findInOrder(^uniqueIds, \k, v -> if (v == uniqueId) Some(k) else None()), -1);
	onHover = generate(0, itemsLength, \__ -> make(-1));

	draggingItem = extractStruct(style, MDraggingItem(make(-1))).item;
	hoveringItem = extractStruct(style, MHoveringItem(make(-1))).item;

	orderIn = make(concat([itemsLength - 1], generate(0, itemsLength - 1, \i -> if (length(getValue(order)) > i) getValue(order)[i] else i)));

	(\par -> TFlexibleGrid(
		mapi(
			items,
			\i, it -> {
				extractStruct(it.style, MReorderItemId(ref -1)).id := getUniqueIdByIndex(i);
				itEn = extractStruct(it.style, MEnabled(const(true))).enabled;
				isDragging : MDragging = extractStruct(it.style, MDragging(make(false)));

				MDragDrop2T(
					manager,
					par,
					MDragDrop(
						const(getUniqueIdByIndex(i)),
						it.content,
						concat([MHoveringId(onHover[i]), MDraggingEnabled(fand(en, itEn)), isDragging], grabDelay)
					),
					m2t
				)
				|> (\f -> TBorder4(borders, f))
				|> (\f ->
					TConstruct(
						[
							makeSubscribe2(onHover[i], \hov0 -> {
								hov = getIndexByUniqueId(hov0);

								if (hov != -1 && hov != i && hov >= 0 && hov < itemsLength) {
									order0 = getValue(orderIn);

									nextDistinct(
										orderIn,
										insertArray(
											removeIndex(order0, elemIndex(order0, hov, 0)),
											if (i == itemsLength - 1)
												1
											else
												elemIndex(order0, i, 0),
											hov
										)
									);
								}
							})
						],
						f
					)
				)
			}
		)
		|> const,
		concat(extractStructMany(style, CenterAlign()), extractStructMany(style, EndAlign()))
		|> (\st -> if (enableAnimation) arrayPush(st, TAnimation(manager.manager.deltaTimer)) else st)
		|> (\st -> if (cropSize) arrayPush(st, TCropView()) else st)
		|> (\st -> if (keepOrder) arrayPush(st, TOrdered(false)) else st)
		|> (\st -> if (verticalGrid) arrayPush(st, TVertical()) else st)
		|> (\st -> if (groupByCols) arrayPush(st, TGroupByCols()) else st)
		|> (\st -> arrayPush(st, TOrder(orderIn)))
		|> (\st -> arrayPush(st, TEnabled(en)))
	)
	|> (\f ->
		TConstruct(
			[
				makeSubscribe(manager.manager.dragging, \dr0 -> {
					dr = getIndexByUniqueId(dr0);
					nextDistinct(
						draggingItem,
						if (dr >= 0 && dr < itemsLength - 1)
							dr
						else
							-1
					);
				}),
				makeSubscribe(manager.manager.hovering, \hov0 -> {

					hov = getIndexByUniqueId(hov0);
					nextDistinct(
						hoveringItem,
						if (hov >= 0 && hov < itemsLength && getValue(manager.manager.dragging) != -1)
							hov
						else
							-1
					);
				}),
			],
			f
		)
	))
	|> (\f ->
		MComponentGroup2T(
			manager,
			parent,
			"MReorderGrid",
			[IScriptBehaviour("order", order, ISInputValue([], "[int]", true))],
			f
		)
	)
}

MReorderGrids2T(manager : MaterialManager, parent : MFocusGroup, m : MReorderGrids, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	itemsLength : [int] = map(m.items, length);

	itemVisible : [[MReorderItemVisible]] =
		generate(0, length(m.items), \i -> {
			start = sum(subrange(itemsLength, 0, i));
			end = start + itemsLength[i];

			generate(0, sum(itemsLength), \j -> MReorderItemVisible(make(j >= start && j < end)))
		});

	reorderId : [[MReorderItemId]]=
		generate(0, length(m.items), \__ ->
			generate(0, sum(itemsLength), \__ -> MReorderItemId(ref -1))
		);

	items =
		mapi(m.items, \i, it -> {
			start = sum(subrange(itemsLength, 0, i));
			end = start + itemsLength[i];

			mapi(concatA(m.items), \j, it0 -> MReorderItem(it0.content, replaceStructMany(it0.style, [itemVisible[i][j], reorderId[i][j]])))
		});

	order = generate(0, length(m.items), \i -> make(
			if (length(getValue(m.order)) > i)
				getValue(m.order)[i]
			else {
				start = sum(subrange(itemsLength, 0, i));
				end = start + itemsLength[i];

				fold(generate(0, sum(itemsLength), \k -> k), Pair([], []), \acc, j ->
					if (j >= start && j < end)
						Pair(arrayPush(acc.first, j), acc.second)
					else
						Pair(acc.first, arrayPush(acc.second, j))
				)
				|> (\f -> concat(f.first, f.second))
			}
		));

	style = generate(0, length(m.items), \i -> if (length(m.style) > i) m.style[i] else []);

	dragging0 = generate(0, length(m.items), \i -> extractStruct(style[i], MDraggingItem(make(-1))).item);
	hovering0 = generate(0, length(m.items), \i -> extractStruct(style[i], MHoveringItem(make(-1))).item);

	draggingB = fmerge(dragging0);
	hoveringB = fmerge(hovering0);
	orderB = fmerge(order);

	mapi(items, \i, it ->
		MReorderGrid2T(
			manager,
			parent,
			it,
			order[i],
			replaceStruct(replaceStruct(style[i], MDraggingItem(dragging0[i])), MHoveringItem(hovering0[i])),
			m2t
		)
	)
	|> m.fn
	|> (\f -> m2t(f, parent))
	|> (\f ->
		TConstruct([
			make2Subscribe2(draggingB, hoveringB, \dr, hv -> {
				drId = foldi(dr, -1, \i, acc, dr0 -> if (dr0 != -1) i else acc);
				hvId = foldi(hv, -1, \i, acc, hv0 -> if (hv0 != -1 && i != drId) i else acc);

				if (drId != -1 && hvId != -1 && dr[drId] != -1 && hv[hvId] != -1) {
					next(manager.manager.dragging, ^(reorderId[hvId][dr[drId]].id));

					nextDistinct(itemVisible[drId][dr[drId]].visible, false);
					nextDistinct(itemVisible[hvId][dr[drId]].visible, true);

					newOrder = removeFirst(getValue(order[hvId]), dr[drId]);
					nextDistinct(order[hvId], insertArray(newOrder, elemIndex(newOrder, hv[hvId], 0), dr[drId]));
				}
			}),
			makeSubscribe(orderB, \or ->
				nextDistinct(m.order, mapi(or, \i, or0 -> foldi(or0, [], \j, acc, or1 ->
					if (i < length(itemsLength) && or1 < itemsLength[i] && getValue(itemVisible[i][or1].visible)) arrayPush(acc, or1) else acc)))
			),
			makeSubscribe2(m.order, \or ->
				iteri(or, \i, or0 -> {
					start = sum(subrange(itemsLength, 0, i));
					end = start + itemsLength[i];

					fold(generate(0, sum(itemsLength), \k -> k), [], \acc, j ->
						if (contains(or[i], j)) {
							nextDistinct(itemVisible[i][j].visible, true);
							acc
						} else {
							nextDistinct(itemVisible[i][j].visible, false);
							arrayPush(acc, j)
						}
					)
					|> (\f2 -> nextDistinct(order[i], concat(or0, f2)))
				})
			),
		], f)
	)
}

MDynamicGridContainer(id : DynamicBehaviour<int>, tr : DynamicBehaviour<Point>);

MDynamicGrid2T(manager : MaterialManager, parent : MFocusGroup, m : MDynamicGrid, m2t : (Material, MFocusGroup) -> Tropic) -> Tropic {
	items = ffuseinit(m.items, make([]));
	itemsLength = fselect(items.first, length |> FLift);

	boxSize = extractStruct(m.style, MBoxSize(make(zeroWH))).wh;
	contentSize = make(zeroWH);
	position = make(zeroPoint);
	containers = make([]);
	itemSize = extractStruct(m.style, MItemSize(fselect(contentSize, FLift(\cs -> WidthHeight(cs.width / 5., cs.width / 5.))))).wh;

	SelectMGroup2T(manager, parent, containers, \__, __, c, p -> {
		TransformTAcc2(\t2a -> {
				b1 =
					TTranslate(
						c.tr,
						TAvailable(
							TCenter(TMutable(fselect2(c.id, items.first, FLift2(\i, it -> m2t(if (existsIndex(it, i)) it[i] else TEmpty(), p))))),
							TSized(itemSize)
						)
					)
					|> t2a;

				TAcc(
					b1.form,
					TFormMetrics(
						zero,
						zero,
						zero
					),
					zero,
					zero,
					zero,
					zero,
					zero,
					zero,
					const(false),
					false,
					false,
					b1.disposers
				)
			}
		)
	})
	|> (\f -> TFixSize(f, TSized(contentSize)))
	|> (\f ->
		MScroll2T(
			manager,
			parent,
			MScroll(
				f,
				TFillXY(),
				[MScrollPosition(position), MScrollWidthHeight(make(zeroWH), boxSize)]
			),
			m2t
		)
	)
	|> (\f ->
		TConstruct(
			[
				items.second,
				make4Subscribe(boxSize, itemSize, position, itemsLength, \wh, sz, p, il -> {
					// items count in the row
					rowCount = max(floor(wh.width / sz.width), 1);
					// how much items on the screen
					itemCount = min((ceil(wh.height / sz.height) + 1) * rowCount, il);
					// max avaliable value of the first index
					topItemMax = (ceil(i2d(il - itemCount) / i2d(rowCount)) * rowCount) + if ((il - itemCount) % rowCount > 0) rowCount else 0;
					// index of the first shown item
					topItem = min(max(floor(p.y / sz.height) * rowCount, 0), topItemMax);

					if (itemCount > 0) {
						if (length(getValue(containers)) > itemCount) {
							nextDistinct(
								containers,
								subrange(getValue(containers), 0, itemCount)
							);
						} else if (length(getValue(containers)) < itemCount) {
							nextDistinct(
								containers,
								concat(
									getValue(containers),
									generate(length(getValue(containers)), itemCount, \i -> MDynamicGridContainer(make(-1), make(zeroPoint)))
								)
							);
						}

						topId = max(getValue(getValue(containers)[0].id), 0);

						iteri(getValue(containers), \i, c -> {
							idMod = (topId + i - topItem) % itemCount;
							id = (if (idMod >= 0) idMod else itemCount + idMod) + topItem;

							nextDistinct(c.id, id);
							nextDistinct(c.tr, Point(i2d(id % rowCount) * sz.width, i2d(id / rowCount) * sz.height));
						});
					} else {
						nextDistinct(containers, []);
					}

					nextDistinct(contentSize, WidthHeight(i2d(rowCount) * sz.width, dceil(i2d(il) / i2d(rowCount)) * sz.height));
				})
			],
			f
		)
	)
}

updateFreePoints(
	freePoints : ref [Point],
	keepOrder : bool,
	verticalGrid : bool,
	groupByCols : bool,
	maxRows : int,
	newSizes : [WidthHeight],
	stageSize0 : double,
	getTranslatePoint : (int) -> DynamicBehaviour<Point>,
	onEnd : (freePoint : Point, sz : WidthHeight) -> void) -> void {

	maxSize =
		if (groupByCols) {
			maxSize = either(maxA(map(newSizes, \sz2 -> if (verticalGrid) sz2.height else sz2.width)), 0.);
			sumSize = dsum(map(newSizes, \sz2 -> if (verticalGrid) sz2.width else sz2.height));
			cols = i2d(floor(stageSize0 / maxSize));
			sumSize / cols;
		} else {
			doubleMax
		};

	emptyPoint = Point(doubleMax, doubleMax);

	iteri(newSizes, \i, sz -> {
		freePoint0 : Point =
			fold(^freePoints, emptyPoint, \acc, p -> {
				isSuitableSize =
					if (verticalGrid)
						((p.y + sz.height <= stageSize0 || p.y == 0. || maxRows > 0) && p.x < maxSize)
					else
						((p.x + sz.width <= stageSize0 || p.x == 0.) && p.y < maxSize);

				countLeftTop = \ ->
					if (if (groupByCols) !verticalGrid else verticalGrid)
						((p.x < acc.x) || (p.x == acc.x && p.y < acc.y))
					else
						((p.y < acc.y) || (p.y == acc.y && p.x < acc.x));

				filterCrossings = \ ->
					foldi(subrange(newSizes, 0, i), true, \j, acc2, sz2 ->
						if (acc2) {
							tr = getValue(getTranslatePoint(j));

							!((p.x + sz.width > tr.x) && (p.y + sz.height > tr.y) &&
								(p.x < tr.x + sz2.width) && (p.y < tr.y + sz2.height));
						} else {
							false
						}
					);

				if (isSuitableSize && countLeftTop() && filterCrossings())
					p
				else
					acc
			});

		freePoint =  if (maxRows > 0) {
			nextDistinct(getTranslatePoint(i), freePoint0);

			if (getOverlapingRectanglesCount(Quadruple(freePoint0.x, 0., freePoint0.x + sz.width, freePoint0.y + sz.height), newSizes, getTranslatePoint) > maxRows) {
				fold(^freePoints, emptyPoint, \acc, p -> {
					isSuitableSize = getOverlapingRectanglesCount(Quadruple(p.x, 0., p.x + sz.width, p.y + sz.height), newSizes, getTranslatePoint) < maxRows;

					countLeftTop = \ -> ((p.x < acc.x) || (p.x == acc.x && p.y < acc.y));

					filterCrossings = \ ->
						foldi(subrange(newSizes, 0, i), true, \j, acc2, sz2 ->
							if (acc2) {
								tr = getValue(getTranslatePoint(j));

								!((p.x + sz.width > tr.x) && (p.y + sz.height > tr.y) &&
									(p.x < tr.x + sz2.width) && (p.y < tr.y + sz2.height));
							} else {
								false
							}
						);

					if (isSuitableSize && countLeftTop() && filterCrossings())
						p
					else
						acc
				});
			} else {
				freePoint0;
			}
		} else {
			freePoint0;
		};

		freePoints :=
			if (keepOrder) {
				if (if (groupByCols) !verticalGrid else verticalGrid) {
					[
						Point(freePoint.x, freePoint.y + sz.height),
						Point(either(maxA(arrayPush(map(^freePoints, \fp -> fp.x), freePoint.x + sz.width)), freePoint.x + sz.width), 0.)
					]
				} else {
					[
						Point(freePoint.x + sz.width, freePoint.y),
						Point(0., either(maxA(arrayPush(map(^freePoints, \fp -> fp.y), freePoint.y + sz.height)), freePoint.y + sz.height))
					]
				}
			} else {
				newPoints =
					concat3(
						^freePoints,
						[
							Point(freePoint.x + sz.width, freePoint.y),
							Point(freePoint.x + sz.width, freePoint.y + sz.height),
							Point(freePoint.x, freePoint.y + sz.height)
						],
						if (if (groupByCols) !verticalGrid else verticalGrid) {
							if (freePoint.y != 0.)
								[Point(freePoint.x + sz.width, 0.)]
							else
								[]
						} else {
							if (freePoint.x != 0.)
								[Point(0., freePoint.y + sz.height)]
							else
								[]
						}
					);

				currentSizes = subrange(newSizes, 0, i);

				fold(newPoints, [], \acc2, p -> {
					validPoint =
						foldi(currentSizes, true, \j, acc3, sz2 ->
							if (acc3) {
								tr = getValue(getTranslatePoint(j));

								if (groupByCols) {
									if (verticalGrid)
										!(p.y >= tr.y && p.y < tr.y + sz2.height && (p.x < tr.x + sz2.width || p.y != tr.y))
									else
										!(p.x >= tr.x && p.x < tr.x + sz2.width && (p.y < tr.y + sz2.height || p.x != tr.x));
								} else {
									!(p.x >= tr.x && p.y >= tr.y && p.x < tr.x + sz2.width && p.y < tr.y + sz2.height);
								}
							} else {
								false
							}
						);

					if (validPoint)
						arrayPush(acc2, p)
					else
						acc2
				});
			}

		nextDistinct(getTranslatePoint(i), freePoint);
		onEnd(freePoint, sz);
	})
}

// TODO: optimize
getOverlapingRectanglesCount(
	rect : Quadruple<double, double, double, double>,
	sizes : [WidthHeight],
	getTranslatePoint : (int) -> DynamicBehaviour<Point>
) -> int {
	foldi(sizes, Pair(makeSet(), 0), \i, acc, sz -> {
		tr = getValue(getTranslatePoint(i));

		if (!containsSet(acc.first, tr.y)) {
			if (tr.x + sz.width > rect.first && tr.x < rect.third && tr.y + sz.height > rect.second && tr.y < rect.fourth)
				Pair(insertSet(acc.first, tr.y), acc.second + 1)
			else
				acc;
		} else {
			acc;
		}
	}).second
}