import array;
import runtime;
import bits;
import maybe;

export {
    BitSet(
        data : BitSetArray, 
        bitcount: int
    );

    makeBitSetMutable(bitcount: int) -> BitSet;
    makeBitSetImmutable(bitcount: int) -> BitSet;
    setBitSet(set: BitSet, i: int) -> BitSet;
    unsetBitSet(set: BitSet, i: int) -> BitSet;
    getBitSet(set: BitSet, i: int) -> Maybe<bool>;
    convertBitSet2Immutable(set: BitSet) -> BitSet;
    convertBitSet2Mutable(set: BitSet) -> BitSet;
    
    // Fast operations of union/intersection of two bitsets. 
    // We suppose, that these sets have the same number of bits, otherwise
    // None is returned.
    mergeBitSetImmutable(set1: BitSet, set2: BitSet) -> Maybe<BitSet>;
    intersectBitSetImmutable(set1: BitSet, set2: BitSet) -> Maybe<BitSet>;
    subtractBitSetImmutable(set1: BitSet, set2: BitSet) -> Maybe<BitSet>;
    complementBitSetImmutable(set: BitSet) -> BitSet;
}

BitSetArray ::= BitSetArrayMutable, BitSetArrayImmutable;
	BitSetArrayMutable(array : [ref int]);
	BitSetArrayImmutable(array : [int]);

makeBitSetMutable(bitcount) {
    n = (bitcount + 31) / 32;
	BitSet(BitSetArrayMutable(map(enumFromTo(0, n-1), \e -> ref 0)), bitcount);
}

makeBitSetImmutable(bitcount) {
    n = (bitcount + 31) / 32;
	BitSet(BitSetArrayImmutable(map(enumFromTo(0, n-1), \e -> 0)), bitcount);
}

setBitSet(set, i) {
	if (i >= 0 && i < set.bitcount) {
		switch (set.data) {
			BitSetArrayMutable(array): {
				array[i / 32] := bitOr(^(array[i / 32]), bitShl(1, i % 32));
				set;
			}
			BitSetArrayImmutable(array): {
				ind = i / 32;
				newArray = mapi(array,
					\j, b -> {
						if (j != ind) b else {
							bitOr(b, bitShl(1, i % 32));
						}
					}
				);
				BitSet(BitSetArrayImmutable(newArray), set.bitcount);
			}
		}
	} else {
		set;
	}
}

unsetBitSet(set, i) {
	if (i >= 0 && i < set.bitcount) {
		switch (set.data) {
			BitSetArrayMutable(array): {
				array[i / 32] := bitAnd(^(array[i / 32]), bitNot(bitShl(1, i % 32)));
				set;
			}
			BitSetArrayImmutable(array): { 
				ind = i / 32;
				newArray = mapi(array,
					\j, b -> {
						if (j != ind) b else {
							bitAnd(b, bitNot(bitShl(1, i % 32)));
						}
					}
				);
				BitSet(BitSetArrayImmutable(newArray), set.bitcount);
			}
		}
	} else {
		set;
	}
}

getBitSet(set, i) {
	if ((i >= 0) && (i < set.bitcount)) {
		switch (set.data) {
			BitSetArrayMutable(array):
				Some(bitAnd(^(array[i / 32]), bitShl(1, i % 32)) != 0);
			BitSetArrayImmutable(array): 
				Some(bitAnd(array[i / 32], bitShl(1, i % 32)) != 0);
		}
	} else {
		None();
	}
}

convertBitSet2Immutable(set: BitSet) -> BitSet {
	switch (set.data) {
		BitSetArrayMutable(array):
			BitSet(BitSetArrayImmutable(map(array, \ri -> ^ri)), set.bitcount);
		BitSetArrayImmutable(__): 
			set;
	}
}

convertBitSet2Mutable(set: BitSet) -> BitSet {
	switch (set.data) {
		BitSetArrayMutable(__):
			set;
		BitSetArrayImmutable(array): 
			BitSet(BitSetArrayMutable(map(array, \i -> ref i)), set.bitcount);
	}
}

mergeBitSetImmutable(set1: BitSet, set2: BitSet) -> Maybe<BitSet> {
	bitSetBinaryOperationImmutable(set1, set2, \v1, v2 -> bitOr(v1, v2)) 
}

intersectBitSetImmutable(set1: BitSet, set2: BitSet) -> Maybe<BitSet> {
	bitSetBinaryOperationImmutable(set1, set2, \v1, v2 -> bitAnd(v1, v2)) 
}

subtractBitSetImmutable(set1: BitSet, set2: BitSet) -> Maybe<BitSet> {
	bitSetBinaryOperationImmutable(set1, set2, \v1, v2 -> bitAnd(v1, bitNot(v2))) 
}

bitSetBinaryOperationImmutable(set1: BitSet, set2: BitSet, operation : (int, int) -> int) -> Maybe<BitSet> {
	if (set1.bitcount != set2.bitcount) None() else {
		mergedArray = switch (set1.data) {
			BitSetArrayMutable(array1):
				switch (set2.data) {
					BitSetArrayMutable(array2):
						mapi(array1, \i, v1 -> operation(^v1, ^(array2[i])));
					BitSetArrayImmutable(array2): 
						mapi(array1, \i, v1 -> operation(^v1, array2[i]));
				}
			BitSetArrayImmutable(array1): 
				switch (set2.data) {
					BitSetArrayMutable(array2):
						mapi(array1, \i, v1 -> operation(v1, ^(array2[i])));
					BitSetArrayImmutable(array2): 
						mapi(array1, \i, v1 -> operation(v1, array2[i]));
				}
		}
		Some(BitSet(BitSetArrayImmutable(mergedArray), set1.bitcount));
	}
}

complementBitSetImmutable(set: BitSet) -> BitSet {
	complementedArray = switch (set.data) {
		BitSetArrayMutable(array): map(array, \i -> bitNot(^i));
		BitSetArrayImmutable(array): map(array, \i -> bitNot(i));
	}
	BitSet(BitSetArrayImmutable(complementedArray), set.bitcount);
}
