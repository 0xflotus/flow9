import array;
import runtime;
import bits;
import maybe;

export {
	BitVector(
		data : [int], 
		bitcount: int
	);

	// Create an instance of BitVector and fill it using init function.
	makeBitVector(bitcount: int, init : (int) -> bool) -> BitVector;

	// This operation has O(n) complexity
	setBitVector(set: BitVector, i: int) -> BitVector;

	// This operation has O(n) complexity
	unsetBitVector(set: BitVector, i: int) -> BitVector;

	// This operation has O(1) complexity
	getBitVector(set: BitVector, i: int) -> Maybe<bool>;

	// Fast operations of union/intersection of two bitsets. 
	// We suppose, that these sets have the same number of bits, otherwise
	// None is returned.
	mergeBitVectorImmutable(set1: BitVector, set2: BitVector) -> Maybe<BitVector>;
	intersectBitVectorImmutable(set1: BitVector, set2: BitVector) -> Maybe<BitVector>;
	subtractBitVectorImmutable(set1: BitVector, set2: BitVector) -> Maybe<BitVector>;
	complementBitVectorImmutable(set: BitVector) -> BitVector;
}

makeBitVector(bitcount : int, init : (int) -> bool) {
	n = (bitcount + 31) / 32;
	BitVector(
		map(enumFromTo(0, n - 1), 
			\i -> {
				k = i * 32;
				fold(enumFromTo(0, 31), 0,
					\acc, j -> if (init(j + k)) acc + bitShl(1, j) else acc
				)
			}
		), 
		bitcount
	);
}

setBitVector(set, i) {
	if (i >= 0 && i < set.bitcount) {
		ind = i / 32;
		newArray = mapi(set.data,
			\j, b -> {
				if (j != ind) b else {
					bitOr(b, bitShl(1, i % 32));
				}
			}
		);
		BitVector(newArray, set.bitcount);
	} else {
		set;
	}
}

unsetBitVector(set, i) {
	if (i >= 0 && i < set.bitcount) {
		ind = i / 32;
		newArray = mapi(set.data,
			\j, b -> {
				if (j != ind) b else {
					bitAnd(b, bitNot(bitShl(1, i % 32)));
				}
			}
		);
		BitVector(newArray, set.bitcount);
	} else {
		set;
	}
}

getBitVector(set, i) {
	if ((i >= 0) && (i < set.bitcount)) {
		Some(bitAnd(set.data[i / 32], bitShl(1, i % 32)) != 0);
	} else {
		None();
	}
}

mergeBitVectorImmutable(set1: BitVector, set2: BitVector) -> Maybe<BitVector> {
	bitSetBinaryOperationImmutable(set1, set2, \v1, v2 -> bitOr(v1, v2)) 
}

intersectBitVectorImmutable(set1: BitVector, set2: BitVector) -> Maybe<BitVector> {
	bitSetBinaryOperationImmutable(set1, set2, \v1, v2 -> bitAnd(v1, v2)) 
}

subtractBitVectorImmutable(set1: BitVector, set2: BitVector) -> Maybe<BitVector> {
	bitSetBinaryOperationImmutable(set1, set2, \v1, v2 -> bitAnd(v1, bitNot(v2))) 
}

bitSetBinaryOperationImmutable(set1: BitVector, set2: BitVector, operation : (int, int) -> int) -> Maybe<BitVector> {
	if (set1.bitcount != set2.bitcount) None() else {
		Some(BitVector(
			mapi(set1.data, \i, v1 -> operation(v1, set2.data[i])), 
			set1.bitcount
		));
	}
}

complementBitVectorImmutable(set: BitVector) -> BitVector {
	BitVector(map(set.data, \i -> bitNot(i)), set.bitcount);
}
