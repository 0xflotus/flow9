#!/usr/bin/python3

# This script starts the flowc as a java application.
# NOTE: flowc must be found iside directories in PATH env.
#
# In case when server is started, this script provides
# a port tunneling for the server, which rejects
# requests while server is busy (i.e. do not queue
# requests). 

import subprocess
import re
import os
import sys
import _thread
import time
import socket

def find_flowdir():
	paths = os.environ['PATH'].split(os.pathsep)
	for path in paths:
		if os.path.isfile(os.path.join(path, 'flowc')):
			return os.path.split(path)[0]
	return None

def run_flowc1(args):
	java_ver = subprocess.Popen(["java", "-fullversion"], stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[1]
	ver_no = int(re.match(r'[^"]*"([0-9]+)', java_ver.decode('utf-8')).group(1))
	flowdir = find_flowdir()
	
	if flowdir == None:
		print("Flow directory not found: flowc must be found by PATH environment variable")
		print("PATH variable: " + os.environ['PATH'])
		sys.exit(1)

	run_args = ['java', '-Xss12m', '-Xmx3g', '-Xms1g']
	if ver_no < 9:
		run_args += ['-XX:+UseConcMarkSweepGC', '-XX:ParallelGCThreads=2']
	run_args += ['-cp', flowdir + 'src/java/.:', '-jar', flowdir + '/tools/flowc/flowc.jar', 'bin-dir=' + flowdir + '/bin']
	run_args += args
	subprocess.Popen(run_args).communicate()

def server(input_port, server_port):
	try:
		dock_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		dock_socket.bind(('', input_port))
		dock_socket.listen(5)
		while True:
			client_socket = dock_socket.accept()[0]
			server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			server_socket.connect(('localhost', server_port))
			_thread.start_new_thread(forward_request, (client_socket, server_socket))
			_thread.start_new_thread(forward_response, (server_socket, client_socket))
	except:
		print("Couldn't start server via proxy")
		sys.exit(1)

request_sent = False

def forward_request(source, destination):
	global request_sent
	if request_sent:
		source.sendall('HTTP/1.1 503 Server is busy.\r\n\r\n'.encode())
	else:
		request_sent = True
		string = ' '
		while string:
			try:
				string = source.recv(1024)
			except source.error: #Exception as ex:
				string = False
				#print("an exception: '" + str(ex) + "'")
				pass
			if string:
				destination.sendall(string)
			else:
				source.shutdown(socket.SHUT_RD)
				destination.shutdown(socket.SHUT_WR)

def forward_response(source, destination):
	global request_sent
	string = ' '
	while string:
		string = source.recv(1024)
		if string:
			destination.sendall(string)
		else:
			request_sent = False
			destination.shutdown(socket.SHUT_WR)

def main():
	args = sys.argv[1:]
	if 'server-mode=1' in args:
		input_port = 10001
		server_port = 10002
		server_args = []
		port_explicitly_set = False
		for arg in args:
			port = re.match(r'server-port=(\d+)', arg)
			if not port == None:
				input_port = int(port.group(1))
				server_port = input_port + 1
				server_args += ["server-port=" + str(server_port)]
				port_explicitly_set = True
			else:
				server_args += [arg]
		if not port_explicitly_set:
			server_args += ["server-port=" + str(server_port)]
		_thread.start_new_thread(server, (input_port, server_port))
		run_flowc1(server_args)
	else:
		run_flowc1(args)

if __name__ == '__main__':
	main()
